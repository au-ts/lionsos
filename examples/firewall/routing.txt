
build/routing_external.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000200000 <_start>:
.section ".text.start"

.global _start;
.type _start, %function;
_start:
    b main
  200000:	14000868 	b	2021a0 <main>
	...

0000000000200010 <hash>:
#include <sddf/serial/config.h>
#include <sddf/timer/client.h>
#include <sddf/timer/config.h>
#include <string.h>

#include "routing.h"
  200010:	5287fc21 	mov	w1, #0x3fe1                	// #16353
  200014:	72bff001 	movk	w1, #0xff80, lsl #16
  200018:	52808042 	mov	w2, #0x402                 	// #1026
  20001c:	9ba17c01 	umull	x1, w0, w1
  200020:	d36afc21 	lsr	x1, x1, #42
#include "firewall_arp.h"
  200024:	1b028020 	msub	w0, w1, w2, w0
  200028:	d65f03c0 	ret
  20002c:	d503201f 	nop

0000000000200030 <hashtable_init>:
#include "hashmap.h"
#include "firewall_config.h"
#include "linkedlist.h"
#include "protocols.h"
  200030:	d2860302 	mov	x2, #0x3018                	// #12312
  200034:	8b020001 	add	x1, x0, x2
  200038:	cb0103e1 	neg	x1, x1
  20003c:	f2400c23 	ands	x3, x1, #0xf
  200040:	54001380 	b.eq	2002b0 <hashtable_init+0x280>  // b.none

  200044:	91400c04 	add	x4, x0, #0x3, lsl #12
  200048:	f27f083f 	tst	x1, #0xe
  20004c:	3900609f 	strb	wzr, [x4, #24]
#include "protocols.h"
  200050:	54001240 	b.eq	200298 <hashtable_init+0x268>  // b.none

  200054:	3900649f 	strb	wzr, [x4, #25]
#include "protocols.h"
  200058:	f100087f 	cmp	x3, #0x2
  20005c:	54001249 	b.ls	2002a4 <hashtable_init+0x274>  // b.plast

  200060:	3900689f 	strb	wzr, [x4, #26]
#include "protocols.h"
  200064:	f27e043f 	tst	x1, #0xc
  200068:	540012a0 	b.eq	2002bc <hashtable_init+0x28c>  // b.none

  20006c:	39006c9f 	strb	wzr, [x4, #27]
#include "protocols.h"
  200070:	f100107f 	cmp	x3, #0x4
  200074:	540012a9 	b.ls	2002c8 <hashtable_init+0x298>  // b.plast

  200078:	3900709f 	strb	wzr, [x4, #28]
#include "protocols.h"
  20007c:	f100147f 	cmp	x3, #0x5
  200080:	54001300 	b.eq	2002e0 <hashtable_init+0x2b0>  // b.none

  200084:	3900749f 	strb	wzr, [x4, #29]
#include "protocols.h"
  200088:	f100187f 	cmp	x3, #0x6
  20008c:	54001360 	b.eq	2002f8 <hashtable_init+0x2c8>  // b.none

  200090:	3900789f 	strb	wzr, [x4, #30]
#include "protocols.h"
  200094:	361812c1 	tbz	w1, #3, 2002ec <hashtable_init+0x2bc>

  200098:	39007c9f 	strb	wzr, [x4, #31]
#include "protocols.h"
  20009c:	f100207f 	cmp	x3, #0x8
  2000a0:	54001329 	b.ls	200304 <hashtable_init+0x2d4>  // b.plast

  2000a4:	3900809f 	strb	wzr, [x4, #32]
#include "protocols.h"
  2000a8:	f100247f 	cmp	x3, #0x9
  2000ac:	54001320 	b.eq	200310 <hashtable_init+0x2e0>  // b.none

  2000b0:	3900849f 	strb	wzr, [x4, #33]
#include "protocols.h"
  2000b4:	f100287f 	cmp	x3, #0xa
  2000b8:	540010e0 	b.eq	2002d4 <hashtable_init+0x2a4>  // b.none

  2000bc:	3900889f 	strb	wzr, [x4, #34]
#include "protocols.h"
  2000c0:	f1002c7f 	cmp	x3, #0xb
  2000c4:	540012c0 	b.eq	20031c <hashtable_init+0x2ec>  // b.none

  2000c8:	39008c9f 	strb	wzr, [x4, #35]
#include "protocols.h"
  2000cc:	f100307f 	cmp	x3, #0xc
  2000d0:	54001320 	b.eq	200334 <hashtable_init+0x304>  // b.none

  2000d4:	3900909f 	strb	wzr, [x4, #36]
#include "protocols.h"
  2000d8:	f100347f 	cmp	x3, #0xd
  2000dc:	54001320 	b.eq	200340 <hashtable_init+0x310>  // b.none

  2000e0:	3900949f 	strb	wzr, [x4, #37]
#include "protocols.h"
  2000e4:	f1003c7f 	cmp	x3, #0xf
  2000e8:	54001201 	b.ne	200328 <hashtable_init+0x2f8>  // b.any
  2000ec:	aa0303e5 	mov	x5, x3
  2000f0:	d2807e62 	mov	x2, #0x3f3                 	// #1011

  2000f4:	3900989f 	strb	wzr, [x4, #38]
#include "protocols.h"
  2000f8:	d2808044 	mov	x4, #0x402                 	// #1026
  2000fc:	d2860301 	mov	x1, #0x3018                	// #12312
  200100:	cb030084 	sub	x4, x4, x3
  200104:	8b010061 	add	x1, x3, x1
  200108:	8b010001 	add	x1, x0, x1
  20010c:	927cec83 	and	x3, x4, #0xfffffffffffffff0

  200110:	4f000400 	movi	v0.4s, #0x0
  200114:	8b010063 	add	x3, x3, x1
  200118:	3c810420 	str	q0, [x1], #16
#include "protocols.h"
  20011c:	eb03003f 	cmp	x1, x3
  200120:	54ffffc1 	b.ne	200118 <hashtable_init+0xe8>  // b.any
  200124:	927cec83 	and	x3, x4, #0xfffffffffffffff0
  200128:	f2400c9f 	tst	x4, #0xf
  20012c:	8b0300a1 	add	x1, x5, x3
  200130:	cb030042 	sub	x2, x2, x3
  200134:	54000b00 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200138:	8b010003 	add	x3, x0, x1
#include "protocols.h"
  20013c:	f100045f 	cmp	x2, #0x1

  200140:	91400c63 	add	x3, x3, #0x3, lsl #12
#include "protocols.h"
  200144:	91000424 	add	x4, x1, #0x1

  200148:	3900607f 	strb	wzr, [x3, #24]
#include "protocols.h"
  20014c:	54000a40 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200150:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  200154:	f100085f 	cmp	x2, #0x2

  200158:	91400c84 	add	x4, x4, #0x3, lsl #12
#include "protocols.h"
  20015c:	91000823 	add	x3, x1, #0x2

  200160:	3900609f 	strb	wzr, [x4, #24]
#include "protocols.h"
  200164:	54000980 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200168:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  20016c:	f1000c5f 	cmp	x2, #0x3

  200170:	91400c63 	add	x3, x3, #0x3, lsl #12
#include "protocols.h"
  200174:	91000c24 	add	x4, x1, #0x3

  200178:	3900607f 	strb	wzr, [x3, #24]
#include "protocols.h"
  20017c:	540008c0 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200180:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  200184:	f100105f 	cmp	x2, #0x4

  200188:	91400c84 	add	x4, x4, #0x3, lsl #12
#include "protocols.h"
  20018c:	91001023 	add	x3, x1, #0x4

  200190:	3900609f 	strb	wzr, [x4, #24]
#include "protocols.h"
  200194:	54000800 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200198:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  20019c:	f100145f 	cmp	x2, #0x5

  2001a0:	91400c63 	add	x3, x3, #0x3, lsl #12
#include "protocols.h"
  2001a4:	91001424 	add	x4, x1, #0x5

  2001a8:	3900607f 	strb	wzr, [x3, #24]
#include "protocols.h"
  2001ac:	54000740 	b.eq	200294 <hashtable_init+0x264>  // b.none

  2001b0:	8b040003 	add	x3, x0, x4
#include "protocols.h"
  2001b4:	f100185f 	cmp	x2, #0x6

  2001b8:	91400c63 	add	x3, x3, #0x3, lsl #12
#include "protocols.h"
  2001bc:	91001824 	add	x4, x1, #0x6

  2001c0:	3900607f 	strb	wzr, [x3, #24]
#include "protocols.h"
  2001c4:	54000680 	b.eq	200294 <hashtable_init+0x264>  // b.none

  2001c8:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  2001cc:	f1001c5f 	cmp	x2, #0x7

  2001d0:	91400c84 	add	x4, x4, #0x3, lsl #12
#include "protocols.h"
  2001d4:	91001c23 	add	x3, x1, #0x7

  2001d8:	3900609f 	strb	wzr, [x4, #24]
#include "protocols.h"
  2001dc:	540005c0 	b.eq	200294 <hashtable_init+0x264>  // b.none

  2001e0:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  2001e4:	f100205f 	cmp	x2, #0x8

  2001e8:	91400c63 	add	x3, x3, #0x3, lsl #12
#include "protocols.h"
  2001ec:	91002024 	add	x4, x1, #0x8

  2001f0:	3900607f 	strb	wzr, [x3, #24]
#include "protocols.h"
  2001f4:	54000500 	b.eq	200294 <hashtable_init+0x264>  // b.none

  2001f8:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  2001fc:	f100245f 	cmp	x2, #0x9

  200200:	91400c84 	add	x4, x4, #0x3, lsl #12
#include "protocols.h"
  200204:	91002423 	add	x3, x1, #0x9

  200208:	3900609f 	strb	wzr, [x4, #24]
#include "protocols.h"
  20020c:	54000440 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200210:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  200214:	f100285f 	cmp	x2, #0xa

  200218:	91400c63 	add	x3, x3, #0x3, lsl #12
#include "protocols.h"
  20021c:	91002824 	add	x4, x1, #0xa

  200220:	3900607f 	strb	wzr, [x3, #24]
#include "protocols.h"
  200224:	54000380 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200228:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  20022c:	f1002c5f 	cmp	x2, #0xb

  200230:	91400c84 	add	x4, x4, #0x3, lsl #12
#include "protocols.h"
  200234:	91002c23 	add	x3, x1, #0xb

  200238:	3900609f 	strb	wzr, [x4, #24]
#include "protocols.h"
  20023c:	540002c0 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200240:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  200244:	f100305f 	cmp	x2, #0xc

  200248:	91400c63 	add	x3, x3, #0x3, lsl #12
#include "protocols.h"
  20024c:	91003024 	add	x4, x1, #0xc

  200250:	3900607f 	strb	wzr, [x3, #24]
#include "protocols.h"
  200254:	54000200 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200258:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  20025c:	f100345f 	cmp	x2, #0xd

  200260:	91400c84 	add	x4, x4, #0x3, lsl #12
#include "protocols.h"
  200264:	91003423 	add	x3, x1, #0xd

  200268:	3900609f 	strb	wzr, [x4, #24]
#include "protocols.h"
  20026c:	54000140 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200270:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  200274:	91003821 	add	x1, x1, #0xe

  200278:	91400c63 	add	x3, x3, #0x3, lsl #12
#include "protocols.h"
  20027c:	f100385f 	cmp	x2, #0xe

  200280:	3900607f 	strb	wzr, [x3, #24]
#include "protocols.h"
  200284:	54000080 	b.eq	200294 <hashtable_init+0x264>  // b.none

  200288:	8b010000 	add	x0, x0, x1
  20028c:	91400c00 	add	x0, x0, #0x3, lsl #12
  200290:	3900601f 	strb	wzr, [x0, #24]
__attribute__((__section__(".router_config"))) router_config_external_t router_config;

  200294:	d65f03c0 	ret
#include "protocols.h"
  200298:	d2808022 	mov	x2, #0x401                 	// #1025
  20029c:	d2800025 	mov	x5, #0x1                   	// #1
  2002a0:	17ffff96 	b	2000f8 <hashtable_init+0xc8>
  2002a4:	d2808002 	mov	x2, #0x400                 	// #1024
  2002a8:	d2800045 	mov	x5, #0x2                   	// #2
  2002ac:	17ffff93 	b	2000f8 <hashtable_init+0xc8>
  2002b0:	d2800005 	mov	x5, #0x0                   	// #0
  2002b4:	d2808042 	mov	x2, #0x402                 	// #1026
  2002b8:	17ffff90 	b	2000f8 <hashtable_init+0xc8>
  2002bc:	d2807fe2 	mov	x2, #0x3ff                 	// #1023
  2002c0:	d2800065 	mov	x5, #0x3                   	// #3
  2002c4:	17ffff8d 	b	2000f8 <hashtable_init+0xc8>
  2002c8:	d2807fc2 	mov	x2, #0x3fe                 	// #1022
  2002cc:	d2800085 	mov	x5, #0x4                   	// #4
  2002d0:	17ffff8a 	b	2000f8 <hashtable_init+0xc8>
  2002d4:	aa0303e5 	mov	x5, x3
  2002d8:	d2807f02 	mov	x2, #0x3f8                 	// #1016
  2002dc:	17ffff87 	b	2000f8 <hashtable_init+0xc8>
  2002e0:	aa0303e5 	mov	x5, x3
  2002e4:	d2807fa2 	mov	x2, #0x3fd                 	// #1021
  2002e8:	17ffff84 	b	2000f8 <hashtable_init+0xc8>
  2002ec:	d2807f62 	mov	x2, #0x3fb                 	// #1019
  2002f0:	d28000e5 	mov	x5, #0x7                   	// #7
  2002f4:	17ffff81 	b	2000f8 <hashtable_init+0xc8>
  2002f8:	aa0303e5 	mov	x5, x3
  2002fc:	d2807f82 	mov	x2, #0x3fc                 	// #1020
  200300:	17ffff7e 	b	2000f8 <hashtable_init+0xc8>
  200304:	d2807f42 	mov	x2, #0x3fa                 	// #1018
  200308:	d2800105 	mov	x5, #0x8                   	// #8
  20030c:	17ffff7b 	b	2000f8 <hashtable_init+0xc8>
  200310:	d2800125 	mov	x5, #0x9                   	// #9
  200314:	d2807f22 	mov	x2, #0x3f9                 	// #1017
  200318:	17ffff78 	b	2000f8 <hashtable_init+0xc8>
  20031c:	aa0303e5 	mov	x5, x3
  200320:	d2807ee2 	mov	x2, #0x3f7                 	// #1015
  200324:	17ffff75 	b	2000f8 <hashtable_init+0xc8>
  200328:	d2807e82 	mov	x2, #0x3f4                 	// #1012
  20032c:	d28001c5 	mov	x5, #0xe                   	// #14
  200330:	17ffff72 	b	2000f8 <hashtable_init+0xc8>
  200334:	aa0303e5 	mov	x5, x3
  200338:	d2807ec2 	mov	x2, #0x3f6                 	// #1014
  20033c:	17ffff6f 	b	2000f8 <hashtable_init+0xc8>
  200340:	aa0303e5 	mov	x5, x3
  200344:	d2807ea2 	mov	x2, #0x3f5                 	// #1013
  200348:	17ffff6c 	b	2000f8 <hashtable_init+0xc8>
  20034c:	d503201f 	nop

0000000000200350 <hashtable_insert>:
#include "routing.h"
  200350:	5287fc2a 	mov	w10, #0x3fe1                	// #16353
  200354:	72bff00a 	movk	w10, #0xff80, lsl #16
  200358:	5280804c 	mov	w12, #0x402                 	// #1026
routing_entry_t routing_table[NUM_ROUTES] = {{0}};

/* Booleans to indicate whether packets have been enqueued during notification handling */
static bool notify_tx;
static bool notify_rx;

  20035c:	d280018b 	mov	x11, #0xc                   	// #12
#include "routing.h"
  200360:	9baa7c29 	umull	x9, w1, w10
  200364:	d36afd29 	lsr	x9, x9, #42
  200368:	1b0c8529 	msub	w9, w9, w12, w1
routing_entry_t routing_table[NUM_ROUTES] = {{0}};
  20036c:	2a0903e3 	mov	w3, w9
static bool notify_rx;
  200370:	14000008 	b	200390 <hashtable_insert+0x40>

  200374:	b8676804 	ldr	w4, [x0, x7]
  200378:	6b01009f 	cmp	w4, w1
  20037c:	54000500 	b.eq	20041c <hashtable_insert+0xcc>  // b.none
net_queue_handle_t virt_tx_queue;

typedef struct state {
    net_queue_handle_t filter_queue[61];
} state_t;
  200380:	d36afd03 	lsr	x3, x8, #42
  200384:	1b0c9863 	msub	w3, w3, w12, w6

  200388:	6b03013f 	cmp	w9, w3
  20038c:	54000460 	b.eq	200418 <hashtable_insert+0xc8>  // b.none
static bool notify_rx;
  200390:	2a0303e5 	mov	w5, w3
} state_t;
  200394:	11000466 	add	w6, w3, #0x1
static bool notify_rx;
  200398:	8b050004 	add	x4, x0, x5
  20039c:	91400c84 	add	x4, x4, #0x3, lsl #12
} state_t;
  2003a0:	9baa7cc8 	umull	x8, w6, w10

  2003a4:	9b0b7ca7 	mul	x7, x5, x11
static bool notify_rx;
  2003a8:	39406084 	ldrb	w4, [x4, #24]
  2003ac:	35fffe44 	cbnz	w4, 200374 <hashtable_insert+0x24>

struct ll_info pkt_waiting_queue;

/* This queue will hold packets that we need to generate an ARP request for. */
net_queue_handle_t arp_waiting;
/* This queue will hold all the ARP requests/responses that are needed by the
  2003b0:	d2800184 	mov	x4, #0xc                   	// #12
packets in the arp_waiting queue. */
  2003b4:	d2800087 	mov	x7, #0x4                   	// #4
  2003b8:	91000446 	add	x6, x2, #0x1
  2003bc:	9ba41c63 	umaddl	x3, w3, w4, x7
/* This queue will hold all the ARP requests/responses that are needed by the
  2003c0:	9b047ca7 	mul	x7, x5, x4
packets in the arp_waiting queue. */
  2003c4:	8b030004 	add	x4, x0, x3
  2003c8:	aa020088 	orr	x8, x4, x2
  2003cc:	cb060086 	sub	x6, x4, x6
/* This queue will hold all the ARP requests/responses that are needed by the
  2003d0:	b8276801 	str	w1, [x0, x7]

static inline void *sddf_memcpy(void *dest, const void *src, size_t n)
{
    unsigned char *to = dest;
    const unsigned char *from = src;
    while (n-- > 0) {
  2003d4:	f240091f 	tst	x8, #0x7
  2003d8:	fa4608c0 	ccmp	x6, #0x6, #0x0, eq	// eq = none
  2003dc:	54000489 	b.ls	20046c <hashtable_insert+0x11c>  // b.plast
        *to++ = *from++;
  2003e0:	fd400040 	ldr	d0, [x2]
  2003e4:	fc236800 	str	d0, [x0, x3]
  2003e8:	39402041 	ldrb	w1, [x2, #8]
    }

    // Insert the new entry
    table->entries[index].key = key;
    sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
    table->used[index] = 1;  // Mark this slot as used
  2003ec:	8b050000 	add	x0, x0, x5
  2003f0:	39002081 	strb	w1, [x4, #8]
  2003f4:	91400c00 	add	x0, x0, #0x3, lsl #12
  2003f8:	39402441 	ldrb	w1, [x2, #9]
  2003fc:	39002481 	strb	w1, [x4, #9]
  200400:	39402841 	ldrb	w1, [x2, #10]
  200404:	39002881 	strb	w1, [x4, #10]
  200408:	39402c41 	ldrb	w1, [x2, #11]
  20040c:	39002c81 	strb	w1, [x4, #11]
  200410:	52800021 	mov	w1, #0x1                   	// #1
  200414:	39006001 	strb	w1, [x0, #24]
}
  200418:	d65f03c0 	ret
            sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
  20041c:	d2800081 	mov	x1, #0x4                   	// #4
  200420:	91000444 	add	x4, x2, #0x1
  200424:	9bab0463 	umaddl	x3, w3, w11, x1
  200428:	8b030001 	add	x1, x0, x3
    while (n-- > 0) {
  20042c:	aa020025 	orr	x5, x1, x2
  200430:	cb040024 	sub	x4, x1, x4
  200434:	f24008bf 	tst	x5, #0x7
  200438:	fa460880 	ccmp	x4, #0x6, #0x0, eq	// eq = none
  20043c:	540003a9 	b.ls	2004b0 <hashtable_insert+0x160>  // b.plast
        *to++ = *from++;
  200440:	fd400040 	ldr	d0, [x2]
  200444:	fc236800 	str	d0, [x0, x3]
  200448:	39402040 	ldrb	w0, [x2, #8]
  20044c:	39002020 	strb	w0, [x1, #8]
  200450:	39402440 	ldrb	w0, [x2, #9]
  200454:	39002420 	strb	w0, [x1, #9]
  200458:	39402840 	ldrb	w0, [x2, #10]
  20045c:	39002820 	strb	w0, [x1, #10]
  200460:	39402c40 	ldrb	w0, [x2, #11]
  200464:	39002c20 	strb	w0, [x1, #11]
}
  200468:	d65f03c0 	ret
  20046c:	39400041 	ldrb	w1, [x2]
  200470:	38236801 	strb	w1, [x0, x3]
  200474:	39400441 	ldrb	w1, [x2, #1]
  200478:	39000481 	strb	w1, [x4, #1]
  20047c:	39400841 	ldrb	w1, [x2, #2]
  200480:	39000881 	strb	w1, [x4, #2]
  200484:	39400c41 	ldrb	w1, [x2, #3]
  200488:	39000c81 	strb	w1, [x4, #3]
  20048c:	39401041 	ldrb	w1, [x2, #4]
  200490:	39001081 	strb	w1, [x4, #4]
  200494:	39401441 	ldrb	w1, [x2, #5]
  200498:	39001481 	strb	w1, [x4, #5]
  20049c:	39401841 	ldrb	w1, [x2, #6]
  2004a0:	39001881 	strb	w1, [x4, #6]
  2004a4:	39401c41 	ldrb	w1, [x2, #7]
  2004a8:	39001c81 	strb	w1, [x4, #7]
  2004ac:	17ffffcf 	b	2003e8 <hashtable_insert+0x98>
  2004b0:	39400044 	ldrb	w4, [x2]
  2004b4:	38236804 	strb	w4, [x0, x3]
  2004b8:	39400440 	ldrb	w0, [x2, #1]
  2004bc:	39000420 	strb	w0, [x1, #1]
  2004c0:	39400840 	ldrb	w0, [x2, #2]
  2004c4:	39000820 	strb	w0, [x1, #2]
  2004c8:	39400c40 	ldrb	w0, [x2, #3]
  2004cc:	39000c20 	strb	w0, [x1, #3]
  2004d0:	39401040 	ldrb	w0, [x2, #4]
  2004d4:	39001020 	strb	w0, [x1, #4]
  2004d8:	39401440 	ldrb	w0, [x2, #5]
  2004dc:	39001420 	strb	w0, [x1, #5]
  2004e0:	39401840 	ldrb	w0, [x2, #6]
  2004e4:	39001820 	strb	w0, [x1, #6]
  2004e8:	39401c40 	ldrb	w0, [x2, #7]
  2004ec:	39001c20 	strb	w0, [x1, #7]
  2004f0:	17ffffd6 	b	200448 <hashtable_insert+0xf8>
  2004f4:	d503201f 	nop
  2004f8:	d503201f 	nop
  2004fc:	d503201f 	nop

0000000000200500 <hashtable_search>:
    return key % TABLE_SIZE;
  200500:	5287fc29 	mov	w9, #0x3fe1                	// #16353
  200504:	72bff009 	movk	w9, #0xff80, lsl #16
  200508:	5280804b 	mov	w11, #0x402                 	// #1026
int hashtable_search(hashtable_t *table, uint32_t key, arp_entry_t *value) {
    uint32_t index = hash(key);
    uint32_t original_index = index;

    while (table->used[index]) {
        if (table->entries[index].key == key) {
  20050c:	d280018a 	mov	x10, #0xc                   	// #12
    return key % TABLE_SIZE;
  200510:	9ba97c28 	umull	x8, w1, w9
  200514:	d36afd08 	lsr	x8, x8, #42
  200518:	1b0b8508 	msub	w8, w8, w11, w1
    uint32_t index = hash(key);
  20051c:	2a0803e3 	mov	w3, w8
    while (table->used[index]) {
  200520:	14000008 	b	200540 <hashtable_search+0x40>
        if (table->entries[index].key == key) {
  200524:	b8646804 	ldr	w4, [x0, x4]
  200528:	6b01009f 	cmp	w4, w1
  20052c:	540001e0 	b.eq	200568 <hashtable_search+0x68>  // b.none
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
            return 1;
        }
        index = (index + 1) % TABLE_SIZE;
  200530:	d36afce3 	lsr	x3, x7, #42
  200534:	1b0b9863 	msub	w3, w3, w11, w6
        if (index == original_index) {
  200538:	6b03011f 	cmp	w8, w3
  20053c:	54000120 	b.eq	200560 <hashtable_search+0x60>  // b.none
    while (table->used[index]) {
  200540:	2a0303e4 	mov	w4, w3
        index = (index + 1) % TABLE_SIZE;
  200544:	11000466 	add	w6, w3, #0x1
    while (table->used[index]) {
  200548:	8b040005 	add	x5, x0, x4
  20054c:	91400ca5 	add	x5, x5, #0x3, lsl #12
        index = (index + 1) % TABLE_SIZE;
  200550:	9ba97cc7 	umull	x7, w6, w9
        if (table->entries[index].key == key) {
  200554:	9b0a7c84 	mul	x4, x4, x10
    while (table->used[index]) {
  200558:	394060a5 	ldrb	w5, [x5, #24]
  20055c:	35fffe45 	cbnz	w5, 200524 <hashtable_search+0x24>
            // Full cycle completed, element not found
            break;
        }
    }
    return -1;
  200560:	12800000 	mov	w0, #0xffffffff            	// #-1
}
  200564:	d65f03c0 	ret
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  200568:	9baa7c63 	umull	x3, w3, w10
  20056c:	91001065 	add	x5, x3, #0x4
  200570:	91001463 	add	x3, x3, #0x5
  200574:	8b050001 	add	x1, x0, x5
    while (n-- > 0) {
  200578:	8b030004 	add	x4, x0, x3
  20057c:	aa020027 	orr	x7, x1, x2
  200580:	cb040046 	sub	x6, x2, x4
  200584:	f24008ff 	tst	x7, #0x7
  200588:	fa4608c0 	ccmp	x6, #0x6, #0x0, eq	// eq = none
  20058c:	540001a9 	b.ls	2005c0 <hashtable_search+0xc0>  // b.plast
        *to++ = *from++;
  200590:	fc656800 	ldr	d0, [x0, x5]
  200594:	fd000040 	str	d0, [x2]
  200598:	39402020 	ldrb	w0, [x1, #8]
  20059c:	39002040 	strb	w0, [x2, #8]
  2005a0:	39402420 	ldrb	w0, [x1, #9]
  2005a4:	39002440 	strb	w0, [x2, #9]
  2005a8:	39402820 	ldrb	w0, [x1, #10]
  2005ac:	39002840 	strb	w0, [x2, #10]
  2005b0:	39402c21 	ldrb	w1, [x1, #11]
            return 1;
  2005b4:	52800020 	mov	w0, #0x1                   	// #1
  2005b8:	39002c41 	strb	w1, [x2, #11]
}
  2005bc:	d65f03c0 	ret
  2005c0:	38656801 	ldrb	w1, [x0, x5]
  2005c4:	39000041 	strb	w1, [x2]
  2005c8:	38636800 	ldrb	w0, [x0, x3]
  2005cc:	39000440 	strb	w0, [x2, #1]
  2005d0:	39400480 	ldrb	w0, [x4, #1]
  2005d4:	39000840 	strb	w0, [x2, #2]
  2005d8:	39400880 	ldrb	w0, [x4, #2]
  2005dc:	39000c40 	strb	w0, [x2, #3]
  2005e0:	39400c80 	ldrb	w0, [x4, #3]
  2005e4:	39001040 	strb	w0, [x2, #4]
  2005e8:	39401080 	ldrb	w0, [x4, #4]
  2005ec:	39001440 	strb	w0, [x2, #5]
  2005f0:	39401480 	ldrb	w0, [x4, #5]
  2005f4:	39001840 	strb	w0, [x2, #6]
  2005f8:	39401880 	ldrb	w0, [x4, #6]
  2005fc:	39001c40 	strb	w0, [x2, #7]
  200600:	39401c80 	ldrb	w0, [x4, #7]
  200604:	39002040 	strb	w0, [x2, #8]
  200608:	39402080 	ldrb	w0, [x4, #8]
  20060c:	39002440 	strb	w0, [x2, #9]
  200610:	39402480 	ldrb	w0, [x4, #9]
  200614:	39002840 	strb	w0, [x2, #10]
  200618:	39402881 	ldrb	w1, [x4, #10]
    while (n-- > 0) {
  20061c:	17ffffe6 	b	2005b4 <hashtable_search+0xb4>

0000000000200620 <hashtable_remove>:
    return key % TABLE_SIZE;
  200620:	5287fc2a 	mov	w10, #0x3fe1                	// #16353
  200624:	72bff00a 	movk	w10, #0xff80, lsl #16
  200628:	52808049 	mov	w9, #0x402                 	// #1026
void hashtable_remove(hashtable_t *table, uint32_t key) {
    uint32_t index = hash(key);
    uint32_t original_index = index;

    while (table->used[index]) {
        if (table->entries[index].key == key) {
  20062c:	d280018b 	mov	x11, #0xc                   	// #12
    return key % TABLE_SIZE;
  200630:	9baa7c28 	umull	x8, w1, w10
  200634:	d36afd08 	lsr	x8, x8, #42
  200638:	1b098508 	msub	w8, w8, w9, w1
    uint32_t index = hash(key);
  20063c:	2a0803e2 	mov	w2, w8
    while (table->used[index]) {
  200640:	14000006 	b	200658 <hashtable_remove+0x38>
        if (table->entries[index].key == key) {
  200644:	b8676804 	ldr	w4, [x0, x7]
  200648:	6b01009f 	cmp	w4, w1
  20064c:	540001a0 	b.eq	200680 <hashtable_remove+0x60>  // b.none
            // Mark the slot as unused and clear the entry
            table->used[index] = 0;
            return;
        }
        index = (index + 1) % TABLE_SIZE;
        if (index == original_index) {
  200650:	6b02011f 	cmp	w8, w2
  200654:	54000140 	b.eq	20067c <hashtable_remove+0x5c>  // b.none
        index = (index + 1) % TABLE_SIZE;
  200658:	11000444 	add	w4, w2, #0x1
    while (table->used[index]) {
  20065c:	8b020003 	add	x3, x0, x2
  200660:	91400c63 	add	x3, x3, #0x3, lsl #12
        if (table->entries[index].key == key) {
  200664:	9b0b7c47 	mul	x7, x2, x11
        index = (index + 1) % TABLE_SIZE;
  200668:	9baa7c86 	umull	x6, w4, w10
    while (table->used[index]) {
  20066c:	39406065 	ldrb	w5, [x3, #24]
        index = (index + 1) % TABLE_SIZE;
  200670:	d36afcc2 	lsr	x2, x6, #42
  200674:	1b099042 	msub	w2, w2, w9, w4
    while (table->used[index]) {
  200678:	35fffe65 	cbnz	w5, 200644 <hashtable_remove+0x24>
            // Full cycle completed, element not found
            break;
        }
    }
}
  20067c:	d65f03c0 	ret
            table->used[index] = 0;
  200680:	3900607f 	strb	wzr, [x3, #24]
}
  200684:	d65f03c0 	ret
  200688:	d503201f 	nop
  20068c:	d503201f 	nop

0000000000200690 <hashtable_empty>:

bool hashtable_empty(hashtable_t *table) {
    bool empty = true;
    for (int i = 0; i < TABLE_SIZE; i++) {
  200690:	d2860301 	mov	x1, #0x3018                	// #12312
  200694:	d2868343 	mov	x3, #0x341a                	// #13338
  200698:	8b010001 	add	x1, x0, x1
  20069c:	8b030003 	add	x3, x0, x3
    bool empty = true;
  2006a0:	52800022 	mov	w2, #0x1                   	// #1
  2006a4:	d503201f 	nop
        if (table->used[i] == 1) {
  2006a8:	38401420 	ldrb	w0, [x1], #1
            empty = false;
  2006ac:	7100041f 	cmp	w0, #0x1
  2006b0:	1a9f1042 	csel	w2, w2, wzr, ne	// ne = any
    for (int i = 0; i < TABLE_SIZE; i++) {
  2006b4:	eb03003f 	cmp	x1, x3
  2006b8:	54ffff81 	b.ne	2006a8 <hashtable_empty+0x18>  // b.any
        }
    }
    return empty;
  2006bc:	2a0203e0 	mov	w0, w2
  2006c0:	d65f03c0 	ret
  2006c4:	d503201f 	nop
  2006c8:	d503201f 	nop
  2006cc:	d503201f 	nop

00000000002006d0 <ll_node_find>:
dev_info_t *device_info;

void *ll_node_find(struct ll_info *info, uint32_t ip)
{
    // Loop through the waiting list
    struct llnode_ptrs *curr = LLNODE_PTRS_CAST(info->head);
  2006d0:	f9400c00 	ldr	x0, [x0, #24]
    while (curr != NULL) {
  2006d4:	b5000080 	cbnz	x0, 2006e4 <ll_node_find+0x14>
  2006d8:	14000006 	b	2006f0 <ll_node_find+0x20>
        // Cast to llnode_pkt_waiting
        struct llnode_pkt_waiting *curr_node = (struct llnode_pkt_waiting *) curr;
        if (curr_node->ip == ip) {
            return (void *) curr;
        }
        curr = LLNODE_PTRS_CAST(curr->next);
  2006dc:	f9400000 	ldr	x0, [x0]
    while (curr != NULL) {
  2006e0:	b4000080 	cbz	x0, 2006f0 <ll_node_find+0x20>
        if (curr_node->ip == ip) {
  2006e4:	b9401002 	ldr	w2, [x0, #16]
  2006e8:	6b01005f 	cmp	w2, w1
  2006ec:	54ffff81 	b.ne	2006dc <ll_node_find+0xc>  // b.any
    }

    return NULL;
}
  2006f0:	d65f03c0 	ret
  2006f4:	d503201f 	nop
  2006f8:	d503201f 	nop
  2006fc:	d503201f 	nop

0000000000200700 <check_waiting>:
    struct llnode_ptrs *curr = LLNODE_PTRS_CAST(info->head);
  200700:	f9400c00 	ldr	x0, [x0, #24]
    while (curr != NULL) {
  200704:	b5000080 	cbnz	x0, 200714 <check_waiting+0x14>
  200708:	14000008 	b	200728 <check_waiting+0x28>
        curr = LLNODE_PTRS_CAST(curr->next);
  20070c:	f9400000 	ldr	x0, [x0]
    while (curr != NULL) {
  200710:	b40000a0 	cbz	x0, 200724 <check_waiting+0x24>
        if (curr_node->ip == ip) {
  200714:	b9401002 	ldr	w2, [x0, #16]
  200718:	6b02003f 	cmp	w1, w2
  20071c:	54ffff81 	b.ne	20070c <check_waiting+0xc>  // b.any
  200720:	52800020 	mov	w0, #0x1                   	// #1
    if (ll_node_find(info, ip) == NULL) {
        return false;
    } else {
        return true;
    }
}
  200724:	d65f03c0 	ret
    while (curr != NULL) {
  200728:	52800000 	mov	w0, #0x0                   	// #0
}
  20072c:	d65f03c0 	ret

0000000000200730 <process_arp_waiting>:
void process_arp_waiting()
{
    /* Loop through all of the ARP responses. If there are any invalid
    responses we will drop the packets associated with the IP address. Otherwise
    we will substitute the MAC address in, and then send the packet out of the NIC. */
    while (!arp_queue_empty_response(arp_queries)) {
  200730:	b0000025 	adrp	x5, 205000 <__sel4_ipc_buffer>
  200734:	f94728a2 	ldr	x2, [x5, #3664]
 *
 * @return true indicates the queue is empty, false otherwise.
 */
static inline bool arp_queue_empty_response(arp_queue_handle_t *queue)
{
    return queue->response.tail - queue->response.head == 0;
  200738:	79700c40 	ldrh	w0, [x2, #6150]
  20073c:	79700841 	ldrh	w1, [x2, #6148]
  200740:	6b00003f 	cmp	w1, w0
  200744:	54003560 	b.eq	200df0 <process_arp_waiting+0x6c0>  // b.none
{
  200748:	a9b77bfd 	stp	x29, x30, [sp, #-144]!
  20074c:	910003fd 	mov	x29, sp
  200750:	a90153f3 	stp	x19, x20, [sp, #16]
  200754:	90000033 	adrp	x19, 204000 <sddf_sprintf_+0x70>
  200758:	910f0261 	add	x1, x19, #0x3c0
  20075c:	a90573fb 	stp	x27, x28, [sp, #80]
  200760:	913940bc 	add	x28, x5, #0xe50
{
    if (arp_queue_empty_response(queue)) {
        return -1;
    }

    sddf_memcpy(response, &queue->response.queue[queue->response.head % queue->capacity], sizeof(arp_request_t));
  200764:	d2830114 	mov	x20, #0x1808                	// #6152
  200768:	f90037e1 	str	x1, [sp, #104]
 *
 * @return true indicates the queue is full, false otherwise.
 */
static inline bool net_queue_full_free(net_queue_handle_t *queue)
{
    return queue->free->tail - queue->free->head == queue->capacity;
  20076c:	9100e381 	add	x1, x28, #0x38
  200770:	a9025bf5 	stp	x21, x22, [sp, #32]
  200774:	52800195 	mov	w21, #0xc                   	// #12
  200778:	a90363f7 	stp	x23, x24, [sp, #48]
  20077c:	a9046bf9 	stp	x25, x26, [sp, #64]
  200780:	f90043e1 	str	x1, [sp, #128]
                err = net_enqueue_free(&state.filter_queue[waiting_packet->filter], waiting_packet->buffer);
                assert(!err);
                microkit_deferred_notify(net_config.tx.id);
            }
        } else {
            sddf_dprintf("ROUTING_EXTERNAL|Unable to find packet waiting on ip address from ARP response.\n");
  200784:	90000021 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  200788:	91122021 	add	x1, x1, #0x488
  20078c:	f9003fe1 	str	x1, [sp, #120]
  200790:	b9700843 	ldr	w3, [x2, #12296]

    queue->response.head++;
  200794:	11000407 	add	w7, w0, #0x1
    struct llnode_ptrs *curr = LLNODE_PTRS_CAST(info->head);
  200798:	f9401393 	ldr	x19, [x28, #32]
    sddf_memcpy(response, &queue->response.queue[queue->response.head % queue->capacity], sizeof(arp_request_t));
  20079c:	1ac30801 	udiv	w1, w0, w3
  2007a0:	1b038021 	msub	w1, w1, w3, w0
  2007a4:	9bb55021 	umaddl	x1, w1, w21, x20
  2007a8:	8b010040 	add	x0, x2, x1
        *to++ = *from++;
  2007ac:	38616848 	ldrb	w8, [x2, x1]
  2007b0:	39400406 	ldrb	w6, [x0, #1]
  2007b4:	39400801 	ldrb	w1, [x0, #2]
  2007b8:	39401004 	ldrb	w4, [x0, #4]
  2007bc:	39400c03 	ldrb	w3, [x0, #3]
  2007c0:	aa062106 	orr	x6, x8, x6, lsl #8
  2007c4:	b90073e4 	str	w4, [sp, #112]
  2007c8:	aa0140c1 	orr	x1, x6, x1, lsl #16
  2007cc:	39401404 	ldrb	w4, [x0, #5]
  2007d0:	39401818 	ldrb	w24, [x0, #6]
  2007d4:	aa036037 	orr	x23, x1, x3, lsl #24
  2007d8:	39401c19 	ldrb	w25, [x0, #7]
  2007dc:	2a1703e1 	mov	w1, w23
  2007e0:	3940201a 	ldrb	w26, [x0, #8]
  2007e4:	3940241b 	ldrb	w27, [x0, #9]
  2007e8:	39402816 	ldrb	w22, [x0, #10]
  2007ec:	b90077e4 	str	w4, [sp, #116]
    queue->response.head++;
  2007f0:	79300c47 	strh	w7, [x2, #6150]
    while (curr != NULL) {
  2007f4:	b5000093 	cbnz	x19, 200804 <process_arp_waiting+0xd4>
  2007f8:	14000122 	b	200c80 <process_arp_waiting+0x550>
        curr = LLNODE_PTRS_CAST(curr->next);
  2007fc:	f9400273 	ldr	x19, [x19]
    while (curr != NULL) {
  200800:	b4002413 	cbz	x19, 200c80 <process_arp_waiting+0x550>
        if (curr_node->ip == ip) {
  200804:	b9401260 	ldr	w0, [x19, #16]
  200808:	6b01001f 	cmp	w0, w1
  20080c:	54ffff81 	b.ne	2007fc <process_arp_waiting+0xcc>  // b.any
        sddf_dprintf("ROUTING_EXTERNAL|Processing arp waiting queue\n");
  200810:	f94037e0 	ldr	x0, [sp, #104]
  200814:	94000dbb 	bl	203f00 <sddf_printf_>
        } else if ((!response.valid && waiting_packet->valid)) {
  200818:	350012f6 	cbnz	w22, 200a74 <process_arp_waiting+0x344>
  20081c:	39405260 	ldrb	w0, [x19, #20]
  200820:	34002440 	cbz	w0, 200ca8 <process_arp_waiting+0x578>
  200824:	79405260 	ldrh	w0, [x19, #40]
  200828:	d2800301 	mov	x1, #0x18                  	// #24
            waiting_packet->buffer.len = 0;
  20082c:	7900427f 	strh	wzr, [x19, #32]
            err = net_enqueue_free(&state.filter_queue[waiting_packet->filter], waiting_packet->buffer);
  200830:	f9400e67 	ldr	x7, [x19, #24]
  200834:	9b017c00 	mul	x0, x0, x1
  200838:	f94043e1 	ldr	x1, [sp, #128]
  20083c:	8b000022 	add	x2, x1, x0
  200840:	f8606821 	ldr	x1, [x1, x0]
  200844:	b9401043 	ldr	w3, [x2, #16]
  200848:	79400420 	ldrh	w0, [x1, #2]
  20084c:	79400022 	ldrh	w2, [x1]
  200850:	4b000040 	sub	w0, w2, w0
 *
 * @return -1 when queue is full, 0 on success.
 */
static inline int net_enqueue_free(net_queue_handle_t *queue, net_buff_desc_t buffer)
{
    if (net_queue_full_free(queue)) {
  200854:	6b03001f 	cmp	w0, w3
  200858:	54002ea0 	b.eq	200e2c <process_arp_waiting+0x6fc>  // b.none
        return -1;
    }

    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  20085c:	1ac30840 	udiv	w0, w2, w3
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->free->tail++;
  200860:	11000446 	add	w6, w2, #0x1
  200864:	1b038800 	msub	w0, w0, w3, w2
  200868:	8b001020 	add	x0, x1, x0, lsl #4
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  20086c:	f9000407 	str	x7, [x0, #8]
  200870:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  200874:	79000026 	strh	w6, [x1]

static void llfree(struct ll_info *info, void *node)
{
    assert(info && node);

    struct llnode_ptrs *prev = LLNODE_PTRS_CAST(node)->prev;
  200878:	a9400660 	ldp	x0, x1, [x19]
    struct llnode_ptrs *next = LLNODE_PTRS_CAST(node)->next;

    /* A -> node -> B: if A exists, A->next = B */
    if (prev) {
  20087c:	b4000041 	cbz	x1, 200884 <process_arp_waiting+0x154>
        prev->next = next;
  200880:	f9000020 	str	x0, [x1]
    }

    /* A -> node -> B:  if B exists, B->prev = A */
    if (next) {
  200884:	b40020e0 	cbz	x0, 200ca0 <process_arp_waiting+0x570>
        next->prev = prev;
  200888:	f9000401 	str	x1, [x0, #8]
        /* if node was the tail */
        info->tail = prev;
    }

    /* Return to free list. */
    LLNODE_PTRS_CAST(node)->next = info->empty_head;
  20088c:	f9400f81 	ldr	x1, [x28, #24]
  200890:	f9000261 	str	x1, [x19]
    info->empty_head = node;

    sddf_memset(node, 0, info->node_size);
  200894:	b9401781 	ldr	w1, [x28, #20]
    info->empty_head = node;
  200898:	f9000f93 	str	x19, [x28, #24]
    while (n-- > 0) {
  20089c:	d1000422 	sub	x2, x1, #0x1
  2008a0:	b4000d21 	cbz	x1, 200a44 <process_arp_waiting+0x314>
  2008a4:	cb1303e6 	neg	x6, x19
  2008a8:	d28002e7 	mov	x7, #0x17                  	// #23
  2008ac:	92400cc0 	and	x0, x6, #0xf
  2008b0:	91003c03 	add	x3, x0, #0xf
  2008b4:	eb07007f 	cmp	x3, x7
  2008b8:	9a872063 	csel	x3, x3, x7, cs	// cs = hs, nlast
  2008bc:	eb03005f 	cmp	x2, x3
  2008c0:	54000b63 	b.cc	200a2c <process_arp_waiting+0x2fc>  // b.lo, b.ul, b.last
  2008c4:	b4001f80 	cbz	x0, 200cb4 <process_arp_waiting+0x584>
        *p++ = c;
  2008c8:	3900027f 	strb	wzr, [x19]
  2008cc:	91000667 	add	x7, x19, #0x1
    while (n-- > 0) {
  2008d0:	d1000822 	sub	x2, x1, #0x2
  2008d4:	f27f08df 	tst	x6, #0xe
  2008d8:	54000880 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  2008dc:	3900067f 	strb	wzr, [x19, #1]
  2008e0:	91000a67 	add	x7, x19, #0x2
    while (n-- > 0) {
  2008e4:	d1000c22 	sub	x2, x1, #0x3
  2008e8:	f100081f 	cmp	x0, #0x2
  2008ec:	540007e9 	b.ls	2009e8 <process_arp_waiting+0x2b8>  // b.plast
        *p++ = c;
  2008f0:	39000a7f 	strb	wzr, [x19, #2]
  2008f4:	91000e67 	add	x7, x19, #0x3
    while (n-- > 0) {
  2008f8:	d1001022 	sub	x2, x1, #0x4
  2008fc:	f27e04df 	tst	x6, #0xc
  200900:	54000740 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  200904:	39000e7f 	strb	wzr, [x19, #3]
  200908:	91001267 	add	x7, x19, #0x4
    while (n-- > 0) {
  20090c:	d1001422 	sub	x2, x1, #0x5
  200910:	f100101f 	cmp	x0, #0x4
  200914:	540006a9 	b.ls	2009e8 <process_arp_waiting+0x2b8>  // b.plast
        *p++ = c;
  200918:	3900127f 	strb	wzr, [x19, #4]
  20091c:	91001667 	add	x7, x19, #0x5
    while (n-- > 0) {
  200920:	d1001822 	sub	x2, x1, #0x6
  200924:	f100141f 	cmp	x0, #0x5
  200928:	54000600 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  20092c:	3900167f 	strb	wzr, [x19, #5]
  200930:	91001a67 	add	x7, x19, #0x6
    while (n-- > 0) {
  200934:	d1001c22 	sub	x2, x1, #0x7
  200938:	f100181f 	cmp	x0, #0x6
  20093c:	54000560 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  200940:	39001a7f 	strb	wzr, [x19, #6]
  200944:	91001e67 	add	x7, x19, #0x7
    while (n-- > 0) {
  200948:	d1002022 	sub	x2, x1, #0x8
  20094c:	361804e6 	tbz	w6, #3, 2009e8 <process_arp_waiting+0x2b8>
        *p++ = c;
  200950:	39001e7f 	strb	wzr, [x19, #7]
  200954:	91002267 	add	x7, x19, #0x8
    while (n-- > 0) {
  200958:	d1002422 	sub	x2, x1, #0x9
  20095c:	f100201f 	cmp	x0, #0x8
  200960:	54000449 	b.ls	2009e8 <process_arp_waiting+0x2b8>  // b.plast
        *p++ = c;
  200964:	3900227f 	strb	wzr, [x19, #8]
  200968:	91002667 	add	x7, x19, #0x9
    while (n-- > 0) {
  20096c:	d1002822 	sub	x2, x1, #0xa
  200970:	f100241f 	cmp	x0, #0x9
  200974:	540003a0 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  200978:	3900267f 	strb	wzr, [x19, #9]
  20097c:	91002a67 	add	x7, x19, #0xa
    while (n-- > 0) {
  200980:	d1002c22 	sub	x2, x1, #0xb
  200984:	f100281f 	cmp	x0, #0xa
  200988:	54000300 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  20098c:	39002a7f 	strb	wzr, [x19, #10]
  200990:	91002e67 	add	x7, x19, #0xb
    while (n-- > 0) {
  200994:	d1003022 	sub	x2, x1, #0xc
  200998:	f1002c1f 	cmp	x0, #0xb
  20099c:	54000260 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  2009a0:	39002e7f 	strb	wzr, [x19, #11]
  2009a4:	91003267 	add	x7, x19, #0xc
    while (n-- > 0) {
  2009a8:	d1003422 	sub	x2, x1, #0xd
  2009ac:	f100301f 	cmp	x0, #0xc
  2009b0:	540001c0 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  2009b4:	3900327f 	strb	wzr, [x19, #12]
  2009b8:	91003667 	add	x7, x19, #0xd
    while (n-- > 0) {
  2009bc:	d1003822 	sub	x2, x1, #0xe
  2009c0:	f100341f 	cmp	x0, #0xd
  2009c4:	54000120 	b.eq	2009e8 <process_arp_waiting+0x2b8>  // b.none
        *p++ = c;
  2009c8:	3900367f 	strb	wzr, [x19, #13]
  2009cc:	91003a67 	add	x7, x19, #0xe
    while (n-- > 0) {
  2009d0:	d1003c22 	sub	x2, x1, #0xf
  2009d4:	f1003c1f 	cmp	x0, #0xf
  2009d8:	54000081 	b.ne	2009e8 <process_arp_waiting+0x2b8>  // b.any
        *p++ = c;
  2009dc:	91003e67 	add	x7, x19, #0xf
    while (n-- > 0) {
  2009e0:	d1004022 	sub	x2, x1, #0x10
        *p++ = c;
  2009e4:	39003a7f 	strb	wzr, [x19, #14]
  2009e8:	4f000400 	movi	v0.4s, #0x0
  2009ec:	cb000026 	sub	x6, x1, x0
  2009f0:	d10040c3 	sub	x3, x6, #0x10
  2009f4:	8b000260 	add	x0, x19, x0
    while (n-- > 0) {
  2009f8:	d2800001 	mov	x1, #0x0                   	// #0
  2009fc:	d344fc63 	lsr	x3, x3, #4
  200a00:	91000463 	add	x3, x3, #0x1
  200a04:	d503201f 	nop
        *p++ = c;
  200a08:	91000421 	add	x1, x1, #0x1
  200a0c:	3c810400 	str	q0, [x0], #16
    while (n-- > 0) {
  200a10:	eb03003f 	cmp	x1, x3
  200a14:	54ffffa3 	b.cc	200a08 <process_arp_waiting+0x2d8>  // b.lo, b.ul, b.last
  200a18:	d37cec63 	lsl	x3, x3, #4
  200a1c:	8b0300f3 	add	x19, x7, x3
  200a20:	cb030042 	sub	x2, x2, x3
  200a24:	eb06007f 	cmp	x3, x6
  200a28:	540000e0 	b.eq	200a44 <process_arp_waiting+0x314>  // b.none
  200a2c:	91000440 	add	x0, x2, #0x1
  200a30:	8b000260 	add	x0, x19, x0
  200a34:	d503201f 	nop
        *p++ = c;
  200a38:	3800167f 	strb	wzr, [x19], #1
    while (n-- > 0) {
  200a3c:	eb00027f 	cmp	x19, x0
  200a40:	54ffffc1 	b.ne	200a38 <process_arp_waiting+0x308>  // b.any
    while (!arp_queue_empty_response(arp_queries)) {
  200a44:	f9400382 	ldr	x2, [x28]
    return queue->response.tail - queue->response.head == 0;
  200a48:	79700c40 	ldrh	w0, [x2, #6150]
  200a4c:	79700841 	ldrh	w1, [x2, #6148]
  200a50:	6b00003f 	cmp	w1, w0
  200a54:	54ffe9e1 	b.ne	200790 <process_arp_waiting+0x60>  // b.any
        }

        llfree(&pkt_waiting_queue, (void *)waiting_packet);
    }

}
  200a58:	a94153f3 	ldp	x19, x20, [sp, #16]
  200a5c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  200a60:	a94363f7 	ldp	x23, x24, [sp, #48]
  200a64:	a9446bf9 	ldp	x25, x26, [sp, #64]
  200a68:	a94573fb 	ldp	x27, x28, [sp, #80]
  200a6c:	a8c97bfd 	ldp	x29, x30, [sp], #144
  200a70:	d65f03c0 	ret
        } else if (waiting_packet->valid) {
  200a74:	39405260 	ldrb	w0, [x19, #20]
  200a78:	34001180 	cbz	w0, 200ca8 <process_arp_waiting+0x578>
            if (response.ip_addr == waiting_packet->ip) {
  200a7c:	b9401260 	ldr	w0, [x19, #16]
  200a80:	6b17001f 	cmp	w0, w23
  200a84:	54ffefa1 	b.ne	200878 <process_arp_waiting+0x148>  // b.any
                struct ipv4_packet *pkt = (struct ipv4_packet *)(router_config.filters[waiting_packet->filter].data.vaddr + waiting_packet->buffer.io_or_offset);
  200a88:	79405260 	ldrh	w0, [x19, #40]
  200a8c:	b0000028 	adrp	x8, 205000 <__sel4_ipc_buffer>
  200a90:	91026108 	add	x8, x8, #0x98
  200a94:	d2800702 	mov	x2, #0x38                  	// #56
  200a98:	f9400e61 	ldr	x1, [x19, #24]
  200a9c:	9b022000 	madd	x0, x0, x2, x8
        *to++ = *from++;
  200aa0:	3941c3e2 	ldrb	w2, [sp, #112]
  200aa4:	f9403800 	ldr	x0, [x0, #112]
  200aa8:	8b010017 	add	x23, x0, x1
  200aac:	38216802 	strb	w2, [x0, x1]
  200ab0:	3941d3e0 	ldrb	w0, [sp, #116]
  200ab4:	390006e0 	strb	w0, [x23, #1]
  200ab8:	39000af8 	strb	w24, [x23, #2]
  200abc:	39000ef9 	strb	w25, [x23, #3]
  200ac0:	390012fa 	strb	w26, [x23, #4]
  200ac4:	390016fb 	strb	w27, [x23, #5]
                sddf_memcpy(pkt->ethsrc_addr, device_info->mac, ETH_HWADDR_LEN);
  200ac8:	f942fb80 	ldr	x0, [x28, #1520]
  200acc:	39400001 	ldrb	w1, [x0]
  200ad0:	39001ae1 	strb	w1, [x23, #6]
  200ad4:	39400401 	ldrb	w1, [x0, #1]
  200ad8:	39001ee1 	strb	w1, [x23, #7]
  200adc:	39400801 	ldrb	w1, [x0, #2]
  200ae0:	390022e1 	strb	w1, [x23, #8]
    return queue->free->tail - queue->free->head == 0;
  200ae4:	f942ff81 	ldr	x1, [x28, #1528]
  200ae8:	39400c02 	ldrb	w2, [x0, #3]
  200aec:	390026e2 	strb	w2, [x23, #9]
  200af0:	39401002 	ldrb	w2, [x0, #4]
  200af4:	39002ae2 	strb	w2, [x23, #10]
  200af8:	39401400 	ldrb	w0, [x0, #5]
  200afc:	39002ee0 	strb	w0, [x23, #11]
  200b00:	79400422 	ldrh	w2, [x1, #2]
 *
 * @return -1 when queue is empty, 0 on success.
 */
static inline int net_dequeue_free(net_queue_handle_t *queue, net_buff_desc_t *buffer)
{
    if (net_queue_empty_free(queue)) {
  200b04:	79400020 	ldrh	w0, [x1]
  200b08:	6b02001f 	cmp	w0, w2
  200b0c:	54001a20 	b.eq	200e50 <process_arp_waiting+0x720>  // b.none
        return -1;
    }

    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200b10:	b9460b83 	ldr	w3, [x28, #1544]
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->free->head++;
  200b14:	11000447 	add	w7, w2, #0x1
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200b18:	1ac30840 	udiv	w0, w2, w3
  200b1c:	1b038800 	msub	w0, w0, w3, w2
  200b20:	8b001020 	add	x0, x1, x0, lsl #4
  200b24:	f9400400 	ldr	x0, [x0, #8]
    queue->free->head++;
  200b28:	79000427 	strh	w7, [x1, #2]
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200b2c:	f90047e0 	str	x0, [sp, #136]
                assert(!err);
  200b30:	aa0003e2 	mov	x2, x0
                sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[waiting_packet->filter].data.vaddr + waiting_packet->buffer.io_or_offset), waiting_packet->buffer.len);
  200b34:	79405260 	ldrh	w0, [x19, #40]
  200b38:	d2800701 	mov	x1, #0x38                  	// #56
  200b3c:	b0000036 	adrp	x22, 205000 <__sel4_ipc_buffer>
  200b40:	910022d6 	add	x22, x22, #0x8
  200b44:	79404267 	ldrh	w7, [x19, #32]
  200b48:	f9400e63 	ldr	x3, [x19, #24]
  200b4c:	9b012000 	madd	x0, x0, x1, x8
  200b50:	f94036c1 	ldr	x1, [x22, #104]
    while (n-- > 0) {
  200b54:	d10004e8 	sub	x8, x7, #0x1
  200b58:	f9403800 	ldr	x0, [x0, #112]
                pkt->check = 0;
  200b5c:	390062ff 	strb	wzr, [x23, #24]
  200b60:	390066ff 	strb	wzr, [x23, #25]
                sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[waiting_packet->filter].data.vaddr + waiting_packet->buffer.io_or_offset), waiting_packet->buffer.len);
  200b64:	8b020021 	add	x1, x1, x2
  200b68:	8b030002 	add	x2, x0, x3
  200b6c:	b40015c7 	cbz	x7, 200e24 <process_arp_waiting+0x6f4>
  200b70:	f100391f 	cmp	x8, #0xe
  200b74:	540013a9 	b.ls	200de8 <process_arp_waiting+0x6b8>  // b.plast
  200b78:	91000463 	add	x3, x3, #0x1
  200b7c:	aa020026 	orr	x6, x1, x2
  200b80:	8b030003 	add	x3, x0, x3
  200b84:	d2800000 	mov	x0, #0x0                   	// #0
  200b88:	cb030023 	sub	x3, x1, x3
  200b8c:	f2400cdf 	tst	x6, #0xf
  200b90:	fa4e0860 	ccmp	x3, #0xe, #0x0, eq	// eq = none
  200b94:	54000948 	b.hi	200cbc <process_arp_waiting+0x58c>  // b.pmore
        *to++ = *from++;
  200b98:	38606843 	ldrb	w3, [x2, x0]
  200b9c:	38206823 	strb	w3, [x1, x0]
    while (n-- > 0) {
  200ba0:	91000400 	add	x0, x0, #0x1
  200ba4:	eb0000ff 	cmp	x7, x0
  200ba8:	54ffff81 	b.ne	200b98 <process_arp_waiting+0x468>  // b.any
                buffer_tx.len = waiting_packet->buffer.len;
  200bac:	79404267 	ldrh	w7, [x19, #32]
    return queue->active->tail - queue->active->head == queue->capacity;
  200bb0:	f9430381 	ldr	x1, [x28, #1536]
  200bb4:	b9460b83 	ldr	w3, [x28, #1544]
  200bb8:	79400022 	ldrh	w2, [x1]
  200bbc:	79400420 	ldrh	w0, [x1, #2]
  200bc0:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  200bc4:	6b03001f 	cmp	w0, w3
  200bc8:	540015c0 	b.eq	200e80 <process_arp_waiting+0x750>  // b.none
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  200bcc:	1ac30840 	udiv	w0, w2, w3
  200bd0:	d2800108 	mov	x8, #0x8                   	// #8
    queue->active->tail++;
  200bd4:	11000446 	add	w6, w2, #0x1
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  200bd8:	1b038800 	msub	w0, w0, w3, w2
  200bdc:	f94047e3 	ldr	x3, [sp, #136]
  200be0:	8b205100 	add	x0, x8, w0, uxtw #4
  200be4:	8b000022 	add	x2, x1, x0
  200be8:	f8206823 	str	x3, [x1, x0]
  200bec:	79001047 	strh	w7, [x2, #8]
    queue->active->tail++;
  200bf0:	79000026 	strh	w6, [x1]
    return queue->free->tail - queue->free->head == queue->capacity;
  200bf4:	79405260 	ldrh	w0, [x19, #40]
  200bf8:	d2800302 	mov	x2, #0x18                  	// #24
  200bfc:	9100e381 	add	x1, x28, #0x38
                waiting_packet->buffer.len = 0;
  200c00:	7900427f 	strh	wzr, [x19, #32]
                err = net_enqueue_free(&state.filter_queue[waiting_packet->filter], waiting_packet->buffer);
  200c04:	f9400e67 	ldr	x7, [x19, #24]
  200c08:	9b027c00 	mul	x0, x0, x2
  200c0c:	8b000022 	add	x2, x1, x0
  200c10:	f8606821 	ldr	x1, [x1, x0]
  200c14:	b9401043 	ldr	w3, [x2, #16]
  200c18:	79400420 	ldrh	w0, [x1, #2]
  200c1c:	79400022 	ldrh	w2, [x1]
  200c20:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  200c24:	6b03001f 	cmp	w0, w3
  200c28:	540013e0 	b.eq	200ea4 <process_arp_waiting+0x774>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200c2c:	1ac30840 	udiv	w0, w2, w3
    queue->free->tail++;
  200c30:	11000446 	add	w6, w2, #0x1
  200c34:	1b038800 	msub	w0, w0, w3, w2
  200c38:	8b001020 	add	x0, x1, x0, lsl #4
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200c3c:	f9000407 	str	x7, [x0, #8]
  200c40:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  200c44:	79000026 	strh	w6, [x1]
}
#endif

static inline void microkit_deferred_notify(microkit_channel ch)
{
    if ((microkit_notifications & (1ULL << ch)) == 0) {
  200c48:	d0000020 	adrp	x0, 206000 <state+0x178>
  200c4c:	f942b000 	ldr	x0, [x0, #1376]
                microkit_deferred_notify(net_config.tx.id);
  200c50:	39418ad6 	ldrb	w22, [x22, #98]
  200c54:	9ad62400 	lsr	x0, x0, x22
  200c58:	36000ce0 	tbz	w0, #0, 200df4 <process_arp_waiting+0x6c4>
        microkit_dbg_puts("'\n");
        return;
    }
    microkit_have_signal = seL4_True;
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  200c5c:	d0000026 	adrp	x6, 206000 <state+0x178>
    microkit_have_signal = seL4_True;
  200c60:	d0000022 	adrp	x2, 206000 <state+0x178>
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  200c64:	d0000021 	adrp	x1, 206000 <state+0x178>
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  200c68:	11002ac0 	add	w0, w22, #0xa
    microkit_have_signal = seL4_True;
  200c6c:	52800023 	mov	w3, #0x1                   	// #1
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  200c70:	f902a8c0 	str	x0, [x6, #1360]
    microkit_have_signal = seL4_True;
  200c74:	39150443 	strb	w3, [x2, #1345]
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  200c78:	f902a43f 	str	xzr, [x1, #1352]
    assert(info && node);
  200c7c:	17fffeff 	b	200878 <process_arp_waiting+0x148>
            sddf_dprintf("There where no packets waiting.")
  200c80:	90000020 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  200c84:	910e8000 	add	x0, x0, #0x3a0
  200c88:	94000c9e 	bl	203f00 <sddf_printf_>
        sddf_dprintf("ROUTING_EXTERNAL|Processing arp waiting queue\n");
  200c8c:	f94037e0 	ldr	x0, [sp, #104]
  200c90:	94000c9c 	bl	203f00 <sddf_printf_>
            err = net_enqueue_free(&state.filter_queue[waiting_packet->filter], waiting_packet->buffer);
  200c94:	d2800000 	mov	x0, #0x0                   	// #0
  200c98:	79405000 	ldrh	w0, [x0, #40]
  200c9c:	d4207d00 	brk	#0x3e8
        info->tail = prev;
  200ca0:	f9001781 	str	x1, [x28, #40]
  200ca4:	17fffefa 	b	20088c <process_arp_waiting+0x15c>
            sddf_dprintf("ROUTING_EXTERNAL|Unable to find packet waiting on ip address from ARP response.\n");
  200ca8:	f9403fe0 	ldr	x0, [sp, #120]
  200cac:	94000c95 	bl	203f00 <sddf_printf_>
    assert(info && node);
  200cb0:	17fffef2 	b	200878 <process_arp_waiting+0x148>
    while (n-- > 0) {
  200cb4:	aa1303e7 	mov	x7, x19
  200cb8:	17ffff4c 	b	2009e8 <process_arp_waiting+0x2b8>
  200cbc:	d10040e3 	sub	x3, x7, #0x10
    while (n-- > 0) {
  200cc0:	d2800006 	mov	x6, #0x0                   	// #0
  200cc4:	d344fc63 	lsr	x3, x3, #4
  200cc8:	91000463 	add	x3, x3, #0x1
  200ccc:	d503201f 	nop
        *to++ = *from++;
  200cd0:	3ce06840 	ldr	q0, [x2, x0]
  200cd4:	910004c6 	add	x6, x6, #0x1
  200cd8:	eb06007f 	cmp	x3, x6
  200cdc:	3ca06820 	str	q0, [x1, x0]
    while (n-- > 0) {
  200ce0:	91004000 	add	x0, x0, #0x10
  200ce4:	54ffff68 	b.hi	200cd0 <process_arp_waiting+0x5a0>  // b.pmore
  200ce8:	d37cec63 	lsl	x3, x3, #4
  200cec:	eb0300ff 	cmp	x7, x3
  200cf0:	cb030100 	sub	x0, x8, x3
  200cf4:	8b030047 	add	x7, x2, x3
  200cf8:	8b030026 	add	x6, x1, x3
  200cfc:	54fff580 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d00:	38636842 	ldrb	w2, [x2, x3]
  200d04:	38236822 	strb	w2, [x1, x3]
    while (n-- > 0) {
  200d08:	b4fff520 	cbz	x0, 200bac <process_arp_waiting+0x47c>
        *to++ = *from++;
  200d0c:	394004e1 	ldrb	w1, [x7, #1]
    while (n-- > 0) {
  200d10:	f100041f 	cmp	x0, #0x1
        *to++ = *from++;
  200d14:	390004c1 	strb	w1, [x6, #1]
    while (n-- > 0) {
  200d18:	54fff4a0 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d1c:	394008e1 	ldrb	w1, [x7, #2]
    while (n-- > 0) {
  200d20:	f100081f 	cmp	x0, #0x2
        *to++ = *from++;
  200d24:	390008c1 	strb	w1, [x6, #2]
    while (n-- > 0) {
  200d28:	54fff420 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d2c:	39400ce1 	ldrb	w1, [x7, #3]
    while (n-- > 0) {
  200d30:	f1000c1f 	cmp	x0, #0x3
        *to++ = *from++;
  200d34:	39000cc1 	strb	w1, [x6, #3]
    while (n-- > 0) {
  200d38:	54fff3a0 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d3c:	394010e1 	ldrb	w1, [x7, #4]
    while (n-- > 0) {
  200d40:	f100101f 	cmp	x0, #0x4
        *to++ = *from++;
  200d44:	390010c1 	strb	w1, [x6, #4]
    while (n-- > 0) {
  200d48:	54fff320 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d4c:	394014e1 	ldrb	w1, [x7, #5]
    while (n-- > 0) {
  200d50:	f100141f 	cmp	x0, #0x5
        *to++ = *from++;
  200d54:	390014c1 	strb	w1, [x6, #5]
    while (n-- > 0) {
  200d58:	54fff2a0 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d5c:	394018e1 	ldrb	w1, [x7, #6]
    while (n-- > 0) {
  200d60:	f100181f 	cmp	x0, #0x6
        *to++ = *from++;
  200d64:	390018c1 	strb	w1, [x6, #6]
    while (n-- > 0) {
  200d68:	54fff220 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d6c:	39401ce1 	ldrb	w1, [x7, #7]
    while (n-- > 0) {
  200d70:	f1001c1f 	cmp	x0, #0x7
        *to++ = *from++;
  200d74:	39001cc1 	strb	w1, [x6, #7]
    while (n-- > 0) {
  200d78:	54fff1a0 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d7c:	394020e1 	ldrb	w1, [x7, #8]
    while (n-- > 0) {
  200d80:	f100201f 	cmp	x0, #0x8
        *to++ = *from++;
  200d84:	390020c1 	strb	w1, [x6, #8]
    while (n-- > 0) {
  200d88:	54fff120 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d8c:	394024e1 	ldrb	w1, [x7, #9]
    while (n-- > 0) {
  200d90:	f100241f 	cmp	x0, #0x9
        *to++ = *from++;
  200d94:	390024c1 	strb	w1, [x6, #9]
    while (n-- > 0) {
  200d98:	54fff0a0 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200d9c:	394028e1 	ldrb	w1, [x7, #10]
    while (n-- > 0) {
  200da0:	f100281f 	cmp	x0, #0xa
        *to++ = *from++;
  200da4:	390028c1 	strb	w1, [x6, #10]
    while (n-- > 0) {
  200da8:	54fff020 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200dac:	39402ce1 	ldrb	w1, [x7, #11]
    while (n-- > 0) {
  200db0:	f1002c1f 	cmp	x0, #0xb
        *to++ = *from++;
  200db4:	39002cc1 	strb	w1, [x6, #11]
    while (n-- > 0) {
  200db8:	54ffefa0 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200dbc:	394030e1 	ldrb	w1, [x7, #12]
    while (n-- > 0) {
  200dc0:	f100301f 	cmp	x0, #0xc
        *to++ = *from++;
  200dc4:	390030c1 	strb	w1, [x6, #12]
    while (n-- > 0) {
  200dc8:	54ffef20 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200dcc:	394034e1 	ldrb	w1, [x7, #13]
    while (n-- > 0) {
  200dd0:	f100341f 	cmp	x0, #0xd
        *to++ = *from++;
  200dd4:	390034c1 	strb	w1, [x6, #13]
    while (n-- > 0) {
  200dd8:	54ffeea0 	b.eq	200bac <process_arp_waiting+0x47c>  // b.none
        *to++ = *from++;
  200ddc:	394038e0 	ldrb	w0, [x7, #14]
  200de0:	390038c0 	strb	w0, [x6, #14]
    while (n-- > 0) {
  200de4:	17ffff72 	b	200bac <process_arp_waiting+0x47c>
  200de8:	d2800000 	mov	x0, #0x0                   	// #0
  200dec:	17ffff6b 	b	200b98 <process_arp_waiting+0x468>
  200df0:	d65f03c0 	ret
        microkit_dbg_puts(microkit_name);
  200df4:	d0000020 	adrp	x0, 206000 <state+0x178>
  200df8:	91140000 	add	x0, x0, #0x500
  200dfc:	9400054d 	bl	202330 <microkit_dbg_puts>
        microkit_dbg_puts(" microkit_deferred_notify: invalid channel given '");
  200e00:	90000020 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  200e04:	91112000 	add	x0, x0, #0x448
  200e08:	9400054a 	bl	202330 <microkit_dbg_puts>
        microkit_dbg_put8((seL4_Uint8)ch);
  200e0c:	2a1603e0 	mov	w0, w22
  200e10:	94000558 	bl	202370 <microkit_dbg_put8>
        microkit_dbg_puts("'\n");
  200e14:	90000020 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  200e18:	91120000 	add	x0, x0, #0x480
  200e1c:	94000545 	bl	202330 <microkit_dbg_puts>
  200e20:	17fffe96 	b	200878 <process_arp_waiting+0x148>
  200e24:	52800007 	mov	w7, #0x0                   	// #0
  200e28:	17ffff62 	b	200bb0 <process_arp_waiting+0x480>
            assert(!err);
  200e2c:	90000023 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  200e30:	90000021 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  200e34:	9109e063 	add	x3, x3, #0x278
  200e38:	910fc021 	add	x1, x1, #0x3f0
  200e3c:	90000020 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  200e40:	52800d42 	mov	w2, #0x6a                  	// #106
  200e44:	91110000 	add	x0, x0, #0x440
  200e48:	94000cea 	bl	2041f0 <_assert_fail>
  200e4c:	17fffe8b 	b	200878 <process_arp_waiting+0x148>
                assert(!err);
  200e50:	52800e42 	mov	w2, #0x72                  	// #114
  200e54:	90000023 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  200e58:	90000021 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  200e5c:	9109e063 	add	x3, x3, #0x278
  200e60:	910fc021 	add	x1, x1, #0x3f0
  200e64:	90000020 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  200e68:	91110000 	add	x0, x0, #0x440
  200e6c:	94000ce1 	bl	2041f0 <_assert_fail>
  200e70:	f94047e2 	ldr	x2, [sp, #136]
  200e74:	b0000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
  200e78:	91026008 	add	x8, x0, #0x98
  200e7c:	17ffff2e 	b	200b34 <process_arp_waiting+0x404>
                assert(!err);
  200e80:	90000023 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  200e84:	90000021 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  200e88:	9109e063 	add	x3, x3, #0x278
  200e8c:	910fc021 	add	x1, x1, #0x3f0
  200e90:	90000020 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  200e94:	52800f42 	mov	w2, #0x7a                  	// #122
  200e98:	91110000 	add	x0, x0, #0x440
  200e9c:	94000cd5 	bl	2041f0 <_assert_fail>
  200ea0:	17ffff55 	b	200bf4 <process_arp_waiting+0x4c4>
                assert(!err);
  200ea4:	90000023 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  200ea8:	90000021 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  200eac:	9109e063 	add	x3, x3, #0x278
  200eb0:	910fc021 	add	x1, x1, #0x3f0
  200eb4:	90000020 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  200eb8:	52800fa2 	mov	w2, #0x7d                  	// #125
  200ebc:	91110000 	add	x0, x0, #0x440
  200ec0:	94000ccc 	bl	2041f0 <_assert_fail>
  200ec4:	17ffff61 	b	200c48 <process_arp_waiting+0x518>
  200ec8:	d503201f 	nop
  200ecc:	d503201f 	nop

0000000000200ed0 <find_route>:
uint32_t find_route(uint32_t ip)
{
    // TODO: extend this function to match with the longest subnet mask,
    // and if tied in this step, find the route with the least hops.
    for (int i = 0; i < NUM_ROUTES; i++) {
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200ed0:	b0000024 	adrp	x4, 205000 <__sel4_ipc_buffer>
  200ed4:	91394084 	add	x4, x4, #0xe50
{
  200ed8:	2a0003e2 	mov	w2, w0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200edc:	91184081 	add	x1, x4, #0x610
  200ee0:	b9461080 	ldr	w0, [x4, #1552]
  200ee4:	b9400423 	ldr	w3, [x1, #4]
  200ee8:	4a000040 	eor	w0, w2, w0
  200eec:	6a03001f 	tst	w0, w3
  200ef0:	540004e0 	b.eq	200f8c <find_route+0xbc>  // b.none
  200ef4:	29418c20 	ldp	w0, w3, [x1, #12]
  200ef8:	4a000040 	eor	w0, w2, w0
  200efc:	6a03001f 	tst	w0, w3
  200f00:	54000500 	b.eq	200fa0 <find_route+0xd0>  // b.none
  200f04:	29430c20 	ldp	w0, w3, [x1, #24]
  200f08:	4a000040 	eor	w0, w2, w0
  200f0c:	6a03001f 	tst	w0, w3
  200f10:	54000500 	b.eq	200fb0 <find_route+0xe0>  // b.none
  200f14:	29448c20 	ldp	w0, w3, [x1, #36]
  200f18:	4a000040 	eor	w0, w2, w0
  200f1c:	6a03001f 	tst	w0, w3
  200f20:	540004c0 	b.eq	200fb8 <find_route+0xe8>  // b.none
  200f24:	29460c20 	ldp	w0, w3, [x1, #48]
  200f28:	4a000040 	eor	w0, w2, w0
  200f2c:	6a03001f 	tst	w0, w3
  200f30:	54000480 	b.eq	200fc0 <find_route+0xf0>  // b.none
  200f34:	29478c20 	ldp	w0, w3, [x1, #60]
  200f38:	4a000040 	eor	w0, w2, w0
  200f3c:	6a03001f 	tst	w0, w3
  200f40:	54000440 	b.eq	200fc8 <find_route+0xf8>  // b.none
  200f44:	29490c20 	ldp	w0, w3, [x1, #72]
  200f48:	4a000040 	eor	w0, w2, w0
  200f4c:	6a03001f 	tst	w0, w3
  200f50:	54000400 	b.eq	200fd0 <find_route+0x100>  // b.none
  200f54:	294a8c20 	ldp	w0, w3, [x1, #84]
  200f58:	4a000040 	eor	w0, w2, w0
  200f5c:	6a03001f 	tst	w0, w3
  200f60:	540003c0 	b.eq	200fd8 <find_route+0x108>  // b.none
  200f64:	294c0c20 	ldp	w0, w3, [x1, #96]
  200f68:	4a000040 	eor	w0, w2, w0
  200f6c:	6a03001f 	tst	w0, w3
  200f70:	54000380 	b.eq	200fe0 <find_route+0x110>  // b.none
  200f74:	294d8423 	ldp	w3, w1, [x1, #108]
            return routing_table[i].next_hop;
        }
    }

    // If we have gotten here, assume on the default gateway.
    return 0;
  200f78:	52800000 	mov	w0, #0x0                   	// #0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200f7c:	4a030042 	eor	w2, w2, w3
  200f80:	6a01005f 	tst	w2, w1
  200f84:	54000120 	b.eq	200fa8 <find_route+0xd8>  // b.none
}
  200f88:	d65f03c0 	ret
    for (int i = 0; i < NUM_ROUTES; i++) {
  200f8c:	d2800000 	mov	x0, #0x0                   	// #0
            return routing_table[i].next_hop;
  200f90:	d2800181 	mov	x1, #0xc                   	// #12
  200f94:	9b011000 	madd	x0, x0, x1, x4
  200f98:	b9461800 	ldr	w0, [x0, #1560]
}
  200f9c:	d65f03c0 	ret
    for (int i = 0; i < NUM_ROUTES; i++) {
  200fa0:	d2800020 	mov	x0, #0x1                   	// #1
  200fa4:	17fffffb 	b	200f90 <find_route+0xc0>
  200fa8:	d2800120 	mov	x0, #0x9                   	// #9
  200fac:	17fffff9 	b	200f90 <find_route+0xc0>
  200fb0:	d2800040 	mov	x0, #0x2                   	// #2
  200fb4:	17fffff7 	b	200f90 <find_route+0xc0>
  200fb8:	d2800060 	mov	x0, #0x3                   	// #3
  200fbc:	17fffff5 	b	200f90 <find_route+0xc0>
  200fc0:	d2800080 	mov	x0, #0x4                   	// #4
  200fc4:	17fffff3 	b	200f90 <find_route+0xc0>
  200fc8:	d28000a0 	mov	x0, #0x5                   	// #5
  200fcc:	17fffff1 	b	200f90 <find_route+0xc0>
  200fd0:	d28000c0 	mov	x0, #0x6                   	// #6
  200fd4:	17ffffef 	b	200f90 <find_route+0xc0>
  200fd8:	d28000e0 	mov	x0, #0x7                   	// #7
  200fdc:	17ffffed 	b	200f90 <find_route+0xc0>
  200fe0:	d2800100 	mov	x0, #0x8                   	// #8
  200fe4:	17ffffeb 	b	200f90 <find_route+0xc0>
  200fe8:	d503201f 	nop
  200fec:	d503201f 	nop

0000000000200ff0 <route>:



void route()
{
  200ff0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  200ff4:	910003fd 	mov	x29, sp
  200ff8:	a9046bf9 	stp	x25, x26, [sp, #64]
    // Check the IP address of the packet.
    bool transmitted = false;
    for (int filter = 0; filter < router_config.num_filters; filter++) {
  200ffc:	b000003a 	adrp	x26, 205000 <__sel4_ipc_buffer>
  201000:	9102635a 	add	x26, x26, #0x98
  201004:	795b4340 	ldrh	w0, [x26, #3488]
  201008:	340016a0 	cbz	w0, 2012dc <route+0x2ec>
  20100c:	a90153f3 	stp	x19, x20, [sp, #16]
  201010:	90000033 	adrp	x19, 205000 <__sel4_ipc_buffer>
  201014:	91394273 	add	x19, x19, #0xe50
  201018:	9100e274 	add	x20, x19, #0x38
  20101c:	a9025bf5 	stp	x21, x22, [sp, #32]
  201020:	aa1a03f5 	mov	x21, x26
  201024:	a90573fb 	stp	x27, x28, [sp, #80]
                        int err = net_dequeue_free(&virt_tx_queue, &buffer_tx);
                        assert(!err);

                        // @kwinter: For now we are memcpy'ing the packet from our receive buffer
                        // to the transmit buffer.
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  201028:	9000003b 	adrp	x27, 205000 <__sel4_ipc_buffer>
  20102c:	9100237b 	add	x27, x27, #0x8
    bool transmitted = false;
  201030:	5280001c 	mov	w28, #0x0                   	// #0
  201034:	a90363f7 	stp	x23, x24, [sp, #48]
    return key % TABLE_SIZE;
  201038:	5287fc37 	mov	w23, #0x3fe1                	// #16353
  20103c:	72bff017 	movk	w23, #0xff80, lsl #16
    for (int filter = 0; filter < router_config.num_filters; filter++) {
  201040:	52800018 	mov	w24, #0x0                   	// #0
  201044:	d503201f 	nop
    return queue->active->tail - queue->active->head == 0;
  201048:	f9400684 	ldr	x4, [x20, #8]
  20104c:	52808056 	mov	w22, #0x402                 	// #1026
  201050:	79400089 	ldrh	w9, [x4]
  201054:	79400481 	ldrh	w1, [x4, #2]
            while (!net_queue_empty_active(&state.filter_queue[filter]) && !net_queue_empty_free(&virt_tx_queue)) {
  201058:	6b01013f 	cmp	w9, w1
  20105c:	540000a1 	b.ne	201070 <route+0x80>  // b.any
  201060:	14000090 	b	2012a0 <route+0x2b0>
  201064:	79400481 	ldrh	w1, [x4, #2]
  201068:	6b09003f 	cmp	w1, w9
  20106c:	540011a0 	b.eq	2012a0 <route+0x2b0>  // b.none
    return queue->free->tail - queue->free->head == 0;
  201070:	f942fe60 	ldr	x0, [x19, #1528]
  201074:	79400002 	ldrh	w2, [x0]
  201078:	79400400 	ldrh	w0, [x0, #2]
  20107c:	6b00005f 	cmp	w2, w0
  201080:	54001340 	b.eq	2012e8 <route+0x2f8>  // b.none
{
    if (net_queue_empty_active(queue)) {
        return -1;
    }

    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  201084:	b9401285 	ldr	w5, [x20, #16]
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->active->head++;
  201088:	11000423 	add	w3, w1, #0x1
                struct ipv4_packet *pkt = (struct ipv4_packet *)(router_config.filters[filter].data.vaddr + buffer.io_or_offset);
  20108c:	f9403aa8 	ldr	x8, [x21, #112]
    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  201090:	1ac50820 	udiv	w0, w1, w5
  201094:	1b058400 	msub	w0, w0, w5, w1
  201098:	8b001080 	add	x0, x4, x0, lsl #4
  20109c:	f9400406 	ldr	x6, [x0, #8]
  2010a0:	79402007 	ldrh	w7, [x0, #16]
  2010a4:	8b060102 	add	x2, x8, x6
    queue->active->head++;
  2010a8:	79000483 	strh	w3, [x4, #2]
                if (pkt->ttl > 1 && pkt->type == HTONS(ETH_TYPE_IP)) {
  2010ac:	39405841 	ldrb	w1, [x2, #22]
  2010b0:	7100043f 	cmp	w1, #0x1
  2010b4:	54fffd89 	b.ls	201064 <route+0x74>  // b.plast
  2010b8:	39403043 	ldrb	w3, [x2, #12]
  2010bc:	39403440 	ldrb	w0, [x2, #13]
  2010c0:	2a002060 	orr	w0, w3, w0, lsl #8
  2010c4:	7100201f 	cmp	w0, #0x8
  2010c8:	54fffce1 	b.ne	201064 <route+0x74>  // b.any
                    uint32_t destIP = pkt->dst_ip;
  2010cc:	39407849 	ldrb	w9, [x2, #30]
                    pkt->ttl -= 1;
  2010d0:	51000421 	sub	w1, w1, #0x1
                    uint32_t destIP = pkt->dst_ip;
  2010d4:	39407c4b 	ldrb	w11, [x2, #31]
  2010d8:	3940804a 	ldrb	w10, [x2, #32]
  2010dc:	39408440 	ldrb	w0, [x2, #33]
  2010e0:	aa0b212b 	orr	x11, x9, x11, lsl #8
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  2010e4:	b9461269 	ldr	w9, [x19, #1552]
                    uint32_t destIP = pkt->dst_ip;
  2010e8:	aa0a416a 	orr	x10, x11, x10, lsl #16
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  2010ec:	b946166b 	ldr	w11, [x19, #1556]
                    uint32_t destIP = pkt->dst_ip;
  2010f0:	aa006140 	orr	x0, x10, x0, lsl #24
                    pkt->ttl -= 1;
  2010f4:	39005841 	strb	w1, [x2, #22]
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  2010f8:	4a000121 	eor	w1, w9, w0
                    uint32_t destIP = pkt->dst_ip;
  2010fc:	2a0003ed 	mov	w13, w0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  201100:	6a0b003f 	tst	w1, w11
  201104:	54003160 	b.eq	201730 <route+0x740>  // b.none
  201108:	b9461e61 	ldr	w1, [x19, #1564]
  20110c:	b9462269 	ldr	w9, [x19, #1568]
  201110:	4a000021 	eor	w1, w1, w0
  201114:	6a09003f 	tst	w1, w9
  201118:	540031c0 	b.eq	201750 <route+0x760>  // b.none
  20111c:	b9462a61 	ldr	w1, [x19, #1576]
  201120:	b9462e69 	ldr	w9, [x19, #1580]
  201124:	4a000021 	eor	w1, w1, w0
  201128:	6a09003f 	tst	w1, w9
  20112c:	54003160 	b.eq	201758 <route+0x768>  // b.none
  201130:	b9463661 	ldr	w1, [x19, #1588]
  201134:	b9463a69 	ldr	w9, [x19, #1592]
  201138:	4a000021 	eor	w1, w1, w0
  20113c:	6a09003f 	tst	w1, w9
  201140:	54003100 	b.eq	201760 <route+0x770>  // b.none
  201144:	b9464261 	ldr	w1, [x19, #1600]
  201148:	b9464669 	ldr	w9, [x19, #1604]
  20114c:	4a000021 	eor	w1, w1, w0
  201150:	6a09003f 	tst	w1, w9
  201154:	540030a0 	b.eq	201768 <route+0x778>  // b.none
  201158:	b9464e61 	ldr	w1, [x19, #1612]
  20115c:	b9465269 	ldr	w9, [x19, #1616]
  201160:	4a000021 	eor	w1, w1, w0
  201164:	6a09003f 	tst	w1, w9
  201168:	54003040 	b.eq	201770 <route+0x780>  // b.none
  20116c:	b9465a61 	ldr	w1, [x19, #1624]
  201170:	b9465e63 	ldr	w3, [x19, #1628]
  201174:	4a000021 	eor	w1, w1, w0
  201178:	6a03003f 	tst	w1, w3
  20117c:	54002fe0 	b.eq	201778 <route+0x788>  // b.none
  201180:	b9466663 	ldr	w3, [x19, #1636]
  201184:	b9466a69 	ldr	w9, [x19, #1640]
  201188:	4a000063 	eor	w3, w3, w0
  20118c:	6a09007f 	tst	w3, w9
  201190:	54002f80 	b.eq	201780 <route+0x790>  // b.none
  201194:	b9467263 	ldr	w3, [x19, #1648]
  201198:	b9467669 	ldr	w9, [x19, #1652]
  20119c:	4a000063 	eor	w3, w3, w0
  2011a0:	6a09007f 	tst	w3, w9
  2011a4:	54002f20 	b.eq	201788 <route+0x798>  // b.none
  2011a8:	b9467e63 	ldr	w3, [x19, #1660]
                        nextIP = destIP;
  2011ac:	2a0003eb 	mov	w11, w0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  2011b0:	b9468269 	ldr	w9, [x19, #1664]
  2011b4:	4a000061 	eor	w1, w3, w0
  2011b8:	6a09003f 	tst	w1, w9
  2011bc:	54002ea0 	b.eq	201790 <route+0x7a0>  // b.none
  2011c0:	9bb77d6a 	umull	x10, w11, w23
        if (table->entries[index].key == key) {
  2011c4:	d280018c 	mov	x12, #0xc                   	// #12
                    int ret = hashtable_search(arp_table, (uint32_t) nextIP, &hash_entry);
  2011c8:	f9434669 	ldr	x9, [x19, #1672]
    return key % TABLE_SIZE;
  2011cc:	d36afd4a 	lsr	x10, x10, #42
  2011d0:	1b16ad4a 	msub	w10, w10, w22, w11
    uint32_t index = hash(key);
  2011d4:	2a0a03e0 	mov	w0, w10
    while (table->used[index]) {
  2011d8:	1400000b 	b	201204 <route+0x214>
        if (table->entries[index].key == key) {
  2011dc:	9b0c7c21 	mul	x1, x1, x12
  2011e0:	b8616921 	ldr	w1, [x9, x1]
  2011e4:	6b01017f 	cmp	w11, w1
  2011e8:	54000860 	b.eq	2012f4 <route+0x304>  // b.none
        index = (index + 1) % TABLE_SIZE;
  2011ec:	11000401 	add	w1, w0, #0x1
  2011f0:	9bb77c20 	umull	x0, w1, w23
  2011f4:	d36afc00 	lsr	x0, x0, #42
  2011f8:	1b168400 	msub	w0, w0, w22, w1
        if (index == original_index) {
  2011fc:	6b00015f 	cmp	w10, w0
  201200:	540000c0 	b.eq	201218 <route+0x228>  // b.none
    while (table->used[index]) {
  201204:	2a0003e1 	mov	w1, w0
  201208:	8b010123 	add	x3, x9, x1
  20120c:	91400c63 	add	x3, x3, #0x3, lsl #12
  201210:	39406063 	ldrb	w3, [x3, #24]
  201214:	35fffe43 	cbnz	w3, 2011dc <route+0x1ec>
                    if (ret == -1 && !llfull(&pkt_waiting_queue)) {
  201218:	f9400e60 	ldr	x0, [x19, #24]
  20121c:	b4002040 	cbz	x0, 201624 <route+0x634>
                        if (!arp_queue_full_request(arp_queries) && !check_waiting(&pkt_waiting_queue, destIP)) {
  201220:	f9400262 	ldr	x2, [x19]
    return queue->request.tail - queue->request.head == queue->capacity;
  201224:	79400048 	ldrh	w8, [x2]
  201228:	79400440 	ldrh	w0, [x2, #2]
  20122c:	b9700843 	ldr	w3, [x2, #12296]
  201230:	4b000100 	sub	w0, w8, w0
  201234:	6b03001f 	cmp	w0, w3
  201238:	54000120 	b.eq	20125c <route+0x26c>  // b.none
    struct llnode_ptrs *curr = LLNODE_PTRS_CAST(info->head);
  20123c:	f9401260 	ldr	x0, [x19, #32]
    while (curr != NULL) {
  201240:	b5000080 	cbnz	x0, 201250 <route+0x260>
  201244:	140000ff 	b	201640 <route+0x650>
        curr = LLNODE_PTRS_CAST(curr->next);
  201248:	f9400000 	ldr	x0, [x0]
    while (curr != NULL) {
  20124c:	b4001fa0 	cbz	x0, 201640 <route+0x650>
        if (curr_node->ip == ip) {
  201250:	b9401001 	ldr	w1, [x0, #16]
  201254:	6b0101bf 	cmp	w13, w1
  201258:	54ffff81 	b.ne	201248 <route+0x258>  // b.any
    return queue->free->tail - queue->free->head == queue->capacity;
  20125c:	f9400281 	ldr	x1, [x20]
  201260:	79400022 	ldrh	w2, [x1]
  201264:	79400420 	ldrh	w0, [x1, #2]
  201268:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  20126c:	6b0000bf 	cmp	w5, w0
  201270:	54003180 	b.eq	2018a0 <route+0x8b0>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201274:	1ac50840 	udiv	w0, w2, w5
    queue->free->tail++;
  201278:	11000443 	add	w3, w2, #0x1
  20127c:	1b058800 	msub	w0, w0, w5, w2
  201280:	8b001020 	add	x0, x1, x0, lsl #4
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201284:	f9000406 	str	x6, [x0, #8]
  201288:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  20128c:	79000023 	strh	w3, [x1]
    return queue->active->tail - queue->active->head == 0;
  201290:	79400089 	ldrh	w9, [x4]
  201294:	79400481 	ldrh	w1, [x4, #2]
            while (!net_queue_empty_active(&state.filter_queue[filter]) && !net_queue_empty_free(&virt_tx_queue)) {
  201298:	6b09003f 	cmp	w1, w9
  20129c:	54ffeea1 	b.ne	201070 <route+0x80>  // b.any
    for (int filter = 0; filter < router_config.num_filters; filter++) {
  2012a0:	795b4340 	ldrh	w0, [x26, #3488]
  2012a4:	11000718 	add	w24, w24, #0x1
 *
 * @param queue queue handle of active queue that requires signalling upon enqueuing.
 */
static inline void net_request_signal_active(net_queue_handle_t *queue)
{
    queue->active->consumer_signalled = 0;
  2012a8:	b900049f 	str	wzr, [x4, #4]
  2012ac:	91006294 	add	x20, x20, #0x18
  2012b0:	9100e2b5 	add	x21, x21, #0x38
  2012b4:	6b18001f 	cmp	w0, w24
  2012b8:	54ffec8c 	b.gt	201048 <route+0x58>
                reprocess = true;
            }
        }
    }

    if (transmitted && net_require_signal_active(&virt_tx_queue)) {
  2012bc:	3400009c 	cbz	w28, 2012cc <route+0x2dc>
 *
 * @param queue queue handle of the active queue to check.
 */
static inline bool net_require_signal_active(net_queue_handle_t *queue)
{
    return !queue->active->consumer_signalled;
  2012c0:	f9430260 	ldr	x0, [x19, #1536]
  2012c4:	b9400401 	ldr	w1, [x0, #4]
  2012c8:	340029a1 	cbz	w1, 2017fc <route+0x80c>
  2012cc:	a94153f3 	ldp	x19, x20, [sp, #16]
  2012d0:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2012d4:	a94363f7 	ldp	x23, x24, [sp, #48]
  2012d8:	a94573fb 	ldp	x27, x28, [sp, #80]
        net_cancel_signal_active(&virt_tx_queue);
        microkit_deferred_notify(net_config.tx.id);
    }

}
  2012dc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  2012e0:	a8c87bfd 	ldp	x29, x30, [sp], #128
  2012e4:	d65f03c0 	ret
    queue->active->consumer_signalled = 1;
  2012e8:	52800020 	mov	w0, #0x1                   	// #1
  2012ec:	b9000480 	str	w0, [x4, #4]
                reprocess = true;
  2012f0:	17ffff5a 	b	201058 <route+0x68>
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  2012f4:	d2800081 	mov	x1, #0x4                   	// #4
  2012f8:	9bac0400 	umaddl	x0, w0, w12, x1
  2012fc:	8b000121 	add	x1, x9, x0
        *to++ = *from++;
  201300:	3860692a 	ldrb	w10, [x9, x0]
  201304:	39400825 	ldrb	w5, [x1, #2]
  201308:	39400429 	ldrb	w9, [x1, #1]
  20130c:	39400c24 	ldrb	w4, [x1, #3]
  201310:	39401023 	ldrb	w3, [x1, #4]
  201314:	39401420 	ldrb	w0, [x1, #5]
  201318:	3826690a 	strb	w10, [x8, x6]
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  20131c:	2a0703fc 	mov	w28, w7
  201320:	39000449 	strb	w9, [x2, #1]
  201324:	39000845 	strb	w5, [x2, #2]
  201328:	39000c44 	strb	w4, [x2, #3]
  20132c:	39001043 	strb	w3, [x2, #4]
  201330:	39001440 	strb	w0, [x2, #5]
                        sddf_memcpy(&pkt->ethsrc_addr, device_info->mac, ETH_HWADDR_LEN);
  201334:	f942fa60 	ldr	x0, [x19, #1520]
  201338:	39400003 	ldrb	w3, [x0]
  20133c:	39001843 	strb	w3, [x2, #6]
  201340:	39400403 	ldrb	w3, [x0, #1]
  201344:	39001c43 	strb	w3, [x2, #7]
  201348:	39400803 	ldrb	w3, [x0, #2]
  20134c:	39002043 	strb	w3, [x2, #8]
    return queue->free->tail - queue->free->head == 0;
  201350:	f942fe63 	ldr	x3, [x19, #1528]
  201354:	39400c04 	ldrb	w4, [x0, #3]
  201358:	39002444 	strb	w4, [x2, #9]
  20135c:	39401004 	ldrb	w4, [x0, #4]
  201360:	39002844 	strb	w4, [x2, #10]
  201364:	39401400 	ldrb	w0, [x0, #5]
  201368:	39002c40 	strb	w0, [x2, #11]
                        pkt->check = 0;
  20136c:	3900605f 	strb	wzr, [x2, #24]
  201370:	79400464 	ldrh	w4, [x3, #2]
    if (net_queue_empty_free(queue)) {
  201374:	79400060 	ldrh	w0, [x3]
  201378:	3900645f 	strb	wzr, [x2, #25]
  20137c:	6b04001f 	cmp	w0, w4
  201380:	540026a0 	b.eq	201854 <route+0x864>  // b.none
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  201384:	b9460a65 	ldr	w5, [x19, #1544]
    queue->free->head++;
  201388:	11000488 	add	w8, w4, #0x1
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  20138c:	f9403761 	ldr	x1, [x27, #104]
  201390:	f9403aa2 	ldr	x2, [x21, #112]
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  201394:	1ac50880 	udiv	w0, w4, w5
  201398:	8b060042 	add	x2, x2, x6
  20139c:	1b059000 	msub	w0, w0, w5, w4
  2013a0:	8b001060 	add	x0, x3, x0, lsl #4
  2013a4:	f9400419 	ldr	x25, [x0, #8]
    queue->free->head++;
  2013a8:	79000468 	strh	w8, [x3, #2]
  2013ac:	8b190021 	add	x1, x1, x25
    while (n-- > 0) {
  2013b0:	aa020020 	orr	x0, x1, x2
  2013b4:	91000443 	add	x3, x2, #0x1
  2013b8:	cb030023 	sub	x3, x1, x3
  2013bc:	91008b85 	add	x5, x28, #0x22
  2013c0:	f2400c1f 	tst	x0, #0xf
    uint32_t index = hash(key);
  2013c4:	d2800000 	mov	x0, #0x0                   	// #0
  2013c8:	fa4e0860 	ccmp	x3, #0xe, #0x0, eq	// eq = none
  2013cc:	54000508 	b.hi	20146c <route+0x47c>  // b.pmore
        *to++ = *from++;
  2013d0:	38606843 	ldrb	w3, [x2, x0]
  2013d4:	38206823 	strb	w3, [x1, x0]
    while (n-- > 0) {
  2013d8:	91000400 	add	x0, x0, #0x1
  2013dc:	eb05001f 	cmp	x0, x5
  2013e0:	54ffff81 	b.ne	2013d0 <route+0x3e0>  // b.any
    return queue->active->tail - queue->active->head == queue->capacity;
  2013e4:	f9430261 	ldr	x1, [x19, #1536]
  2013e8:	b9460a63 	ldr	w3, [x19, #1544]
  2013ec:	79400022 	ldrh	w2, [x1]
  2013f0:	79400420 	ldrh	w0, [x1, #2]
  2013f4:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  2013f8:	6b03001f 	cmp	w0, w3
  2013fc:	54000dc0 	b.eq	2015b4 <route+0x5c4>  // b.none
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  201400:	1ac30840 	udiv	w0, w2, w3
  201404:	d2800105 	mov	x5, #0x8                   	// #8
    queue->active->tail++;
  201408:	11000444 	add	w4, w2, #0x1
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  20140c:	1b038800 	msub	w0, w0, w3, w2
    return queue->free->tail - queue->free->head == queue->capacity;
  201410:	b9401283 	ldr	w3, [x20, #16]
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  201414:	8b2050a0 	add	x0, x5, w0, uxtw #4
  201418:	8b000022 	add	x2, x1, x0
  20141c:	f8206839 	str	x25, [x1, x0]
  201420:	79001047 	strh	w7, [x2, #8]
    queue->active->tail++;
  201424:	79000024 	strh	w4, [x1]
    return queue->free->tail - queue->free->head == queue->capacity;
  201428:	f9400281 	ldr	x1, [x20]
  20142c:	79400022 	ldrh	w2, [x1]
  201430:	79400420 	ldrh	w0, [x1, #2]
  201434:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  201438:	6b03001f 	cmp	w0, w3
  20143c:	54000e00 	b.eq	2015fc <route+0x60c>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201440:	1ac30840 	udiv	w0, w2, w3
    queue->free->tail++;
  201444:	11000444 	add	w4, w2, #0x1
  201448:	1b038800 	msub	w0, w0, w3, w2
  20144c:	8b001020 	add	x0, x1, x0, lsl #4
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201450:	f9000406 	str	x6, [x0, #8]
  201454:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  201458:	79000024 	strh	w4, [x1]
    return queue->active->tail - queue->active->head == 0;
  20145c:	f9400684 	ldr	x4, [x20, #8]
                        transmitted = true;
  201460:	5280003c 	mov	w28, #0x1                   	// #1
  201464:	79400089 	ldrh	w9, [x4]
  201468:	17fffeff 	b	201064 <route+0x74>
  20146c:	91004b83 	add	x3, x28, #0x12
  201470:	d2800004 	mov	x4, #0x0                   	// #0
  201474:	d344fc63 	lsr	x3, x3, #4
  201478:	91000463 	add	x3, x3, #0x1
  20147c:	d503201f 	nop
        *to++ = *from++;
  201480:	3ce06840 	ldr	q0, [x2, x0]
  201484:	91000484 	add	x4, x4, #0x1
  201488:	eb03009f 	cmp	x4, x3
  20148c:	3ca06820 	str	q0, [x1, x0]
    while (n-- > 0) {
  201490:	91004000 	add	x0, x0, #0x10
  201494:	54ffff63 	b.cc	201480 <route+0x490>  // b.lo, b.ul, b.last
  201498:	d37cec63 	lsl	x3, x3, #4
  20149c:	91008780 	add	x0, x28, #0x21
  2014a0:	eb05007f 	cmp	x3, x5
  2014a4:	cb030000 	sub	x0, x0, x3
  2014a8:	8b030045 	add	x5, x2, x3
  2014ac:	8b030024 	add	x4, x1, x3
  2014b0:	54fff9a0 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  2014b4:	38636842 	ldrb	w2, [x2, x3]
  2014b8:	38236822 	strb	w2, [x1, x3]
    while (n-- > 0) {
  2014bc:	b4fff940 	cbz	x0, 2013e4 <route+0x3f4>
        *to++ = *from++;
  2014c0:	394004a1 	ldrb	w1, [x5, #1]
    while (n-- > 0) {
  2014c4:	f100041f 	cmp	x0, #0x1
        *to++ = *from++;
  2014c8:	39000481 	strb	w1, [x4, #1]
    while (n-- > 0) {
  2014cc:	54fff8c0 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  2014d0:	394008a1 	ldrb	w1, [x5, #2]
    while (n-- > 0) {
  2014d4:	f100081f 	cmp	x0, #0x2
        *to++ = *from++;
  2014d8:	39000881 	strb	w1, [x4, #2]
    while (n-- > 0) {
  2014dc:	54fff840 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  2014e0:	39400ca1 	ldrb	w1, [x5, #3]
    while (n-- > 0) {
  2014e4:	f1000c1f 	cmp	x0, #0x3
        *to++ = *from++;
  2014e8:	39000c81 	strb	w1, [x4, #3]
    while (n-- > 0) {
  2014ec:	54fff7c0 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  2014f0:	394010a1 	ldrb	w1, [x5, #4]
    while (n-- > 0) {
  2014f4:	f100101f 	cmp	x0, #0x4
        *to++ = *from++;
  2014f8:	39001081 	strb	w1, [x4, #4]
    while (n-- > 0) {
  2014fc:	54fff740 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201500:	394014a1 	ldrb	w1, [x5, #5]
    while (n-- > 0) {
  201504:	f100141f 	cmp	x0, #0x5
        *to++ = *from++;
  201508:	39001481 	strb	w1, [x4, #5]
    while (n-- > 0) {
  20150c:	54fff6c0 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201510:	394018a1 	ldrb	w1, [x5, #6]
    while (n-- > 0) {
  201514:	f100181f 	cmp	x0, #0x6
        *to++ = *from++;
  201518:	39001881 	strb	w1, [x4, #6]
    while (n-- > 0) {
  20151c:	54fff640 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201520:	39401ca1 	ldrb	w1, [x5, #7]
    while (n-- > 0) {
  201524:	f1001c1f 	cmp	x0, #0x7
        *to++ = *from++;
  201528:	39001c81 	strb	w1, [x4, #7]
    while (n-- > 0) {
  20152c:	54fff5c0 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201530:	394020a1 	ldrb	w1, [x5, #8]
    while (n-- > 0) {
  201534:	f100201f 	cmp	x0, #0x8
        *to++ = *from++;
  201538:	39002081 	strb	w1, [x4, #8]
    while (n-- > 0) {
  20153c:	54fff540 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201540:	394024a1 	ldrb	w1, [x5, #9]
    while (n-- > 0) {
  201544:	f100241f 	cmp	x0, #0x9
        *to++ = *from++;
  201548:	39002481 	strb	w1, [x4, #9]
    while (n-- > 0) {
  20154c:	54fff4c0 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201550:	394028a1 	ldrb	w1, [x5, #10]
    while (n-- > 0) {
  201554:	f100281f 	cmp	x0, #0xa
        *to++ = *from++;
  201558:	39002881 	strb	w1, [x4, #10]
    while (n-- > 0) {
  20155c:	54fff440 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201560:	39402ca1 	ldrb	w1, [x5, #11]
    while (n-- > 0) {
  201564:	f1002c1f 	cmp	x0, #0xb
        *to++ = *from++;
  201568:	39002c81 	strb	w1, [x4, #11]
    while (n-- > 0) {
  20156c:	54fff3c0 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201570:	394030a1 	ldrb	w1, [x5, #12]
    while (n-- > 0) {
  201574:	f100301f 	cmp	x0, #0xc
        *to++ = *from++;
  201578:	39003081 	strb	w1, [x4, #12]
    while (n-- > 0) {
  20157c:	54fff340 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201580:	394034a1 	ldrb	w1, [x5, #13]
    while (n-- > 0) {
  201584:	f100341f 	cmp	x0, #0xd
        *to++ = *from++;
  201588:	39003481 	strb	w1, [x4, #13]
    while (n-- > 0) {
  20158c:	54fff2c0 	b.eq	2013e4 <route+0x3f4>  // b.none
        *to++ = *from++;
  201590:	394038a0 	ldrb	w0, [x5, #14]
  201594:	39003880 	strb	w0, [x4, #14]
    return queue->active->tail - queue->active->head == queue->capacity;
  201598:	f9430261 	ldr	x1, [x19, #1536]
  20159c:	b9460a63 	ldr	w3, [x19, #1544]
  2015a0:	79400022 	ldrh	w2, [x1]
  2015a4:	79400420 	ldrh	w0, [x1, #2]
  2015a8:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  2015ac:	6b03001f 	cmp	w0, w3
  2015b0:	54fff281 	b.ne	201400 <route+0x410>  // b.any
                        assert(!err);
  2015b4:	f0000003 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  2015b8:	9109e063 	add	x3, x3, #0x278
  2015bc:	91006063 	add	x3, x3, #0x18
  2015c0:	52801de2 	mov	w2, #0xef                  	// #239
  2015c4:	f0000001 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  2015c8:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  2015cc:	910fc021 	add	x1, x1, #0x3f0
  2015d0:	91110000 	add	x0, x0, #0x440
  2015d4:	f90033e6 	str	x6, [sp, #96]
  2015d8:	94000b06 	bl	2041f0 <_assert_fail>
    return queue->free->tail - queue->free->head == queue->capacity;
  2015dc:	f9400281 	ldr	x1, [x20]
  2015e0:	b9401283 	ldr	w3, [x20, #16]
  2015e4:	f94033e6 	ldr	x6, [sp, #96]
  2015e8:	79400022 	ldrh	w2, [x1]
  2015ec:	79400420 	ldrh	w0, [x1, #2]
  2015f0:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  2015f4:	6b03001f 	cmp	w0, w3
  2015f8:	54fff241 	b.ne	201440 <route+0x450>  // b.any
                    assert(!err);
  2015fc:	f0000003 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  201600:	9109e063 	add	x3, x3, #0x278
  201604:	91006063 	add	x3, x3, #0x18
  201608:	f0000001 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  20160c:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  201610:	910fc021 	add	x1, x1, #0x3f0
  201614:	91110000 	add	x0, x0, #0x440
  201618:	52801e62 	mov	w2, #0xf3                  	// #243
  20161c:	94000af5 	bl	2041f0 <_assert_fail>
  201620:	17ffff8f 	b	20145c <route+0x46c>
  201624:	3941e3ea 	ldrb	w10, [sp, #120]
  201628:	3941e7e9 	ldrb	w9, [sp, #121]
  20162c:	3941ebe5 	ldrb	w5, [sp, #122]
  201630:	3941efe4 	ldrb	w4, [sp, #123]
  201634:	3941f3e3 	ldrb	w3, [sp, #124]
  201638:	3941f7e0 	ldrb	w0, [sp, #125]
  20163c:	17ffff37 	b	201318 <route+0x328>
    sddf_memcpy(&queue->request.queue[queue->request.tail % queue->capacity], &request, sizeof(arp_request_t));
  201640:	1ac30901 	udiv	w1, w8, w3
  201644:	d2800080 	mov	x0, #0x4                   	// #4
  201648:	5280018d 	mov	w13, #0xc                   	// #12
  20164c:	d3483d6c 	ubfx	x12, x11, #8, #8
  201650:	d3505d65 	ubfx	x5, x11, #16, #8
  201654:	53187d64 	lsr	w4, w11, #24
  201658:	5280002a 	mov	w10, #0x1                   	// #1
  20165c:	1b03a021 	msub	w1, w1, w3, w8
  201660:	9bad0021 	umaddl	x1, w1, w13, x0
  201664:	8b010040 	add	x0, x2, x1
  201668:	3821684b 	strb	w11, [x2, x1]
  20166c:	3900040c 	strb	w12, [x0, #1]
  201670:	39000805 	strb	w5, [x0, #2]
  201674:	39000c04 	strb	w4, [x0, #3]
  201678:	3900101f 	strb	wzr, [x0, #4]
  20167c:	3900141f 	strb	wzr, [x0, #5]
  201680:	3900181f 	strb	wzr, [x0, #6]
  201684:	39001c1f 	strb	wzr, [x0, #7]
  201688:	3900201f 	strb	wzr, [x0, #8]
  20168c:	3900241f 	strb	wzr, [x0, #9]
  201690:	3900280a 	strb	w10, [x0, #10]
  201694:	39002c1f 	strb	wzr, [x0, #11]
    return (info->empty_head == NULL);
  201698:	f9400e60 	ldr	x0, [x19, #24]
    queue->request.tail++;
  20169c:	79400041 	ldrh	w1, [x2]
  2016a0:	11000421 	add	w1, w1, #0x1
  2016a4:	79000041 	strh	w1, [x2]
    if (llfull(info)) {
  2016a8:	b4001360 	cbz	x0, 201914 <route+0x924>
    info->empty_head = LLNODE_PTRS_CAST(info->empty_head)->next;
  2016ac:	f9400001 	ldr	x1, [x0]
  2016b0:	f9000e61 	str	x1, [x19, #24]

static void llpush(struct ll_info *info, void *node)
{
    assert(info && node);

    LLNODE_PTRS_CAST(node)->next = info->head;
  2016b4:	f9401261 	ldr	x1, [x19, #32]
  2016b8:	f9000001 	str	x1, [x0]
                        waiting_packet->ip = nextIP;
  2016bc:	b900100b 	str	w11, [x0, #16]
                        waiting_packet->valid = true;
  2016c0:	3900500a 	strb	w10, [x0, #20]
                        waiting_packet->buffer = buffer;
  2016c4:	f9000c06 	str	x6, [x0, #24]
  2016c8:	79004007 	strh	w7, [x0, #32]
                        waiting_packet->filter = filter;
  2016cc:	79005018 	strh	w24, [x0, #40]
    if (info->head) {
  2016d0:	b4000041 	cbz	x1, 2016d8 <route+0x6e8>
        LLNODE_PTRS_CAST(info->head)->prev = node;
  2016d4:	f9000420 	str	x0, [x1, #8]
    }
    info->head = node;

    if (!info->tail) {
  2016d8:	f9401662 	ldr	x2, [x19, #40]
    info->head = node;
  2016dc:	f9001260 	str	x0, [x19, #32]
    if (!info->tail) {
  2016e0:	b40005c2 	cbz	x2, 201798 <route+0x7a8>
        info->tail = node;
    }
    info->curr_size++;
  2016e4:	b9403262 	ldr	w2, [x19, #48]
    if ((microkit_notifications & (1ULL << ch)) == 0) {
  2016e8:	b0000020 	adrp	x0, 206000 <state+0x178>
  2016ec:	f942b000 	ldr	x0, [x0, #1376]
  2016f0:	11000442 	add	w2, w2, #0x1
                        microkit_deferred_notify(router_config.router.id);
  2016f4:	3940e341 	ldrb	w1, [x26, #56]
  2016f8:	b9003262 	str	w2, [x19, #48]
  2016fc:	9ac12400 	lsr	x0, x0, x1
  201700:	360005e0 	tbz	w0, #0, 2017bc <route+0x7cc>
    return queue->active->tail - queue->active->head == 0;
  201704:	f9400684 	ldr	x4, [x20, #8]
    microkit_have_signal = seL4_True;
  201708:	b0000023 	adrp	x3, 206000 <state+0x178>
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  20170c:	11002820 	add	w0, w1, #0xa
  201710:	b0000025 	adrp	x5, 206000 <state+0x178>
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  201714:	b0000022 	adrp	x2, 206000 <state+0x178>
    microkit_have_signal = seL4_True;
  201718:	52800021 	mov	w1, #0x1                   	// #1
  20171c:	39150461 	strb	w1, [x3, #1345]
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  201720:	f902a8a0 	str	x0, [x5, #1360]
  201724:	79400089 	ldrh	w9, [x4]
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  201728:	f902a45f 	str	xzr, [x2, #1352]
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  20172c:	17fffeda 	b	201294 <route+0x2a4>
    for (int i = 0; i < NUM_ROUTES; i++) {
  201730:	d2800001 	mov	x1, #0x0                   	// #0
  201734:	d503201f 	nop
            return routing_table[i].next_hop;
  201738:	d2800183 	mov	x3, #0xc                   	// #12
  20173c:	9b034c21 	madd	x1, x1, x3, x19
  201740:	b946182b 	ldr	w11, [x1, #1560]
                        nextIP = destIP;
  201744:	7100017f 	cmp	w11, #0x0
  201748:	1a80116b 	csel	w11, w11, w0, ne	// ne = any
  20174c:	17fffe9d 	b	2011c0 <route+0x1d0>
    for (int i = 0; i < NUM_ROUTES; i++) {
  201750:	d2800021 	mov	x1, #0x1                   	// #1
  201754:	17fffff9 	b	201738 <route+0x748>
  201758:	d2800041 	mov	x1, #0x2                   	// #2
  20175c:	17fffff7 	b	201738 <route+0x748>
  201760:	d2800061 	mov	x1, #0x3                   	// #3
  201764:	17fffff5 	b	201738 <route+0x748>
  201768:	d2800081 	mov	x1, #0x4                   	// #4
  20176c:	17fffff3 	b	201738 <route+0x748>
  201770:	d28000a1 	mov	x1, #0x5                   	// #5
  201774:	17fffff1 	b	201738 <route+0x748>
  201778:	d28000c1 	mov	x1, #0x6                   	// #6
  20177c:	17ffffef 	b	201738 <route+0x748>
  201780:	d28000e1 	mov	x1, #0x7                   	// #7
  201784:	17ffffed 	b	201738 <route+0x748>
  201788:	d2800101 	mov	x1, #0x8                   	// #8
  20178c:	17ffffeb 	b	201738 <route+0x748>
  201790:	d2800121 	mov	x1, #0x9                   	// #9
  201794:	17ffffe9 	b	201738 <route+0x748>
  201798:	b9403262 	ldr	w2, [x19, #48]
        info->tail = node;
  20179c:	f9001660 	str	x0, [x19, #40]
    if ((microkit_notifications & (1ULL << ch)) == 0) {
  2017a0:	b0000020 	adrp	x0, 206000 <state+0x178>
  2017a4:	f942b000 	ldr	x0, [x0, #1376]
    info->curr_size++;
  2017a8:	11000442 	add	w2, w2, #0x1
                        microkit_deferred_notify(router_config.router.id);
  2017ac:	3940e341 	ldrb	w1, [x26, #56]
  2017b0:	b9003262 	str	w2, [x19, #48]
  2017b4:	9ac12400 	lsr	x0, x0, x1
  2017b8:	3707fa60 	tbnz	w0, #0, 201704 <route+0x714>
        microkit_dbg_puts(microkit_name);
  2017bc:	b0000020 	adrp	x0, 206000 <state+0x178>
  2017c0:	91140000 	add	x0, x0, #0x500
  2017c4:	b90063e1 	str	w1, [sp, #96]
  2017c8:	940002da 	bl	202330 <microkit_dbg_puts>
        microkit_dbg_puts(" microkit_deferred_notify: invalid channel given '");
  2017cc:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  2017d0:	91112000 	add	x0, x0, #0x448
  2017d4:	940002d7 	bl	202330 <microkit_dbg_puts>
        microkit_dbg_put8((seL4_Uint8)ch);
  2017d8:	b94063e1 	ldr	w1, [sp, #96]
  2017dc:	2a0103e0 	mov	w0, w1
  2017e0:	940002e4 	bl	202370 <microkit_dbg_put8>
        microkit_dbg_puts("'\n");
  2017e4:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  2017e8:	91120000 	add	x0, x0, #0x480
  2017ec:	940002d1 	bl	202330 <microkit_dbg_puts>
  2017f0:	f9400684 	ldr	x4, [x20, #8]
  2017f4:	79400089 	ldrh	w9, [x4]
  2017f8:	17fffea7 	b	201294 <route+0x2a4>
    queue->active->consumer_signalled = 1;
  2017fc:	52800021 	mov	w1, #0x1                   	// #1
  201800:	b9000401 	str	w1, [x0, #4]
    if ((microkit_notifications & (1ULL << ch)) == 0) {
  201804:	b0000020 	adrp	x0, 206000 <state+0x178>
  201808:	f942b000 	ldr	x0, [x0, #1376]
        microkit_deferred_notify(net_config.tx.id);
  20180c:	90000022 	adrp	x2, 205000 <__sel4_ipc_buffer>
  201810:	3941a853 	ldrb	w19, [x2, #106]
  201814:	9ad32400 	lsr	x0, x0, x19
  201818:	360005c0 	tbz	w0, #0, 2018d0 <route+0x8e0>
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  20181c:	b0000023 	adrp	x3, 206000 <state+0x178>
    microkit_have_signal = seL4_True;
  201820:	b0000024 	adrp	x4, 206000 <state+0x178>
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  201824:	b0000022 	adrp	x2, 206000 <state+0x178>
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  201828:	11002a60 	add	w0, w19, #0xa
    microkit_have_signal = seL4_True;
  20182c:	39150481 	strb	w1, [x4, #1345]
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  201830:	f902a860 	str	x0, [x3, #1360]
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  201834:	f902a45f 	str	xzr, [x2, #1352]
}
  201838:	a94153f3 	ldp	x19, x20, [sp, #16]
  20183c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  201840:	a94363f7 	ldp	x23, x24, [sp, #48]
  201844:	a9446bf9 	ldp	x25, x26, [sp, #64]
  201848:	a94573fb 	ldp	x27, x28, [sp, #80]
  20184c:	a8c87bfd 	ldp	x29, x30, [sp], #128
  201850:	d65f03c0 	ret
                        assert(!err);
  201854:	f0000003 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  201858:	9109e063 	add	x3, x3, #0x278
  20185c:	52801ca2 	mov	w2, #0xe5                  	// #229
  201860:	91006063 	add	x3, x3, #0x18
  201864:	f0000001 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  201868:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  20186c:	910fc021 	add	x1, x1, #0x3f0
  201870:	91110000 	add	x0, x0, #0x440
  201874:	f90033e6 	str	x6, [sp, #96]
  201878:	b9006fe7 	str	w7, [sp, #108]
  20187c:	94000a5d 	bl	2041f0 <_assert_fail>
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  201880:	f94033e6 	ldr	x6, [sp, #96]
  201884:	90000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
  201888:	f9403801 	ldr	x1, [x0, #112]
  20188c:	f9403aa2 	ldr	x2, [x21, #112]
  201890:	8b190021 	add	x1, x1, x25
  201894:	b9406fe7 	ldr	w7, [sp, #108]
  201898:	8b060042 	add	x2, x2, x6
    while (n-- > 0) {
  20189c:	17fffec5 	b	2013b0 <route+0x3c0>
                            assert(!err);
  2018a0:	f0000003 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  2018a4:	9109e063 	add	x3, x3, #0x278
  2018a8:	91006063 	add	x3, x3, #0x18
  2018ac:	f0000001 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  2018b0:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  2018b4:	910fc021 	add	x1, x1, #0x3f0
  2018b8:	91110000 	add	x0, x0, #0x440
  2018bc:	528019e2 	mov	w2, #0xcf                  	// #207
  2018c0:	94000a4c 	bl	2041f0 <_assert_fail>
    return queue->active->tail - queue->active->head == 0;
  2018c4:	f9400684 	ldr	x4, [x20, #8]
  2018c8:	79400089 	ldrh	w9, [x4]
  2018cc:	17fffe72 	b	201294 <route+0x2a4>
        microkit_dbg_puts(microkit_name);
  2018d0:	b0000020 	adrp	x0, 206000 <state+0x178>
  2018d4:	91140000 	add	x0, x0, #0x500
  2018d8:	94000296 	bl	202330 <microkit_dbg_puts>
        microkit_dbg_puts(" microkit_deferred_notify: invalid channel given '");
  2018dc:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  2018e0:	91112000 	add	x0, x0, #0x448
  2018e4:	94000293 	bl	202330 <microkit_dbg_puts>
        microkit_dbg_put8((seL4_Uint8)ch);
  2018e8:	2a1303e0 	mov	w0, w19
  2018ec:	940002a1 	bl	202370 <microkit_dbg_put8>
        microkit_dbg_puts("'\n");
  2018f0:	a94153f3 	ldp	x19, x20, [sp, #16]
  2018f4:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  2018f8:	91120000 	add	x0, x0, #0x480
  2018fc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  201900:	a94363f7 	ldp	x23, x24, [sp, #48]
}
  201904:	a9446bf9 	ldp	x25, x26, [sp, #64]
  201908:	a94573fb 	ldp	x27, x28, [sp, #80]
  20190c:	a8c87bfd 	ldp	x29, x30, [sp], #128
  201910:	14000288 	b	202330 <microkit_dbg_puts>
                        waiting_packet->ip = nextIP;
  201914:	b900101f 	str	wzr, [x0, #16]
  201918:	d4207d00 	brk	#0x3e8
  20191c:	d503201f 	nop

0000000000201920 <init>:

void init(void)
{
  201920:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  201924:	910003fd 	mov	x29, sp
  201928:	a9025bf5 	stp	x21, x22, [sp, #32]

static bool net_config_check_magic(void *config)
{
    char *magic = (char *)config;
    for (int i = 0; i < SDDF_NET_MAGIC_LEN; i++) {
        if (magic[i] != SDDF_NET_MAGIC[i]) {
  20192c:	90000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
  201930:	91002016 	add	x22, x0, #0x8
  201934:	39402000 	ldrb	w0, [x0, #8]
  201938:	a90153f3 	stp	x19, x20, [sp, #16]
  20193c:	7101cc1f 	cmp	w0, #0x73
  201940:	a90363f7 	stp	x23, x24, [sp, #48]
  201944:	f90023f9 	str	x25, [sp, #64]
  201948:	54003621 	b.ne	20200c <init+0x6ec>  // b.any
  20194c:	394006c0 	ldrb	w0, [x22, #1]
  201950:	7101101f 	cmp	w0, #0x44
  201954:	540035c1 	b.ne	20200c <init+0x6ec>  // b.any
  201958:	39400ac0 	ldrb	w0, [x22, #2]
  20195c:	7101101f 	cmp	w0, #0x44
  201960:	54003561 	b.ne	20200c <init+0x6ec>  // b.any
  201964:	39400ec0 	ldrb	w0, [x22, #3]
  201968:	7101181f 	cmp	w0, #0x46
  20196c:	54003501 	b.ne	20200c <init+0x6ec>  // b.any
  201970:	394012c0 	ldrb	w0, [x22, #4]
  201974:	7100141f 	cmp	w0, #0x5
  201978:	540034a1 	b.ne	20200c <init+0x6ec>  // b.any

static bool firewall_config_check_magic(void *config)
{
    char *magic = (char *)config;
    for (int i = 0; i < LIONS_FIREWALL_MAGIC_LEN; i++) {
        if (magic[i] != LIONS_FIREWALL_MAGIC[i]) {
  20197c:	90000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
  201980:	91026018 	add	x24, x0, #0x98
  201984:	39426000 	ldrb	w0, [x0, #152]
  201988:	7101301f 	cmp	w0, #0x4c
  20198c:	54003541 	b.ne	202034 <init+0x714>  // b.any
  201990:	39400700 	ldrb	w0, [x24, #1]
  201994:	7101a41f 	cmp	w0, #0x69
  201998:	540034e1 	b.ne	202034 <init+0x714>  // b.any
  20199c:	39400b00 	ldrb	w0, [x24, #2]
  2019a0:	7101bc1f 	cmp	w0, #0x6f
  2019a4:	54003481 	b.ne	202034 <init+0x714>  // b.any
  2019a8:	39400f00 	ldrb	w0, [x24, #3]
  2019ac:	7101b81f 	cmp	w0, #0x6e
  2019b0:	54003421 	b.ne	202034 <init+0x714>  // b.any
  2019b4:	39401300 	ldrb	w0, [x24, #4]
  2019b8:	7101cc1f 	cmp	w0, #0x73
  2019bc:	540033c1 	b.ne	202034 <init+0x714>  // b.any
  2019c0:	39401700 	ldrb	w0, [x24, #5]
  2019c4:	71013c1f 	cmp	w0, #0x4f
  2019c8:	54003361 	b.ne	202034 <init+0x714>  // b.any
  2019cc:	39401b00 	ldrb	w0, [x24, #6]
  2019d0:	71014c1f 	cmp	w0, #0x53
  2019d4:	54003301 	b.ne	202034 <init+0x714>  // b.any
  2019d8:	39401f00 	ldrb	w0, [x24, #7]
  2019dc:	71000c1f 	cmp	w0, #0x3
  2019e0:	540032a1 	b.ne	202034 <init+0x714>  // b.any
    // Init the hashtable here, as we are the first component that will
    // ever access it.
    assert(net_config_check_magic((void *)&net_config));
    assert(firewall_config_check_magic((void*) &router_config));
    arp_table = (hashtable_t*) router_config.router.arp_cache.vaddr;
  2019e4:	f9401701 	ldr	x1, [x24, #40]
  2019e8:	90000037 	adrp	x23, 205000 <__sel4_ipc_buffer>
  2019ec:	913942f5 	add	x21, x23, #0xe50
  2019f0:	d2860302 	mov	x2, #0x3018                	// #12312
  2019f4:	8b020020 	add	x0, x1, x2
  2019f8:	cb0003e0 	neg	x0, x0
  2019fc:	f90346a1 	str	x1, [x21, #1672]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a00:	f2400c03 	ands	x3, x0, #0xf
  201a04:	540033e0 	b.eq	202080 <init+0x760>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a08:	91400c24 	add	x4, x1, #0x3, lsl #12
  201a0c:	f27f081f 	tst	x0, #0xe
  201a10:	3900609f 	strb	wzr, [x4, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a14:	540032a0 	b.eq	202068 <init+0x748>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a18:	3900649f 	strb	wzr, [x4, #25]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a1c:	f100087f 	cmp	x3, #0x2
  201a20:	540032a9 	b.ls	202074 <init+0x754>  // b.plast
        table->used[i] = 0;  // Mark all slots as unused
  201a24:	3900689f 	strb	wzr, [x4, #26]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a28:	f27e041f 	tst	x0, #0xc
  201a2c:	54003360 	b.eq	202098 <init+0x778>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a30:	39006c9f 	strb	wzr, [x4, #27]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a34:	f100107f 	cmp	x3, #0x4
  201a38:	540032a9 	b.ls	20208c <init+0x76c>  // b.plast
        table->used[i] = 0;  // Mark all slots as unused
  201a3c:	3900709f 	strb	wzr, [x4, #28]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a40:	f100147f 	cmp	x3, #0x5
  201a44:	54003360 	b.eq	2020b0 <init+0x790>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a48:	3900749f 	strb	wzr, [x4, #29]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a4c:	f100187f 	cmp	x3, #0x6
  201a50:	540033c0 	b.eq	2020c8 <init+0x7a8>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a54:	3900789f 	strb	wzr, [x4, #30]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a58:	36183440 	tbz	w0, #3, 2020e0 <init+0x7c0>
        table->used[i] = 0;  // Mark all slots as unused
  201a5c:	39007c9f 	strb	wzr, [x4, #31]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a60:	f100207f 	cmp	x3, #0x8
  201a64:	54003389 	b.ls	2020d4 <init+0x7b4>  // b.plast
        table->used[i] = 0;  // Mark all slots as unused
  201a68:	3900809f 	strb	wzr, [x4, #32]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a6c:	f100247f 	cmp	x3, #0x9
  201a70:	54003260 	b.eq	2020bc <init+0x79c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a74:	3900849f 	strb	wzr, [x4, #33]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a78:	f100287f 	cmp	x3, #0xa
  201a7c:	54003140 	b.eq	2020a4 <init+0x784>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a80:	3900889f 	strb	wzr, [x4, #34]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a84:	f1002c7f 	cmp	x3, #0xb
  201a88:	54003320 	b.eq	2020ec <init+0x7cc>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a8c:	39008c9f 	strb	wzr, [x4, #35]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a90:	f100307f 	cmp	x3, #0xc
  201a94:	54003320 	b.eq	2020f8 <init+0x7d8>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a98:	3900909f 	strb	wzr, [x4, #36]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a9c:	f100347f 	cmp	x3, #0xd
  201aa0:	54003320 	b.eq	202104 <init+0x7e4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201aa4:	3900949f 	strb	wzr, [x4, #37]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201aa8:	f1003c7f 	cmp	x3, #0xf
  201aac:	54003321 	b.ne	202110 <init+0x7f0>  // b.any
  201ab0:	aa0303e5 	mov	x5, x3
  201ab4:	d2807e62 	mov	x2, #0x3f3                 	// #1011
        table->used[i] = 0;  // Mark all slots as unused
  201ab8:	3900989f 	strb	wzr, [x4, #38]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201abc:	d2808044 	mov	x4, #0x402                 	// #1026
  201ac0:	d2860300 	mov	x0, #0x3018                	// #12312
  201ac4:	cb030084 	sub	x4, x4, x3
  201ac8:	8b000060 	add	x0, x3, x0
  201acc:	8b000020 	add	x0, x1, x0
  201ad0:	927cec83 	and	x3, x4, #0xfffffffffffffff0
        table->used[i] = 0;  // Mark all slots as unused
  201ad4:	4f000400 	movi	v0.4s, #0x0
  201ad8:	8b000063 	add	x3, x3, x0
  201adc:	d503201f 	nop
  201ae0:	3c810400 	str	q0, [x0], #16
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201ae4:	eb03001f 	cmp	x0, x3
  201ae8:	54ffffc1 	b.ne	201ae0 <init+0x1c0>  // b.any
  201aec:	927cec83 	and	x3, x4, #0xfffffffffffffff0
  201af0:	f2400c9f 	tst	x4, #0xf
  201af4:	8b0300a0 	add	x0, x5, x3
  201af8:	cb030042 	sub	x2, x2, x3
  201afc:	54000b00 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201b00:	8b000023 	add	x3, x1, x0
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b04:	f100045f 	cmp	x2, #0x1
        table->used[i] = 0;  // Mark all slots as unused
  201b08:	91400c63 	add	x3, x3, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b0c:	91000404 	add	x4, x0, #0x1
        table->used[i] = 0;  // Mark all slots as unused
  201b10:	3900607f 	strb	wzr, [x3, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b14:	54000a40 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201b18:	8b040024 	add	x4, x1, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b1c:	f100085f 	cmp	x2, #0x2
        table->used[i] = 0;  // Mark all slots as unused
  201b20:	91400c84 	add	x4, x4, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b24:	91000803 	add	x3, x0, #0x2
        table->used[i] = 0;  // Mark all slots as unused
  201b28:	3900609f 	strb	wzr, [x4, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b2c:	54000980 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201b30:	8b030023 	add	x3, x1, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b34:	f1000c5f 	cmp	x2, #0x3
        table->used[i] = 0;  // Mark all slots as unused
  201b38:	91400c63 	add	x3, x3, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b3c:	91000c04 	add	x4, x0, #0x3
        table->used[i] = 0;  // Mark all slots as unused
  201b40:	3900607f 	strb	wzr, [x3, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b44:	540008c0 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201b48:	8b040024 	add	x4, x1, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b4c:	f100105f 	cmp	x2, #0x4
        table->used[i] = 0;  // Mark all slots as unused
  201b50:	91400c84 	add	x4, x4, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b54:	91001003 	add	x3, x0, #0x4
        table->used[i] = 0;  // Mark all slots as unused
  201b58:	3900609f 	strb	wzr, [x4, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b5c:	54000800 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201b60:	8b030023 	add	x3, x1, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b64:	f100145f 	cmp	x2, #0x5
        table->used[i] = 0;  // Mark all slots as unused
  201b68:	91400c63 	add	x3, x3, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b6c:	91001404 	add	x4, x0, #0x5
        table->used[i] = 0;  // Mark all slots as unused
  201b70:	3900607f 	strb	wzr, [x3, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b74:	54000740 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201b78:	8b040023 	add	x3, x1, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b7c:	f100185f 	cmp	x2, #0x6
        table->used[i] = 0;  // Mark all slots as unused
  201b80:	91400c63 	add	x3, x3, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b84:	91001804 	add	x4, x0, #0x6
        table->used[i] = 0;  // Mark all slots as unused
  201b88:	3900607f 	strb	wzr, [x3, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b8c:	54000680 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201b90:	8b040024 	add	x4, x1, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b94:	f1001c5f 	cmp	x2, #0x7
        table->used[i] = 0;  // Mark all slots as unused
  201b98:	91400c84 	add	x4, x4, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201b9c:	91001c03 	add	x3, x0, #0x7
        table->used[i] = 0;  // Mark all slots as unused
  201ba0:	3900609f 	strb	wzr, [x4, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201ba4:	540005c0 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201ba8:	8b030023 	add	x3, x1, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bac:	f100205f 	cmp	x2, #0x8
        table->used[i] = 0;  // Mark all slots as unused
  201bb0:	91400c63 	add	x3, x3, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bb4:	91002004 	add	x4, x0, #0x8
        table->used[i] = 0;  // Mark all slots as unused
  201bb8:	3900607f 	strb	wzr, [x3, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bbc:	54000500 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201bc0:	8b040024 	add	x4, x1, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bc4:	f100245f 	cmp	x2, #0x9
        table->used[i] = 0;  // Mark all slots as unused
  201bc8:	91400c84 	add	x4, x4, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bcc:	91002403 	add	x3, x0, #0x9
        table->used[i] = 0;  // Mark all slots as unused
  201bd0:	3900609f 	strb	wzr, [x4, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bd4:	54000440 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201bd8:	8b030023 	add	x3, x1, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bdc:	f100285f 	cmp	x2, #0xa
        table->used[i] = 0;  // Mark all slots as unused
  201be0:	91400c63 	add	x3, x3, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201be4:	91002804 	add	x4, x0, #0xa
        table->used[i] = 0;  // Mark all slots as unused
  201be8:	3900607f 	strb	wzr, [x3, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bec:	54000380 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201bf0:	8b040024 	add	x4, x1, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bf4:	f1002c5f 	cmp	x2, #0xb
        table->used[i] = 0;  // Mark all slots as unused
  201bf8:	91400c84 	add	x4, x4, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201bfc:	91002c03 	add	x3, x0, #0xb
        table->used[i] = 0;  // Mark all slots as unused
  201c00:	3900609f 	strb	wzr, [x4, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c04:	540002c0 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201c08:	8b030023 	add	x3, x1, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c0c:	f100305f 	cmp	x2, #0xc
        table->used[i] = 0;  // Mark all slots as unused
  201c10:	91400c63 	add	x3, x3, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c14:	91003004 	add	x4, x0, #0xc
        table->used[i] = 0;  // Mark all slots as unused
  201c18:	3900607f 	strb	wzr, [x3, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c1c:	54000200 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201c20:	8b040024 	add	x4, x1, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c24:	f100345f 	cmp	x2, #0xd
        table->used[i] = 0;  // Mark all slots as unused
  201c28:	91400c84 	add	x4, x4, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c2c:	91003403 	add	x3, x0, #0xd
        table->used[i] = 0;  // Mark all slots as unused
  201c30:	3900609f 	strb	wzr, [x4, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c34:	54000140 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201c38:	8b030023 	add	x3, x1, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c3c:	91003800 	add	x0, x0, #0xe
        table->used[i] = 0;  // Mark all slots as unused
  201c40:	91400c63 	add	x3, x3, #0x3, lsl #12
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c44:	f100385f 	cmp	x2, #0xe
        table->used[i] = 0;  // Mark all slots as unused
  201c48:	3900607f 	strb	wzr, [x3, #24]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201c4c:	54000080 	b.eq	201c5c <init+0x33c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201c50:	8b000020 	add	x0, x1, x0
  201c54:	91400c00 	add	x0, x0, #0x3, lsl #12
  201c58:	3900601f 	strb	wzr, [x0, #24]
    hashtable_init(arp_table);

    // Setup all the queues for the filters
    for (int i = 0; i < router_config.num_filters; i++) {
  201c5c:	795b4300 	ldrh	w0, [x24, #3488]
  201c60:	34000240 	cbz	w0, 201ca8 <init+0x388>
  201c64:	51000403 	sub	w3, w0, #0x1
  201c68:	9100e302 	add	x2, x24, #0x38
  201c6c:	52800704 	mov	w4, #0x38                  	// #56
  201c70:	aa1803e0 	mov	x0, x24
  201c74:	9100e2a1 	add	x1, x21, #0x38
  201c78:	9ba40863 	umaddl	x3, w3, w4, x2
  201c7c:	d503201f 	nop
    queue->free = free;
  201c80:	f9402402 	ldr	x2, [x0, #72]
  201c84:	f9000022 	str	x2, [x1]
        net_queue_init(&state.filter_queue[i], router_config.filters[i].conn.free_queue.vaddr,
            router_config.filters[i].conn.active_queue.vaddr, router_config.filters[i].conn.num_buffers);
  201c88:	f9402c02 	ldr	x2, [x0, #88]
    queue->active = active;
  201c8c:	f9000422 	str	x2, [x1, #8]
        net_queue_init(&state.filter_queue[i], router_config.filters[i].conn.free_queue.vaddr,
  201c90:	7940d002 	ldrh	w2, [x0, #104]
    for (int i = 0; i < router_config.num_filters; i++) {
  201c94:	9100e000 	add	x0, x0, #0x38
    queue->capacity = capacity;
  201c98:	b9001022 	str	w2, [x1, #16]
  201c9c:	eb00007f 	cmp	x3, x0
  201ca0:	91006021 	add	x1, x1, #0x18
  201ca4:	54fffee1 	b.ne	201c80 <init+0x360>  // b.any
    }
    net_queue_init(&virt_tx_queue, net_config.tx.free_queue.vaddr, net_config.tx.active_queue.vaddr,
  201ca8:	7940c2c3 	ldrh	w3, [x22, #96]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201cac:	52800014 	mov	w20, #0x0                   	// #0
  201cb0:	f94022c1 	ldr	x1, [x22, #64]
    queue->free = free;
  201cb4:	f902fea1 	str	x1, [x21, #1528]
  201cb8:	f9402ac2 	ldr	x2, [x22, #80]
    queue->active = active;
  201cbc:	f90302a2 	str	x2, [x21, #1536]
    queue->capacity = capacity;
  201cc0:	b9060aa3 	str	w3, [x21, #1544]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201cc4:	52800013 	mov	w19, #0x0                   	// #0
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201cc8:	d2800119 	mov	x25, #0x8                   	// #8
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201ccc:	34000463 	cbz	w3, 201d58 <init+0x438>
    return queue->free->tail - queue->free->head == queue->capacity;
  201cd0:	79400022 	ldrh	w2, [x1]
        net_buff_desc_t buffer = {(NET_BUFFER_SIZE * i) + base_addr, 0};
  201cd4:	2a1403e5 	mov	w5, w20
    return queue->free->tail - queue->free->head == queue->capacity;
  201cd8:	79400420 	ldrh	w0, [x1, #2]
    queue->free->tail++;
  201cdc:	11000444 	add	w4, w2, #0x1
    return queue->free->tail - queue->free->head == queue->capacity;
  201ce0:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  201ce4:	6b03001f 	cmp	w0, w3
  201ce8:	540001c0 	b.eq	201d20 <init+0x400>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201cec:	1ac30840 	udiv	w0, w2, w3
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201cf0:	11000673 	add	w19, w19, #0x1
  201cf4:	6b03027f 	cmp	w19, w3
  201cf8:	11200294 	add	w20, w20, #0x800
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201cfc:	1b038800 	msub	w0, w0, w3, w2
  201d00:	8b205320 	add	x0, x25, w0, uxtw #4
  201d04:	8b000022 	add	x2, x1, x0
  201d08:	f8206825 	str	x5, [x1, x0]
  201d0c:	7900105f 	strh	wzr, [x2, #8]
    queue->free->tail++;
  201d10:	79000024 	strh	w4, [x1]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201d14:	54000222 	b.cs	201d58 <init+0x438>  // b.hs, b.nlast
    return queue->free->tail - queue->free->head == queue->capacity;
  201d18:	f942fea1 	ldr	x1, [x21, #1528]
  201d1c:	17ffffed 	b	201cd0 <init+0x3b0>
        assert(!err);
  201d20:	f0000003 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  201d24:	9109e063 	add	x3, x3, #0x278
  201d28:	9100a063 	add	x3, x3, #0x28
  201d2c:	f0000001 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  201d30:	f0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  201d34:	91152021 	add	x1, x1, #0x548
  201d38:	91110000 	add	x0, x0, #0x440
  201d3c:	52801ba2 	mov	w2, #0xdd                  	// #221
  201d40:	9400092c 	bl	2041f0 <_assert_fail>
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201d44:	11000673 	add	w19, w19, #0x1
  201d48:	b9460aa3 	ldr	w3, [x21, #1544]
  201d4c:	11200294 	add	w20, w20, #0x800
  201d50:	6b03027f 	cmp	w19, w3
  201d54:	54fffe23 	b.cc	201d18 <init+0x3f8>  // b.lo, b.ul, b.last
        net_config.tx.num_buffers);
    net_buffers_init(&virt_tx_queue, 0);

    arp_queries = (arp_queue_handle_t *) router_config.router.arp_queue.vaddr;
  201d58:	f9400f04 	ldr	x4, [x24, #24]

    device_info = (dev_info_t *) net_config.dev_info.vaddr;

    // Init the waiting queue from a pool of memory
    pkt_waiting_queue.llnode_pool = (uint8_t *) router_config.packet_queue.vaddr;
    pkt_waiting_queue.pool_size = 10;
  201d5c:	f0000002 	adrp	x2, 204000 <sddf_sprintf_+0x70>
  201d60:	fd432840 	ldr	d0, [x2, #1616]
 * @param active pointer to active queue in shared memory.
 * @param capacity capacity of the free and active queues.
 */
static inline void arp_handle_init(arp_queue_handle_t *queue, uint32_t capacity)
{
    queue->capacity = capacity;
  201d64:	52802005 	mov	w5, #0x100                 	// #256
    pkt_waiting_queue.llnode_pool = (uint8_t *) router_config.packet_queue.vaddr;
  201d68:	f9400700 	ldr	x0, [x24, #8]
    arp_queries = (arp_queue_handle_t *) router_config.router.arp_queue.vaddr;
  201d6c:	f9072ae4 	str	x4, [x23, #3664]
    device_info = (dev_info_t *) net_config.dev_info.vaddr;
  201d70:	f94042c6 	ldr	x6, [x22, #128]
    pkt_waiting_queue.llnode_pool = (uint8_t *) router_config.packet_queue.vaddr;
  201d74:	f90006a0 	str	x0, [x21, #8]
    pkt_waiting_queue.node_size = sizeof(struct llnode_pkt_waiting);
    pkt_waiting_queue.empty_head = NULL;
    pkt_waiting_queue.head = NULL;
    pkt_waiting_queue.tail = NULL;
  201d78:	a9027ebf 	stp	xzr, xzr, [x21, #32]
  201d7c:	cb0003e3 	neg	x3, x0
  201d80:	f2400c62 	ands	x2, x3, #0xf
    device_info = (dev_info_t *) net_config.dev_info.vaddr;
  201d84:	f902faa6 	str	x6, [x21, #1520]
  201d88:	b9300885 	str	w5, [x4, #12296]
    pkt_waiting_queue.pool_size = 10;
  201d8c:	fd000aa0 	str	d0, [x21, #16]
    while (n-- > 0) {
  201d90:	54001660 	b.eq	20205c <init+0x73c>  // b.none
        *p++ = c;
  201d94:	3900001f 	strb	wzr, [x0]
  201d98:	91000404 	add	x4, x0, #0x1
  201d9c:	f27f087f 	tst	x3, #0xe
    while (n-- > 0) {
  201da0:	d2803be1 	mov	x1, #0x1df                 	// #479
  201da4:	54000880 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201da8:	3900041f 	strb	wzr, [x0, #1]
  201dac:	91000804 	add	x4, x0, #0x2
  201db0:	f100085f 	cmp	x2, #0x2
    while (n-- > 0) {
  201db4:	d2803bc1 	mov	x1, #0x1de                 	// #478
  201db8:	540007e9 	b.ls	201eb4 <init+0x594>  // b.plast
        *p++ = c;
  201dbc:	3900081f 	strb	wzr, [x0, #2]
  201dc0:	91000c04 	add	x4, x0, #0x3
  201dc4:	f27e047f 	tst	x3, #0xc
    while (n-- > 0) {
  201dc8:	d2803ba1 	mov	x1, #0x1dd                 	// #477
  201dcc:	54000740 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201dd0:	39000c1f 	strb	wzr, [x0, #3]
  201dd4:	91001004 	add	x4, x0, #0x4
  201dd8:	f100105f 	cmp	x2, #0x4
    while (n-- > 0) {
  201ddc:	d2803b81 	mov	x1, #0x1dc                 	// #476
  201de0:	540006a9 	b.ls	201eb4 <init+0x594>  // b.plast
        *p++ = c;
  201de4:	3900101f 	strb	wzr, [x0, #4]
  201de8:	91001404 	add	x4, x0, #0x5
  201dec:	f100145f 	cmp	x2, #0x5
    while (n-- > 0) {
  201df0:	d2803b61 	mov	x1, #0x1db                 	// #475
  201df4:	54000600 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201df8:	3900141f 	strb	wzr, [x0, #5]
  201dfc:	91001804 	add	x4, x0, #0x6
  201e00:	f100185f 	cmp	x2, #0x6
    while (n-- > 0) {
  201e04:	d2803b41 	mov	x1, #0x1da                 	// #474
  201e08:	54000560 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201e0c:	3900181f 	strb	wzr, [x0, #6]
  201e10:	91001c04 	add	x4, x0, #0x7
    while (n-- > 0) {
  201e14:	d2803b21 	mov	x1, #0x1d9                 	// #473
  201e18:	361804e3 	tbz	w3, #3, 201eb4 <init+0x594>
        *p++ = c;
  201e1c:	39001c1f 	strb	wzr, [x0, #7]
  201e20:	91002004 	add	x4, x0, #0x8
  201e24:	f100205f 	cmp	x2, #0x8
    while (n-- > 0) {
  201e28:	d2803b01 	mov	x1, #0x1d8                 	// #472
  201e2c:	54000449 	b.ls	201eb4 <init+0x594>  // b.plast
        *p++ = c;
  201e30:	3900201f 	strb	wzr, [x0, #8]
  201e34:	91002404 	add	x4, x0, #0x9
  201e38:	f100245f 	cmp	x2, #0x9
    while (n-- > 0) {
  201e3c:	d2803ae1 	mov	x1, #0x1d7                 	// #471
  201e40:	540003a0 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201e44:	3900241f 	strb	wzr, [x0, #9]
  201e48:	91002804 	add	x4, x0, #0xa
  201e4c:	f100285f 	cmp	x2, #0xa
    while (n-- > 0) {
  201e50:	d2803ac1 	mov	x1, #0x1d6                 	// #470
  201e54:	54000300 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201e58:	3900281f 	strb	wzr, [x0, #10]
  201e5c:	91002c04 	add	x4, x0, #0xb
  201e60:	f1002c5f 	cmp	x2, #0xb
    while (n-- > 0) {
  201e64:	d2803aa1 	mov	x1, #0x1d5                 	// #469
  201e68:	54000260 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201e6c:	39002c1f 	strb	wzr, [x0, #11]
  201e70:	91003004 	add	x4, x0, #0xc
  201e74:	f100305f 	cmp	x2, #0xc
    while (n-- > 0) {
  201e78:	d2803a81 	mov	x1, #0x1d4                 	// #468
  201e7c:	540001c0 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201e80:	3900301f 	strb	wzr, [x0, #12]
  201e84:	91003404 	add	x4, x0, #0xd
  201e88:	f100345f 	cmp	x2, #0xd
    while (n-- > 0) {
  201e8c:	d2803a61 	mov	x1, #0x1d3                 	// #467
  201e90:	54000120 	b.eq	201eb4 <init+0x594>  // b.none
        *p++ = c;
  201e94:	3900341f 	strb	wzr, [x0, #13]
  201e98:	91003804 	add	x4, x0, #0xe
  201e9c:	f1003c5f 	cmp	x2, #0xf
    while (n-- > 0) {
  201ea0:	d2803a41 	mov	x1, #0x1d2                 	// #466
  201ea4:	54000081 	b.ne	201eb4 <init+0x594>  // b.any
        *p++ = c;
  201ea8:	91003c04 	add	x4, x0, #0xf
    while (n-- > 0) {
  201eac:	d2803a21 	mov	x1, #0x1d1                 	// #465
        *p++ = c;
  201eb0:	3900381f 	strb	wzr, [x0, #14]
    while (n-- > 0) {
  201eb4:	d2803c03 	mov	x3, #0x1e0                 	// #480
  201eb8:	cb020063 	sub	x3, x3, x2
        *p++ = c;
  201ebc:	4f000400 	movi	v0.4s, #0x0
  201ec0:	8b020000 	add	x0, x0, x2
  201ec4:	927cec62 	and	x2, x3, #0xfffffffffffffff0
  201ec8:	8b000042 	add	x2, x2, x0
  201ecc:	d503201f 	nop
  201ed0:	3c810400 	str	q0, [x0], #16
    while (n-- > 0) {
  201ed4:	eb02001f 	cmp	x0, x2
  201ed8:	54ffffc1 	b.ne	201ed0 <init+0x5b0>  // b.any
  201edc:	927cec62 	and	x2, x3, #0xfffffffffffffff0
  201ee0:	f2400c7f 	tst	x3, #0xf
  201ee4:	cb020020 	sub	x0, x1, x2
  201ee8:	8b020081 	add	x1, x4, x2
  201eec:	54000580 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201ef0:	3822689f 	strb	wzr, [x4, x2]
    while (n-- > 0) {
  201ef4:	f100041f 	cmp	x0, #0x1
  201ef8:	54000520 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201efc:	3900043f 	strb	wzr, [x1, #1]
    while (n-- > 0) {
  201f00:	f100081f 	cmp	x0, #0x2
  201f04:	540004c0 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f08:	3900083f 	strb	wzr, [x1, #2]
    while (n-- > 0) {
  201f0c:	f1000c1f 	cmp	x0, #0x3
  201f10:	54000460 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f14:	39000c3f 	strb	wzr, [x1, #3]
    while (n-- > 0) {
  201f18:	f100101f 	cmp	x0, #0x4
  201f1c:	54000400 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f20:	3900103f 	strb	wzr, [x1, #4]
    while (n-- > 0) {
  201f24:	f100141f 	cmp	x0, #0x5
  201f28:	540003a0 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f2c:	3900143f 	strb	wzr, [x1, #5]
    while (n-- > 0) {
  201f30:	f100181f 	cmp	x0, #0x6
  201f34:	54000340 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f38:	3900183f 	strb	wzr, [x1, #6]
    while (n-- > 0) {
  201f3c:	f1001c1f 	cmp	x0, #0x7
  201f40:	540002e0 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f44:	39001c3f 	strb	wzr, [x1, #7]
    while (n-- > 0) {
  201f48:	f100201f 	cmp	x0, #0x8
  201f4c:	54000280 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f50:	3900203f 	strb	wzr, [x1, #8]
    while (n-- > 0) {
  201f54:	f100241f 	cmp	x0, #0x9
  201f58:	54000220 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f5c:	3900243f 	strb	wzr, [x1, #9]
    while (n-- > 0) {
  201f60:	f100281f 	cmp	x0, #0xa
  201f64:	540001c0 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f68:	3900283f 	strb	wzr, [x1, #10]
    while (n-- > 0) {
  201f6c:	f1002c1f 	cmp	x0, #0xb
  201f70:	54000160 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f74:	39002c3f 	strb	wzr, [x1, #11]
    while (n-- > 0) {
  201f78:	f100301f 	cmp	x0, #0xc
  201f7c:	54000100 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f80:	3900303f 	strb	wzr, [x1, #12]
    while (n-- > 0) {
  201f84:	f100341f 	cmp	x0, #0xd
  201f88:	540000a0 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f8c:	3900343f 	strb	wzr, [x1, #13]
    while (n-- > 0) {
  201f90:	f100381f 	cmp	x0, #0xe
  201f94:	54000040 	b.eq	201f9c <init+0x67c>  // b.none
        *p++ = c;
  201f98:	3900383f 	strb	wzr, [x1, #14]
    info->empty_head = info->llnode_pool;
  201f9c:	f94006a6 	ldr	x6, [x21, #8]
  201fa0:	f9000ea6 	str	x6, [x21, #24]
    for (size_t i = 1; i < info->pool_size; i++) {
  201fa4:	b94012a3 	ldr	w3, [x21, #16]
    curr->prev = NULL;
  201fa8:	f90004df 	str	xzr, [x6, #8]
    for (size_t i = 1; i < info->pool_size; i++) {
  201fac:	7100047f 	cmp	w3, #0x1
  201fb0:	2a0303e3 	mov	w3, w3
  201fb4:	540001c9 	b.ls	201fec <init+0x6cc>  // b.plast
        curr->next = &info->llnode_pool[i * info->node_size];
  201fb8:	b94016a4 	ldr	w4, [x21, #20]
  201fbc:	aa0603e0 	mov	x0, x6
    for (size_t i = 1; i < info->pool_size; i++) {
  201fc0:	d2800021 	mov	x1, #0x1                   	// #1
  201fc4:	d503201f 	nop
        curr->next = &info->llnode_pool[i * info->node_size];
  201fc8:	aa0003e2 	mov	x2, x0
  201fcc:	8b040000 	add	x0, x0, x4
  201fd0:	aa0103e5 	mov	x5, x1
    for (size_t i = 1; i < info->pool_size; i++) {
  201fd4:	91000421 	add	x1, x1, #0x1
  201fd8:	eb01007f 	cmp	x3, x1
        curr->next = &info->llnode_pool[i * info->node_size];
  201fdc:	f9000040 	str	x0, [x2]
        LLNODE_PTRS_CAST(curr->next)->prev = curr;
  201fe0:	f9000402 	str	x2, [x0, #8]
    for (size_t i = 1; i < info->pool_size; i++) {
  201fe4:	54ffff21 	b.ne	201fc8 <init+0x6a8>  // b.any
        curr->next = &info->llnode_pool[i * info->node_size];
  201fe8:	9b051886 	madd	x6, x4, x5, x6

    llinit(&pkt_waiting_queue);
    // routing_table[0].network_id = 0;
    // routing_table[0].subnet_mask = 0xFFFFFF00;
    // routing_table[0].next_hop = 0;
}
  201fec:	a94153f3 	ldp	x19, x20, [sp, #16]
  201ff0:	a94363f7 	ldp	x23, x24, [sp, #48]
  201ff4:	f94023f9 	ldr	x25, [sp, #64]
    curr->next = NULL;
  201ff8:	f90000df 	str	xzr, [x6]
    info->curr_size = 0;
  201ffc:	b90032bf 	str	wzr, [x21, #48]
  202000:	a9425bf5 	ldp	x21, x22, [sp, #32]
  202004:	a8c57bfd 	ldp	x29, x30, [sp], #80
  202008:	d65f03c0 	ret
    assert(net_config_check_magic((void *)&net_config));
  20200c:	d0000003 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  202010:	9109e063 	add	x3, x3, #0x278
  202014:	91008063 	add	x3, x3, #0x20
  202018:	d0000001 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  20201c:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202020:	910fc021 	add	x1, x1, #0x3f0
  202024:	91138000 	add	x0, x0, #0x4e0
  202028:	528021a2 	mov	w2, #0x10d                 	// #269
  20202c:	94000871 	bl	2041f0 <_assert_fail>
  202030:	17fffe53 	b	20197c <init+0x5c>
    assert(firewall_config_check_magic((void*) &router_config));
  202034:	d0000003 	adrp	x3, 204000 <sddf_sprintf_+0x70>
  202038:	9109e063 	add	x3, x3, #0x278
  20203c:	91008063 	add	x3, x3, #0x20
  202040:	d0000001 	adrp	x1, 204000 <sddf_sprintf_+0x70>
  202044:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202048:	910fc021 	add	x1, x1, #0x3f0
  20204c:	91144000 	add	x0, x0, #0x510
  202050:	528021c2 	mov	w2, #0x10e                 	// #270
  202054:	94000867 	bl	2041f0 <_assert_fail>
  202058:	17fffe63 	b	2019e4 <init+0xc4>
    unsigned char *p = s;
  20205c:	aa0003e4 	mov	x4, x0
    pkt_waiting_queue.tail = NULL;
  202060:	d2803c01 	mov	x1, #0x1e0                 	// #480
  202064:	17ffff94 	b	201eb4 <init+0x594>
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  202068:	d2808022 	mov	x2, #0x401                 	// #1025
  20206c:	d2800025 	mov	x5, #0x1                   	// #1
  202070:	17fffe93 	b	201abc <init+0x19c>
  202074:	d2808002 	mov	x2, #0x400                 	// #1024
  202078:	d2800045 	mov	x5, #0x2                   	// #2
  20207c:	17fffe90 	b	201abc <init+0x19c>
  202080:	d2800005 	mov	x5, #0x0                   	// #0
    arp_table = (hashtable_t*) router_config.router.arp_cache.vaddr;
  202084:	d2808042 	mov	x2, #0x402                 	// #1026
  202088:	17fffe8d 	b	201abc <init+0x19c>
  20208c:	d2807fc2 	mov	x2, #0x3fe                 	// #1022
  202090:	d2800085 	mov	x5, #0x4                   	// #4
  202094:	17fffe8a 	b	201abc <init+0x19c>
  202098:	d2807fe2 	mov	x2, #0x3ff                 	// #1023
  20209c:	d2800065 	mov	x5, #0x3                   	// #3
  2020a0:	17fffe87 	b	201abc <init+0x19c>
  2020a4:	aa0303e5 	mov	x5, x3
  2020a8:	d2807f02 	mov	x2, #0x3f8                 	// #1016
  2020ac:	17fffe84 	b	201abc <init+0x19c>
  2020b0:	aa0303e5 	mov	x5, x3
  2020b4:	d2807fa2 	mov	x2, #0x3fd                 	// #1021
  2020b8:	17fffe81 	b	201abc <init+0x19c>
  2020bc:	d2800125 	mov	x5, #0x9                   	// #9
  2020c0:	d2807f22 	mov	x2, #0x3f9                 	// #1017
  2020c4:	17fffe7e 	b	201abc <init+0x19c>
  2020c8:	aa0303e5 	mov	x5, x3
  2020cc:	d2807f82 	mov	x2, #0x3fc                 	// #1020
  2020d0:	17fffe7b 	b	201abc <init+0x19c>
  2020d4:	d2807f42 	mov	x2, #0x3fa                 	// #1018
  2020d8:	d2800105 	mov	x5, #0x8                   	// #8
  2020dc:	17fffe78 	b	201abc <init+0x19c>
  2020e0:	d2807f62 	mov	x2, #0x3fb                 	// #1019
  2020e4:	d28000e5 	mov	x5, #0x7                   	// #7
  2020e8:	17fffe75 	b	201abc <init+0x19c>
  2020ec:	aa0303e5 	mov	x5, x3
  2020f0:	d2807ee2 	mov	x2, #0x3f7                 	// #1015
  2020f4:	17fffe72 	b	201abc <init+0x19c>
  2020f8:	aa0303e5 	mov	x5, x3
  2020fc:	d2807ec2 	mov	x2, #0x3f6                 	// #1014
  202100:	17fffe6f 	b	201abc <init+0x19c>
  202104:	aa0303e5 	mov	x5, x3
  202108:	d2807ea2 	mov	x2, #0x3f5                 	// #1013
  20210c:	17fffe6c 	b	201abc <init+0x19c>
  202110:	d2807e82 	mov	x2, #0x3f4                 	// #1012
  202114:	d28001c5 	mov	x5, #0xe                   	// #14
  202118:	17fffe69 	b	201abc <init+0x19c>
  20211c:	d503201f 	nop

0000000000202120 <notified>:

void notified(microkit_channel ch)
{
    // Popualate with the rx ch number
    if (ch == router_config.router.id) {
  202120:	f0000001 	adrp	x1, 205000 <__sel4_ipc_buffer>
  202124:	39434021 	ldrb	w1, [x1, #208]
  202128:	6b00003f 	cmp	w1, w0
  20212c:	54000040 	b.eq	202134 <notified+0x14>  // b.none
        /* This is the channel between the ARP component and the routing component. */
        process_arp_waiting();
    } else {
        route();
  202130:	17fffbb0 	b	200ff0 <route>
        process_arp_waiting();
  202134:	17fff97f 	b	200730 <process_arp_waiting>
	...

0000000000202140 <protected>:

extern const void (*const __init_array_start [])(void);
extern const void (*const __init_array_end [])(void);

__attribute__((weak)) microkit_msginfo protected(microkit_channel ch, microkit_msginfo msginfo)
{
  202140:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    microkit_dbg_puts(microkit_name);
  202144:	90000020 	adrp	x0, 206000 <state+0x178>
  202148:	91140000 	add	x0, x0, #0x500
{
  20214c:	910003fd 	mov	x29, sp
    microkit_dbg_puts(microkit_name);
  202150:	94000078 	bl	202330 <microkit_dbg_puts>
    microkit_dbg_puts(" is missing the 'protected' entry point\n");
  202154:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202158:	91166000 	add	x0, x0, #0x598
  20215c:	94000075 	bl	202330 <microkit_dbg_puts>
     * Actually derference 'err' which means the crash reporting will have
     * `err` as the fault address. A bit of a cute hack. Not a good long term
     * solution but good for now.
     */
    int *x = (int *)(seL4_Word) err;
    *x = 0;
  202160:	d2800000 	mov	x0, #0x0                   	// #0
  202164:	b900001f 	str	wzr, [x0]
  202168:	d4207d00 	brk	#0x3e8
  20216c:	d503201f 	nop

0000000000202170 <fault>:
    microkit_internal_crash(0);
    return seL4_MessageInfo_new(0, 0, 0, 0);
}

__attribute__((weak)) seL4_Bool fault(microkit_child child, microkit_msginfo msginfo, microkit_msginfo *reply_msginfo)
{
  202170:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
    microkit_dbg_puts(microkit_name);
  202174:	90000020 	adrp	x0, 206000 <state+0x178>
  202178:	91140000 	add	x0, x0, #0x500
{
  20217c:	910003fd 	mov	x29, sp
    microkit_dbg_puts(microkit_name);
  202180:	9400006c 	bl	202330 <microkit_dbg_puts>
    microkit_dbg_puts(" is missing the 'fault' entry point\n");
  202184:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202188:	91172000 	add	x0, x0, #0x5c8
  20218c:	94000069 	bl	202330 <microkit_dbg_puts>
  202190:	d2800000 	mov	x0, #0x0                   	// #0
  202194:	b900001f 	str	wzr, [x0]
  202198:	d4207d00 	brk	#0x3e8
  20219c:	00000000 	udf	#0

00000000002021a0 <main>:
        }
    }
}

void main(void)
{
  2021a0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
    size_t count = __init_array_end - __init_array_start;
  2021a4:	f0000000 	adrp	x0, 205000 <__sel4_ipc_buffer>
  2021a8:	91000000 	add	x0, x0, #0x0
{
  2021ac:	910003fd 	mov	x29, sp
  2021b0:	a90153f3 	stp	x19, x20, [sp, #16]
    size_t count = __init_array_end - __init_array_start;
  2021b4:	f0000014 	adrp	x20, 205000 <__sel4_ipc_buffer>
  2021b8:	91000294 	add	x20, x20, #0x0
{
  2021bc:	a9025bf5 	stp	x21, x22, [sp, #32]
    for (size_t i = 0; i < count; i++) {
  2021c0:	eb140015 	subs	x21, x0, x20
  2021c4:	54000100 	b.eq	2021e4 <main+0x44>  // b.none
  2021c8:	9343feb5 	asr	x21, x21, #3
  2021cc:	d2800013 	mov	x19, #0x0                   	// #0
        __init_array_start[i]();
  2021d0:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
    for (size_t i = 0; i < count; i++) {
  2021d4:	91000673 	add	x19, x19, #0x1
        __init_array_start[i]();
  2021d8:	d63f0000 	blr	x0
    for (size_t i = 0; i < count; i++) {
  2021dc:	eb1302bf 	cmp	x21, x19
  2021e0:	54ffff88 	b.hi	2021d0 <main+0x30>  // b.pmore
     * If we are passive, now our initialisation is complete we can
     * signal the monitor to unbind our scheduling context and bind
     * it to our notification object.
     * We delay this signal so we are ready waiting on a recv() syscall
     */
    if (microkit_passive) {
  2021e4:	90000036 	adrp	x22, 206000 <state+0x178>
  2021e8:	911402d6 	add	x22, x22, #0x500
    init();
  2021ec:	97fffdcd 	bl	201920 <init>
    if (microkit_passive) {
  2021f0:	394102c0 	ldrb	w0, [x22, #64]
  2021f4:	340000a0 	cbz	w0, 202208 <main+0x68>
        microkit_have_signal = seL4_True;
  2021f8:	52800021 	mov	w1, #0x1                   	// #1
        microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
        microkit_signal_cap = MONITOR_EP;
  2021fc:	d28000a0 	mov	x0, #0x5                   	// #5
        microkit_have_signal = seL4_True;
  202200:	390106c1 	strb	w1, [x22, #65]
        microkit_signal_cap = MONITOR_EP;
  202204:	a90482df 	stp	xzr, x0, [x22, #72]
  202208:	f0000015 	adrp	x21, 205000 <__sel4_ipc_buffer>
  20220c:	910002b5 	add	x21, x21, #0x0
    for (size_t i = 0; i < count; i++) {
  202210:	52800000 	mov	w0, #0x0                   	// #0
  202214:	d503201f 	nop
        if (have_reply) {
  202218:	35000220 	cbnz	w0, 20225c <main+0xbc>
        } else if (microkit_have_signal) {
  20221c:	39c106c0 	ldrsb	w0, [x22, #65]
  202220:	350004e0 	cbnz	w0, 2022bc <main+0x11c>
}

static inline void arm_sys_recv(seL4_Word sys, seL4_Word src, seL4_Word *out_badge, seL4_Word *out_info,
                                seL4_Word *out_mr0, seL4_Word *out_mr1, seL4_Word *out_mr2, seL4_Word *out_mr3, LIBSEL4_UNUSED seL4_Word reply)
{
    register seL4_Word src_and_badge asm("x0") = src;
  202224:	d2800020 	mov	x0, #0x1                   	// #1
    /* Incoming message registers. */
    register seL4_Word msg0 asm("x2");
    register seL4_Word msg1 asm("x3");
    register seL4_Word msg2 asm("x4");
    register seL4_Word msg3 asm("x5");
    MCS_PARAM_DECL("x6");
  202228:	d2800086 	mov	x6, #0x4                   	// #4

    /* Perform the system call. */
    register seL4_Word scno asm("x7") = sys;
  20222c:	928000c7 	mov	x7, #0xfffffffffffffff9    	// #-7
    asm volatile(
  202230:	d4000001 	svc	#0x0
    return;
}

LIBSEL4_INLINE_FUNC seL4_IPCBuffer *seL4_GetIPCBuffer(void)
{
    return __sel4_ipc_buffer;
  202234:	f94002a6 	ldr	x6, [x21]
        : "=r"(msg0), "=r"(msg1), "=r"(msg2), "=r"(msg3),
        "=r"(info), "+r"(src_and_badge)
        : "r"(scno) MCS_PARAM
        : "memory"
    );
    *out_badge = src_and_badge;
  202238:	aa0003f3 	mov	x19, x0
    return seL4_GetIPCBuffer()->msg[i];
}

LIBSEL4_INLINE_FUNC void seL4_SetMR(int i, seL4_Word mr)
{
    seL4_GetIPCBuffer()->msg[i] = mr;
  20223c:	a9008cc2 	stp	x2, x3, [x6, #8]
  202240:	a90194c4 	stp	x4, x5, [x6, #24]
        if (is_fault) {
  202244:	b7f00313 	tbnz	x19, #62, 2022a4 <main+0x104>
            unsigned int idx = 0;
  202248:	52800014 	mov	w20, #0x0                   	// #0
        } else if (is_endpoint) {
  20224c:	b6f801b3 	tbz	x19, #63, 202280 <main+0xe0>
            reply_tag = protected(badge & CHANNEL_MASK, tag);
  202250:	12001660 	and	w0, w19, #0x3f
  202254:	97ffffbb 	bl	202140 <protected>
  202258:	f9001fe0 	str	x0, [sp, #56]
    return __sel4_ipc_buffer;
  20225c:	f94002a5 	ldr	x5, [x21]

static inline void arm_sys_send_recv(seL4_Word sys, seL4_Word dest, seL4_Word *out_badge, seL4_Word info_arg,
                                     seL4_Word *out_info, seL4_Word *in_out_mr0, seL4_Word *in_out_mr1, seL4_Word *in_out_mr2, seL4_Word *in_out_mr3,
                                     LIBSEL4_UNUSED seL4_Word reply)
{
    register seL4_Word destptr asm("x0") = dest;
  202260:	d2800020 	mov	x0, #0x1                   	// #1
    register seL4_Word info asm("x1") = info_arg;
  202264:	f9401fe1 	ldr	x1, [sp, #56]
    /* Load beginning of the message into registers. */
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
    MCS_PARAM_DECL("x6");
  202268:	d2800086 	mov	x6, #0x4                   	// #4
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  20226c:	a9408ca2 	ldp	x2, x3, [x5, #8]

    /* Perform the system call. */
    register seL4_Word scno asm("x7") = sys;
  202270:	92800027 	mov	x7, #0xfffffffffffffffe    	// #-2
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  202274:	a94194a4 	ldp	x4, x5, [x5, #24]
    asm volatile(
  202278:	d4000001 	svc	#0x0
        : "+r"(msg0), "+r"(msg1), "+r"(msg2), "+r"(msg3),
        "+r"(info), "+r"(destptr)
        : "r"(scno) MCS_PARAM
        : "memory"
    );
    *out_info = info;
  20227c:	17ffffee 	b	202234 <main+0x94>
                if (badge & 1) {
  202280:	370000d3 	tbnz	w19, #0, 202298 <main+0xf8>
  202284:	d503201f 	nop
                badge >>= 1;
  202288:	d341fe73 	lsr	x19, x19, #1
                idx++;
  20228c:	11000694 	add	w20, w20, #0x1
            } while (badge != 0);
  202290:	b4fffc73 	cbz	x19, 20221c <main+0x7c>
                if (badge & 1) {
  202294:	3607ffb3 	tbz	w19, #0, 202288 <main+0xe8>
                    notified(idx);
  202298:	2a1403e0 	mov	w0, w20
  20229c:	97ffffa1 	bl	202120 <notified>
  2022a0:	17fffffa 	b	202288 <main+0xe8>
            seL4_Bool reply_to_fault = fault(badge & PD_MASK, tag, &reply_tag);
  2022a4:	12001e60 	and	w0, w19, #0xff
  2022a8:	9100e3e2 	add	x2, sp, #0x38
  2022ac:	97ffffb1 	bl	202170 <fault>
            if (reply_to_fault) {
  2022b0:	72001c1f 	tst	w0, #0xff
  2022b4:	1a9f07e0 	cset	w0, ne	// ne = any
  2022b8:	17ffffd8 	b	202218 <main+0x78>
  2022bc:	f94002a5 	ldr	x5, [x21]
static inline void arm_sys_nbsend_recv(seL4_Word sys, seL4_Word dest, seL4_Word src, seL4_Word *out_badge,
                                       seL4_Word info_arg,
                                       seL4_Word *out_info, seL4_Word *in_out_mr0, seL4_Word *in_out_mr1, seL4_Word *in_out_mr2,
                                       seL4_Word *in_out_mr3, seL4_Word reply)
{
    register seL4_Word src_and_badge asm("x0") = src;
  2022c0:	d2800020 	mov	x0, #0x1                   	// #1
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
    register seL4_Word msg3 asm("x5") = *in_out_mr3;

    register seL4_Word reply_reg asm("x6") = reply;
    register seL4_Word dest_reg asm("x8") = dest;
  2022c4:	a944a2c1 	ldp	x1, x8, [x22, #72]
    register seL4_Word reply_reg asm("x6") = reply;
  2022c8:	d2800086 	mov	x6, #0x4                   	// #4
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  2022cc:	a9408ca2 	ldp	x2, x3, [x5, #8]

    /* Perform the system call. */
    register seL4_Word scno asm("x7") = sys;
  2022d0:	92800047 	mov	x7, #0xfffffffffffffffd    	// #-3
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  2022d4:	a94194a4 	ldp	x4, x5, [x5, #24]
    asm volatile(
  2022d8:	d4000001 	svc	#0x0
  2022dc:	f94002a6 	ldr	x6, [x21]
        "+r"(src_and_badge), "+r"(info)
        : "r"(scno), "r"(reply_reg), "r"(dest_reg)
        : "memory"
    );

    *out_badge = src_and_badge;
  2022e0:	aa0003f3 	mov	x19, x0
            microkit_have_signal = seL4_False;
  2022e4:	390106df 	strb	wzr, [x22, #65]
    seL4_GetIPCBuffer()->msg[i] = mr;
  2022e8:	a9008cc2 	stp	x2, x3, [x6, #8]
  2022ec:	a90194c4 	stp	x4, x5, [x6, #24]
  2022f0:	17ffffd5 	b	202244 <main+0xa4>
	...

0000000000202300 <microkit_dbg_putc>:
    register seL4_Word info asm("x1") = info_arg;
  202300:	d2800001 	mov	x1, #0x0                   	// #0
    seL4_Word unused2 = 0;
    seL4_Word unused3 = 0;
    seL4_Word unused4 = 0;
    seL4_Word unused5 = 0;

    arm_sys_send_recv(seL4_SysDebugPutChar, c, &unused0, 0, &unused1, &unused2, &unused3, &unused4, &unused5, 0);
  202304:	92401c00 	and	x0, x0, #0xff
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  202308:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  20230c:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  202310:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  202314:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  202318:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  20231c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  202320:	d4000001 	svc	#0x0
void microkit_dbg_putc(int c)
{
#if defined(CONFIG_PRINTING)
    seL4_DebugPutChar(c);
#endif
}
  202324:	d65f03c0 	ret
  202328:	d503201f 	nop
  20232c:	d503201f 	nop

0000000000202330 <microkit_dbg_puts>:



void microkit_dbg_puts(const char *s)
{
  202330:	aa0003e8 	mov	x8, x0
    while (*s) {
  202334:	39400000 	ldrb	w0, [x0]
  202338:	34000180 	cbz	w0, 202368 <microkit_dbg_puts+0x38>
  20233c:	d503201f 	nop
    register seL4_Word info asm("x1") = info_arg;
  202340:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  202344:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  202348:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  20234c:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  202350:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  202354:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  202358:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  20235c:	d4000001 	svc	#0x0
  202360:	38401d00 	ldrb	w0, [x8, #1]!
  202364:	35fffee0 	cbnz	w0, 202340 <microkit_dbg_puts+0x10>
        microkit_dbg_putc(*s);
        s++;
    }
}
  202368:	d65f03c0 	ret
  20236c:	d503201f 	nop

0000000000202370 <microkit_dbg_put8>:

void microkit_dbg_put8(seL4_Uint8 x)
{
  202370:	12001c05 	and	w5, w0, #0xff
    char tmp[4];
    unsigned i = 3;
    tmp[3] = 0;
    do {
        seL4_Uint8 c = x % 10;
  202374:	529999a2 	mov	w2, #0xcccd                	// #52429
  202378:	72b99982 	movk	w2, #0xcccc, lsl #16
  20237c:	52800143 	mov	w3, #0xa                   	// #10
{
  202380:	d10043ff 	sub	sp, sp, #0x10
        tmp[--i] = '0' + c;
        x /= 10;
    } while (x);
  202384:	710024bf 	cmp	w5, #0x9
        seL4_Uint8 c = x % 10;
  202388:	9ba27ca1 	umull	x1, w5, w2
        tmp[--i] = '0' + c;
  20238c:	d2800044 	mov	x4, #0x2                   	// #2
    tmp[3] = 0;
  202390:	39002fff 	strb	wzr, [sp, #11]
        seL4_Uint8 c = x % 10;
  202394:	d363fc21 	lsr	x1, x1, #35
  202398:	1b039420 	msub	w0, w1, w3, w5
        tmp[--i] = '0' + c;
  20239c:	1100c000 	add	w0, w0, #0x30
  2023a0:	92401c00 	and	x0, x0, #0xff
  2023a4:	39002be0 	strb	w0, [sp, #10]
    } while (x);
  2023a8:	540001c9 	b.ls	2023e0 <microkit_dbg_put8+0x70>  // b.plast
        x /= 10;
  2023ac:	12001c21 	and	w1, w1, #0xff
    } while (x);
  2023b0:	71018cbf 	cmp	w5, #0x63
        tmp[--i] = '0' + c;
  2023b4:	d2800024 	mov	x4, #0x1                   	// #1
        seL4_Uint8 c = x % 10;
  2023b8:	9ba27c22 	umull	x2, w1, w2
  2023bc:	d363fc42 	lsr	x2, x2, #35
  2023c0:	1b038443 	msub	w3, w2, w3, w1
        tmp[--i] = '0' + c;
  2023c4:	1100c063 	add	w3, w3, #0x30
  2023c8:	92401c60 	and	x0, x3, #0xff
  2023cc:	390027e0 	strb	w0, [sp, #9]
    } while (x);
  2023d0:	54000089 	b.ls	2023e0 <microkit_dbg_put8+0x70>  // b.plast
        tmp[--i] = '0' + c;
  2023d4:	1100c040 	add	w0, w2, #0x30
  2023d8:	d2800004 	mov	x4, #0x0                   	// #0
  2023dc:	390023e0 	strb	w0, [sp, #8]
    microkit_dbg_puts(&tmp[i]);
  2023e0:	910023e1 	add	x1, sp, #0x8
  2023e4:	8b040028 	add	x8, x1, x4
    register seL4_Word info asm("x1") = info_arg;
  2023e8:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  2023ec:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  2023f0:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  2023f4:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  2023f8:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  2023fc:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  202400:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  202404:	d4000001 	svc	#0x0
    while (*s) {
  202408:	38401d00 	ldrb	w0, [x8, #1]!
  20240c:	35fffee0 	cbnz	w0, 2023e8 <microkit_dbg_put8+0x78>
}
  202410:	910043ff 	add	sp, sp, #0x10
  202414:	d65f03c0 	ret
  202418:	d503201f 	nop
  20241c:	d503201f 	nop

0000000000202420 <__assert_fail>:

void __assert_fail(const char  *str, const char *file, int line, const char *function)
{
  202420:	d000000b 	adrp	x11, 204000 <sddf_sprintf_+0x70>
  202424:	9117c16b 	add	x11, x11, #0x5f0
  202428:	aa0103e9 	mov	x9, x1
  20242c:	aa0303e8 	mov	x8, x3
  202430:	aa0003ea 	mov	x10, x0
    while (*s) {
  202434:	d2800c20 	mov	x0, #0x61                  	// #97
    register seL4_Word info asm("x1") = info_arg;
  202438:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  20243c:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  202440:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  202444:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  202448:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  20244c:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  202450:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  202454:	d4000001 	svc	#0x0
  202458:	38401d60 	ldrb	w0, [x11, #1]!
  20245c:	35fffee0 	cbnz	w0, 202438 <__assert_fail+0x18>
  202460:	39400140 	ldrb	w0, [x10]
  202464:	34000160 	cbz	w0, 202490 <__assert_fail+0x70>
    register seL4_Word info asm("x1") = info_arg;
  202468:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  20246c:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  202470:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  202474:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  202478:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  20247c:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  202480:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  202484:	d4000001 	svc	#0x0
  202488:	38401d40 	ldrb	w0, [x10, #1]!
  20248c:	35fffee0 	cbnz	w0, 202468 <__assert_fail+0x48>
    register seL4_Word destptr asm("x0") = dest;
  202490:	d2800400 	mov	x0, #0x20                  	// #32
    register seL4_Word info asm("x1") = info_arg;
  202494:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  202498:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  20249c:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  2024a0:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  2024a4:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  2024a8:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  2024ac:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  2024b0:	d4000001 	svc	#0x0
  2024b4:	39400120 	ldrb	w0, [x9]
  2024b8:	34000180 	cbz	w0, 2024e8 <__assert_fail+0xc8>
  2024bc:	d503201f 	nop
    register seL4_Word info asm("x1") = info_arg;
  2024c0:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  2024c4:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  2024c8:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  2024cc:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  2024d0:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  2024d4:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  2024d8:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  2024dc:	d4000001 	svc	#0x0
  2024e0:	38401d20 	ldrb	w0, [x9, #1]!
  2024e4:	35fffee0 	cbnz	w0, 2024c0 <__assert_fail+0xa0>
    register seL4_Word destptr asm("x0") = dest;
  2024e8:	d2800400 	mov	x0, #0x20                  	// #32
    register seL4_Word info asm("x1") = info_arg;
  2024ec:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  2024f0:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  2024f4:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  2024f8:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  2024fc:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  202500:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  202504:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  202508:	d4000001 	svc	#0x0
  20250c:	39400100 	ldrb	w0, [x8]
  202510:	34000180 	cbz	w0, 202540 <__assert_fail+0x120>
  202514:	d503201f 	nop
    register seL4_Word info asm("x1") = info_arg;
  202518:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  20251c:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  202520:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  202524:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  202528:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  20252c:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  202530:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  202534:	d4000001 	svc	#0x0
  202538:	38401d00 	ldrb	w0, [x8, #1]!
  20253c:	35fffee0 	cbnz	w0, 202518 <__assert_fail+0xf8>
    register seL4_Word destptr asm("x0") = dest;
  202540:	d2800140 	mov	x0, #0xa                   	// #10
    register seL4_Word info asm("x1") = info_arg;
  202544:	d2800001 	mov	x1, #0x0                   	// #0
    register seL4_Word msg0 asm("x2") = *in_out_mr0;
  202548:	d2800002 	mov	x2, #0x0                   	// #0
    register seL4_Word msg1 asm("x3") = *in_out_mr1;
  20254c:	d2800003 	mov	x3, #0x0                   	// #0
    register seL4_Word msg2 asm("x4") = *in_out_mr2;
  202550:	d2800004 	mov	x4, #0x0                   	// #0
    register seL4_Word msg3 asm("x5") = *in_out_mr3;
  202554:	d2800005 	mov	x5, #0x0                   	// #0
    MCS_PARAM_DECL("x6");
  202558:	d2800006 	mov	x6, #0x0                   	// #0
    register seL4_Word scno asm("x7") = sys;
  20255c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
    asm volatile(
  202560:	d4000001 	svc	#0x0
    microkit_dbg_puts(" ");
    microkit_dbg_puts(file);
    microkit_dbg_puts(" ");
    microkit_dbg_puts(function);
    microkit_dbg_puts("\n");
}
  202564:	d65f03c0 	ret
	...

0000000000202570 <_out_buffer>:


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
  202570:	eb03005f 	cmp	x2, x3
{
  202574:	12001c00 	and	w0, w0, #0xff
  if (idx < maxlen) {
  202578:	54000042 	b.cs	202580 <_out_buffer+0x10>  // b.hs, b.nlast
    ((char*)buffer)[idx] = character;
  20257c:	38226820 	strb	w0, [x1, x2]
  }
}
  202580:	d65f03c0 	ret
  202584:	d503201f 	nop
  202588:	d503201f 	nop
  20258c:	d503201f 	nop

0000000000202590 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
  202590:	d65f03c0 	ret
  202594:	d503201f 	nop
  202598:	d503201f 	nop
  20259c:	d503201f 	nop

00000000002025a0 <_out_rev>:
}


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
  2025a0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  2025a4:	910003fd 	mov	x29, sp
  2025a8:	a90153f3 	stp	x19, x20, [sp, #16]
  2025ac:	aa0503f3 	mov	x19, x5
  2025b0:	aa0203f4 	mov	x20, x2
  2025b4:	a9025bf5 	stp	x21, x22, [sp, #32]
  2025b8:	aa0003f5 	mov	x21, x0
  2025bc:	aa0103f6 	mov	x22, x1
  2025c0:	a90363f7 	stp	x23, x24, [sp, #48]
  2025c4:	aa0203f8 	mov	x24, x2
  2025c8:	aa0303f7 	mov	x23, x3
  2025cc:	a9046bf9 	stp	x25, x26, [sp, #64]
  2025d0:	aa0403f9 	mov	x25, x4
  2025d4:	2a0603fa 	mov	w26, w6
  2025d8:	a90573fb 	stp	x27, x28, [sp, #80]
  2025dc:	2a0703fb 	mov	w27, w7
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
  2025e0:	f240077f 	tst	x27, #0x3
  2025e4:	540001e1 	b.ne	202620 <_out_rev+0x80>  // b.any
    for (size_t i = len; i < width; i++) {
  2025e8:	2a1a03e0 	mov	w0, w26
  2025ec:	aa0203fc 	mov	x28, x2
  2025f0:	cb050014 	sub	x20, x0, x5
  2025f4:	eb0000bf 	cmp	x5, x0
  2025f8:	8b020294 	add	x20, x20, x2
  2025fc:	54000502 	b.cs	20269c <_out_rev+0xfc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  202600:	aa1c03e2 	mov	x2, x28
  202604:	aa1703e3 	mov	x3, x23
  202608:	9100079c 	add	x28, x28, #0x1
  20260c:	aa1603e1 	mov	x1, x22
  202610:	52800400 	mov	w0, #0x20                  	// #32
  202614:	d63f02a0 	blr	x21
    for (size_t i = len; i < width; i++) {
  202618:	eb1c029f 	cmp	x20, x28
  20261c:	54ffff21 	b.ne	202600 <_out_rev+0x60>  // b.any
    }
  }

  // reverse string
  while (len) {
  202620:	8b14027c 	add	x28, x19, x20
  202624:	b4000133 	cbz	x19, 202648 <_out_rev+0xa8>
  202628:	cb130382 	sub	x2, x28, x19
    out(buf[--len], buffer, idx++, maxlen);
  20262c:	d1000673 	sub	x19, x19, #0x1
  202630:	aa1c03f4 	mov	x20, x28
  202634:	aa1703e3 	mov	x3, x23
  202638:	aa1603e1 	mov	x1, x22
  20263c:	38736b20 	ldrb	w0, [x25, x19]
  202640:	d63f02a0 	blr	x21
  while (len) {
  202644:	b5ffff33 	cbnz	x19, 202628 <_out_rev+0x88>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
  202648:	360801bb 	tbz	w27, #1, 20267c <_out_rev+0xdc>
    while (idx - start_idx < width) {
  20264c:	cb180298 	sub	x24, x20, x24
  202650:	eb1a031f 	cmp	x24, x26
  202654:	54000142 	b.cs	20267c <_out_rev+0xdc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  202658:	aa1403e2 	mov	x2, x20
    while (idx - start_idx < width) {
  20265c:	91000718 	add	x24, x24, #0x1
      out(' ', buffer, idx++, maxlen);
  202660:	aa1703e3 	mov	x3, x23
  202664:	aa1603e1 	mov	x1, x22
  202668:	52800400 	mov	w0, #0x20                  	// #32
  20266c:	d63f02a0 	blr	x21
  202670:	91000694 	add	x20, x20, #0x1
    while (idx - start_idx < width) {
  202674:	eb1a031f 	cmp	x24, x26
  202678:	54ffff03 	b.cc	202658 <_out_rev+0xb8>  // b.lo, b.ul, b.last
    }
  }

  return idx;
}
  20267c:	a9425bf5 	ldp	x21, x22, [sp, #32]
  202680:	aa1403e0 	mov	x0, x20
  202684:	a94153f3 	ldp	x19, x20, [sp, #16]
  202688:	a94363f7 	ldp	x23, x24, [sp, #48]
  20268c:	a9446bf9 	ldp	x25, x26, [sp, #64]
  202690:	a94573fb 	ldp	x27, x28, [sp, #80]
  202694:	a8c67bfd 	ldp	x29, x30, [sp], #96
  202698:	d65f03c0 	ret
    for (size_t i = len; i < width; i++) {
  20269c:	aa0203f4 	mov	x20, x2
  2026a0:	17ffffe0 	b	202620 <_out_rev+0x80>
  2026a4:	d503201f 	nop
  2026a8:	d503201f 	nop
  2026ac:	d503201f 	nop

00000000002026b0 <_ntoa_long>:
}


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  2026b0:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  2026b4:	aa0603eb 	mov	x11, x6
  2026b8:	aa0403ea 	mov	x10, x4
  2026bc:	910003fd 	mov	x29, sp
  2026c0:	b9403be8 	ldr	w8, [sp, #56]
  2026c4:	2a0703ef 	mov	w15, w7
  2026c8:	b94033e6 	ldr	w6, [sp, #48]
  2026cc:	12001cb2 	and	w18, w5, #0xff
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
  2026d0:	12160110 	and	w16, w8, #0x400
  if (!value) {
  2026d4:	b4000764 	cbz	x4, 2027c0 <_ntoa_long+0x110>
  if (flags & FLAGS_HASH) {
  2026d8:	121c0111 	and	w17, w8, #0x10
  2026dc:	2a0803e7 	mov	w7, w8
    do {
      const char digit = (char)(value % base);
  2026e0:	9acb094c 	udiv	x12, x10, x11
  2026e4:	f27b00ff 	tst	x7, #0x20
  2026e8:	52800c24 	mov	w4, #0x61                  	// #97
  2026ec:	5280082d 	mov	w13, #0x41                  	// #65
  2026f0:	1a8411ad 	csel	w13, w13, w4, ne	// ne = any
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  2026f4:	d2800005 	mov	x5, #0x0                   	// #0
  2026f8:	510029ad 	sub	w13, w13, #0xa
  2026fc:	910043e4 	add	x4, sp, #0x10
      const char digit = (char)(value % base);
  202700:	9b0ba988 	msub	x8, x12, x11, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202704:	910004a5 	add	x5, x5, #0x1
  202708:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  20270c:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202710:	1100c10e 	add	w14, w8, #0x30
  202714:	0b0d0108 	add	w8, w8, w13
  202718:	54000248 	b.hi	202760 <_ntoa_long+0xb0>  // b.pmore
  20271c:	d503201f 	nop
  202720:	8b050088 	add	x8, x4, x5
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  202724:	f1007cbf 	cmp	x5, #0x1f
  202728:	1a9f87e9 	cset	w9, ls	// ls = plast
  20272c:	7100013f 	cmp	w9, #0x0
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202730:	381ff10e 	sturb	w14, [x8, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  202734:	fa4a1162 	ccmp	x11, x10, #0x2, ne	// ne = any
  202738:	54000228 	b.hi	20277c <_ntoa_long+0xcc>  // b.pmore
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  20273c:	aa0c03ea 	mov	x10, x12
  202740:	910004a5 	add	x5, x5, #0x1
      const char digit = (char)(value % base);
  202744:	9acb094c 	udiv	x12, x10, x11
  202748:	9b0ba988 	msub	x8, x12, x11, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  20274c:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  202750:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202754:	1100c10e 	add	w14, w8, #0x30
  202758:	0b0d0108 	add	w8, w8, w13
  20275c:	54fffe29 	b.ls	202720 <_ntoa_long+0x70>  // b.plast
  202760:	8b05008e 	add	x14, x4, x5
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  202764:	f1007cbf 	cmp	x5, #0x1f
  202768:	1a9f87e9 	cset	w9, ls	// ls = plast
  20276c:	7100013f 	cmp	w9, #0x0
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202770:	381ff1c8 	sturb	w8, [x14, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  202774:	fa4a1162 	ccmp	x11, x10, #0x2, ne	// ne = any
  202778:	54fffe29 	b.ls	20273c <_ntoa_long+0x8c>  // b.plast
  if (!(flags & FLAGS_LEFT)) {
  20277c:	36080307 	tbz	w7, #1, 2027dc <_ntoa_long+0x12c>
  if (flags & FLAGS_HASH) {
  202780:	34000771 	cbz	w17, 20286c <_ntoa_long+0x1bc>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  202784:	34000850 	cbz	w16, 20288c <_ntoa_long+0x1dc>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202788:	f100417f 	cmp	x11, #0x10
  20278c:	54000de0 	b.eq	202948 <_ntoa_long+0x298>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202790:	7100013f 	cmp	w9, #0x0
  202794:	7a421960 	ccmp	w11, #0x2, #0x0, ne	// ne = any
  202798:	540000a1 	b.ne	2027ac <_ntoa_long+0xfc>  // b.any
      buf[len++] = 'b';
  20279c:	aa0503e8 	mov	x8, x5
  2027a0:	910004a5 	add	x5, x5, #0x1
  2027a4:	52800c49 	mov	w9, #0x62                  	// #98
  2027a8:	38286889 	strb	w9, [x4, x8]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  2027ac:	f10080bf 	cmp	x5, #0x20
  2027b0:	54000881 	b.ne	2028c0 <_ntoa_long+0x210>  // b.any
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  2027b4:	97ffff7b 	bl	2025a0 <_out_rev>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
  2027b8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  2027bc:	d65f03c0 	ret
    flags &= ~FLAGS_HASH;
  2027c0:	121b7907 	and	w7, w8, #0xffffffef
  if (!(flags & FLAGS_PRECISION) || value) {
  2027c4:	340008d0 	cbz	w16, 2028dc <_ntoa_long+0x22c>
  if (!(flags & FLAGS_LEFT)) {
  2027c8:	121f0111 	and	w17, w8, #0x2
  2027cc:	37080a08 	tbnz	w8, #1, 20290c <_ntoa_long+0x25c>
  2027d0:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  2027d4:	d2800005 	mov	x5, #0x0                   	// #0
  if (!(flags & FLAGS_LEFT)) {
  2027d8:	52800029 	mov	w9, #0x1                   	// #1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2027dc:	2a0f03ea 	mov	w10, w15
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  2027e0:	120000ed 	and	w13, w7, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2027e4:	eb0a00bf 	cmp	x5, x10
  2027e8:	1a9f27e8 	cset	w8, cc	// cc = lo, ul, last
  2027ec:	0a080128 	and	w8, w9, w8
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  2027f0:	340007a6 	cbz	w6, 2028e4 <_ntoa_long+0x234>
  2027f4:	3400088d 	cbz	w13, 202904 <_ntoa_long+0x254>
  2027f8:	35000072 	cbnz	w18, 202804 <_ntoa_long+0x154>
  2027fc:	721e04ff 	tst	w7, #0xc
  202800:	54000040 	b.eq	202808 <_ntoa_long+0x158>  // b.none
      width--;
  202804:	510004c6 	sub	w6, w6, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202808:	34000168 	cbz	w8, 202834 <_ntoa_long+0x184>
      buf[len++] = '0';
  20280c:	5280060c 	mov	w12, #0x30                  	// #48
  202810:	910004a5 	add	x5, x5, #0x1
  202814:	8b050088 	add	x8, x4, x5
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202818:	f1007cbf 	cmp	x5, #0x1f
  20281c:	1a9f87e9 	cset	w9, ls	// ls = plast
  202820:	7100013f 	cmp	w9, #0x0
      buf[len++] = '0';
  202824:	381ff10c 	sturb	w12, [x8, #-1]
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202828:	fa4a10a2 	ccmp	x5, x10, #0x2, ne	// ne = any
  20282c:	54ffff23 	b.cc	202810 <_ntoa_long+0x160>  // b.lo, b.ul, b.last
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202830:	34fffa8d 	cbz	w13, 202780 <_ntoa_long+0xd0>
  202834:	7100013f 	cmp	w9, #0x0
  202838:	2a0603ea 	mov	w10, w6
  20283c:	fa451140 	ccmp	x10, x5, #0x0, ne	// ne = any
  202840:	54fffa09 	b.ls	202780 <_ntoa_long+0xd0>  // b.plast
      buf[len++] = '0';
  202844:	5280060c 	mov	w12, #0x30                  	// #48
  202848:	910004a5 	add	x5, x5, #0x1
  20284c:	8b050088 	add	x8, x4, x5
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202850:	f1007cbf 	cmp	x5, #0x1f
  202854:	1a9f87e9 	cset	w9, ls	// ls = plast
  202858:	7100013f 	cmp	w9, #0x0
      buf[len++] = '0';
  20285c:	381ff10c 	sturb	w12, [x8, #-1]
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202860:	fa4a10a2 	ccmp	x5, x10, #0x2, ne	// ne = any
  202864:	54ffff23 	b.cc	202848 <_ntoa_long+0x198>  // b.lo, b.ul, b.last
  if (flags & FLAGS_HASH) {
  202868:	35fff8f1 	cbnz	w17, 202784 <_ntoa_long+0xd4>
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  20286c:	f10080bf 	cmp	x5, #0x20
  202870:	54fffa20 	b.eq	2027b4 <_ntoa_long+0x104>  // b.none
    if (negative) {
  202874:	350003d2 	cbnz	w18, 2028ec <_ntoa_long+0x23c>
    else if (flags & FLAGS_PLUS) {
  202878:	36100787 	tbz	w7, #2, 202968 <_ntoa_long+0x2b8>
      buf[len++] = '+';  // ignore the space if the '+' exists
  20287c:	52800568 	mov	w8, #0x2b                  	// #43
  202880:	38256888 	strb	w8, [x4, x5]
  202884:	910004a5 	add	x5, x5, #0x1
  202888:	17ffffcb 	b	2027b4 <_ntoa_long+0x104>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  20288c:	b4000485 	cbz	x5, 20291c <_ntoa_long+0x26c>
  202890:	eb2f40bf 	cmp	x5, w15, uxtw
  202894:	54000060 	b.eq	2028a0 <_ntoa_long+0x1f0>  // b.none
  202898:	eb2640bf 	cmp	x5, w6, uxtw
  20289c:	54fff761 	b.ne	202788 <_ntoa_long+0xd8>  // b.any
      if (len && (base == 16U)) {
  2028a0:	f10004a8 	subs	x8, x5, #0x1
  2028a4:	7a501960 	ccmp	w11, #0x10, #0x0, ne	// ne = any
  2028a8:	54000821 	b.ne	2029ac <_ntoa_long+0x2fc>  // b.any
        len--;
  2028ac:	d10008a9 	sub	x9, x5, #0x2
      buf[len++] = 'x';
  2028b0:	aa0803e5 	mov	x5, x8
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2028b4:	36280907 	tbz	w7, #5, 2029d4 <_ntoa_long+0x324>
      buf[len++] = 'X';
  2028b8:	52800b08 	mov	w8, #0x58                  	// #88
  2028bc:	38296888 	strb	w8, [x4, x9]
      buf[len++] = '0';
  2028c0:	aa0503e8 	mov	x8, x5
  2028c4:	910004a5 	add	x5, x5, #0x1
  2028c8:	52800609 	mov	w9, #0x30                  	// #48
  2028cc:	38286889 	strb	w9, [x4, x8]
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  2028d0:	f10080bf 	cmp	x5, #0x20
  2028d4:	54fff700 	b.eq	2027b4 <_ntoa_long+0x104>  // b.none
  2028d8:	17ffffe7 	b	202874 <_ntoa_long+0x1c4>
  if (!(flags & FLAGS_PRECISION) || value) {
  2028dc:	52800011 	mov	w17, #0x0                   	// #0
  2028e0:	17ffff80 	b	2026e0 <_ntoa_long+0x30>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2028e4:	35fff948 	cbnz	w8, 20280c <_ntoa_long+0x15c>
  2028e8:	17ffffd2 	b	202830 <_ntoa_long+0x180>
      buf[len++] = '-';
  2028ec:	528005a8 	mov	w8, #0x2d                  	// #45
  2028f0:	38256888 	strb	w8, [x4, x5]
  2028f4:	910004a5 	add	x5, x5, #0x1
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  2028f8:	97ffff2a 	bl	2025a0 <_out_rev>
}
  2028fc:	a8c37bfd 	ldp	x29, x30, [sp], #48
  202900:	d65f03c0 	ret
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202904:	35fff848 	cbnz	w8, 20280c <_ntoa_long+0x15c>
  202908:	17ffff9e 	b	202780 <_ntoa_long+0xd0>
  20290c:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  202910:	d2800005 	mov	x5, #0x0                   	// #0
    if (negative) {
  202914:	34fffb32 	cbz	w18, 202878 <_ntoa_long+0x1c8>
  202918:	17fffff5 	b	2028ec <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20291c:	f100417f 	cmp	x11, #0x10
  202920:	54000500 	b.eq	2029c0 <_ntoa_long+0x310>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202924:	f100097f 	cmp	x11, #0x2
  202928:	54000381 	b.ne	202998 <_ntoa_long+0x2e8>  // b.any
  20292c:	52800c48 	mov	w8, #0x62                  	// #98
      buf[len++] = '0';
  202930:	52800609 	mov	w9, #0x30                  	// #48
      buf[len++] = 'x';
  202934:	390043e8 	strb	w8, [sp, #16]
      buf[len++] = '0';
  202938:	390047e9 	strb	w9, [sp, #17]
  20293c:	d2800045 	mov	x5, #0x2                   	// #2
    if (negative) {
  202940:	34fff9d2 	cbz	w18, 202878 <_ntoa_long+0x1c8>
  202944:	17ffffea 	b	2028ec <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202948:	362801a7 	tbz	w7, #5, 20297c <_ntoa_long+0x2cc>
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20294c:	f10080bf 	cmp	x5, #0x20
  202950:	54fff320 	b.eq	2027b4 <_ntoa_long+0x104>  // b.none
      buf[len++] = 'b';
  202954:	910004a9 	add	x9, x5, #0x1
      buf[len++] = 'X';
  202958:	52800b08 	mov	w8, #0x58                  	// #88
  20295c:	38256888 	strb	w8, [x4, x5]
  202960:	aa0903e5 	mov	x5, x9
  202964:	17ffff92 	b	2027ac <_ntoa_long+0xfc>
    else if (flags & FLAGS_SPACE) {
  202968:	361ff267 	tbz	w7, #3, 2027b4 <_ntoa_long+0x104>
      buf[len++] = ' ';
  20296c:	52800408 	mov	w8, #0x20                  	// #32
  202970:	38256888 	strb	w8, [x4, x5]
  202974:	910004a5 	add	x5, x5, #0x1
  202978:	17ffff8f 	b	2027b4 <_ntoa_long+0x104>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20297c:	f10080bf 	cmp	x5, #0x20
  202980:	54fff1a0 	b.eq	2027b4 <_ntoa_long+0x104>  // b.none
      buf[len++] = 'b';
  202984:	aa0503e8 	mov	x8, x5
  202988:	910004a5 	add	x5, x5, #0x1
      buf[len++] = 'x';
  20298c:	52800f09 	mov	w9, #0x78                  	// #120
  202990:	38286889 	strb	w9, [x4, x8]
  202994:	17ffff86 	b	2027ac <_ntoa_long+0xfc>
      buf[len++] = '0';
  202998:	52800608 	mov	w8, #0x30                  	// #48
  20299c:	390043e8 	strb	w8, [sp, #16]
  2029a0:	d2800025 	mov	x5, #0x1                   	// #1
    if (negative) {
  2029a4:	34fff6b2 	cbz	w18, 202878 <_ntoa_long+0x1c8>
  2029a8:	17ffffd1 	b	2028ec <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2029ac:	f100417f 	cmp	x11, #0x10
  2029b0:	54000180 	b.eq	2029e0 <_ntoa_long+0x330>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2029b4:	f100097f 	cmp	x11, #0x2
  2029b8:	54ffef60 	b.eq	2027a4 <_ntoa_long+0xf4>  // b.none
  2029bc:	17ffffc3 	b	2028c8 <_ntoa_long+0x218>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2029c0:	f27b00ff 	tst	x7, #0x20
  2029c4:	52800f08 	mov	w8, #0x78                  	// #120
  2029c8:	52800b05 	mov	w5, #0x58                  	// #88
  2029cc:	1a850108 	csel	w8, w8, w5, eq	// eq = none
  2029d0:	17ffffd8 	b	202930 <_ntoa_long+0x280>
      buf[len++] = 'x';
  2029d4:	52800f08 	mov	w8, #0x78                  	// #120
  2029d8:	38296888 	strb	w8, [x4, x9]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  2029dc:	17ffffb9 	b	2028c0 <_ntoa_long+0x210>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2029e0:	362ffd67 	tbz	w7, #5, 20298c <_ntoa_long+0x2dc>
  2029e4:	aa0503e9 	mov	x9, x5
      len--;
  2029e8:	aa0803e5 	mov	x5, x8
  2029ec:	17ffffdb 	b	202958 <_ntoa_long+0x2a8>

00000000002029f0 <_out_char>:
  if (character) {
  2029f0:	72001c00 	ands	w0, w0, #0xff
  2029f4:	54000041 	b.ne	2029fc <_out_char+0xc>  // b.any
}
  2029f8:	d65f03c0 	ret
    _sddf_putchar(character);
  2029fc:	14000609 	b	204220 <_sddf_putchar>

0000000000202a00 <_out_fct>:
  if (character) {
  202a00:	72001c00 	ands	w0, w0, #0xff
  202a04:	54000080 	b.eq	202a14 <_out_fct+0x14>  // b.none
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  202a08:	a9400422 	ldp	x2, x1, [x1]
  202a0c:	aa0203f0 	mov	x16, x2
  202a10:	d61f0200 	br	x16
}
  202a14:	d65f03c0 	ret
  202a18:	d503201f 	nop
  202a1c:	d503201f 	nop

0000000000202a20 <_ftoa>:

  // powers of 10
  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for special values
  if (value != value)
  202a20:	1e602000 	fcmp	d0, d0
{
  202a24:	2a0603e7 	mov	w7, w6
  if (value != value)
  202a28:	54000fa1 	b.ne	202c1c <_ftoa+0x1fc>  // b.any
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  if (value < -DBL_MAX)
  202a2c:	92e00206 	mov	x6, #0xffefffffffffffff    	// #-4503599627370497
  202a30:	9e6700c1 	fmov	d1, x6
  202a34:	1e612010 	fcmpe	d0, d1
  202a38:	54001324 	b.mi	202c9c <_ftoa+0x27c>  // b.first
  202a3c:	aa0003ef 	mov	x15, x0
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  if (value > DBL_MAX)
  202a40:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  202a44:	9e670001 	fmov	d1, x0
  202a48:	aa0103f0 	mov	x16, x1
  202a4c:	aa0203f1 	mov	x17, x2
  202a50:	aa0303f2 	mov	x18, x3
  202a54:	1e612010 	fcmpe	d0, d1
  202a58:	54000ccc 	b.gt	202bf0 <_ftoa+0x1d0>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);

  // test for very large values
  // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
  202a5c:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  202a60:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  202a64:	9e670001 	fmov	d1, x0
  202a68:	1e612010 	fcmpe	d0, d1
  202a6c:	540010cc 	b.gt	202c84 <_ftoa+0x264>
  202a70:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  202a74:	f2f839a0 	movk	x0, #0xc1cd, lsl #48
  202a78:	9e670001 	fmov	d1, x0
  202a7c:	1e612010 	fcmpe	d0, d1
  202a80:	54001024 	b.mi	202c84 <_ftoa+0x264>  // b.first
#endif
  }

  // test for negative
  bool negative = false;
  if (value < 0) {
  202a84:	1e602018 	fcmpe	d0, #0.0
{
  202a88:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  202a8c:	910003fd 	mov	x29, sp
  if (value < 0) {
  202a90:	54000e44 	b.mi	202c58 <_ftoa+0x238>  // b.first
  bool negative = false;
  202a94:	52800003 	mov	w3, #0x0                   	// #0
    negative = true;
    value = 0 - value;
  }

  // set default precision, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
  202a98:	36500e87 	tbz	w7, #10, 202c68 <_ftoa+0x248>
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  202a9c:	7100249f 	cmp	w4, #0x9
  202aa0:	54001b49 	b.ls	202e08 <_ftoa+0x3e8>  // b.plast
  202aa4:	910043ec 	add	x12, sp, #0x10
  202aa8:	d2800008 	mov	x8, #0x0                   	// #0
    buf[len++] = '0';
  202aac:	52800601 	mov	w1, #0x30                  	// #48
  202ab0:	91000508 	add	x8, x8, #0x1
    prec--;
  202ab4:	51000484 	sub	w4, w4, #0x1
    buf[len++] = '0';
  202ab8:	8b080180 	add	x0, x12, x8
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  202abc:	f1007d1f 	cmp	x8, #0x1f
  202ac0:	7a499880 	ccmp	w4, #0x9, #0x0, ls	// ls = plast
    buf[len++] = '0';
  202ac4:	381ff001 	sturb	w1, [x0, #-1]
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  202ac8:	54ffff48 	b.hi	202ab0 <_ftoa+0x90>  // b.pmore
  202acc:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  202ad0:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  202ad4:	9e670002 	fmov	d2, x0
  }

  int whole = (int)value;
  202ad8:	1e78000a 	fcvtzs	w10, d0
  double tmp = (value - whole) * pow10[prec];
  unsigned long frac = (unsigned long)tmp;
  diff = tmp - frac;

  if (diff > 0.5) {
  202adc:	1e6c1003 	fmov	d3, #5.000000000000000000e-01
  double tmp = (value - whole) * pow10[prec];
  202ae0:	1e620141 	scvtf	d1, w10
  202ae4:	1e613801 	fsub	d1, d0, d1
  202ae8:	1e620821 	fmul	d1, d1, d2
  unsigned long frac = (unsigned long)tmp;
  202aec:	9e79002e 	fcvtzu	x14, d1
  diff = tmp - frac;
  202af0:	9e6301c4 	ucvtf	d4, x14
  202af4:	1e643821 	fsub	d1, d1, d4
  if (diff > 0.5) {
  202af8:	1e632030 	fcmpe	d1, d3
  202afc:	5400106c 	b.gt	202d08 <_ftoa+0x2e8>
    if (frac >= pow10[prec]) {
      frac = 0;
      ++whole;
    }
  }
  else if (diff < 0.5) {
  202b00:	54000084 	b.mi	202b10 <_ftoa+0xf0>  // b.first
  }
  else if ((frac == 0U) || (frac & 1U)) {
  202b04:	b500172e 	cbnz	x14, 202de8 <_ftoa+0x3c8>
    // if halfway, round up if odd OR if last digit is 0
    ++frac;
  202b08:	910005ce 	add	x14, x14, #0x1
  202b0c:	d503201f 	nop
  }

  if (prec == 0U) {
  202b10:	35000d04 	cbnz	w4, 202cb0 <_ftoa+0x290>
    diff = value - (double)whole;
  202b14:	1e620141 	scvtf	d1, w10
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  202b18:	1e6c1002 	fmov	d2, #5.000000000000000000e-01
    diff = value - (double)whole;
  202b1c:	1e613800 	fsub	d0, d0, d1
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  202b20:	1e622010 	fcmpe	d0, d2
  202b24:	54001564 	b.mi	202dd0 <_ftoa+0x3b0>  // b.first
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
  202b28:	12000140 	and	w0, w10, #0x1
  202b2c:	0b00014a 	add	w10, w10, w0
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    buf[len++] = (char)(48 + (whole % 10));
  202b30:	528ccce1 	mov	w1, #0x6667                	// #26215
  202b34:	72acccc1 	movk	w1, #0x6666, lsl #16
  202b38:	52800142 	mov	w2, #0xa                   	// #10
  202b3c:	1400000a 	b	202b64 <_ftoa+0x144>
  202b40:	9362fd29 	asr	x9, x9, #34
  202b44:	91000508 	add	x8, x8, #0x1
  202b48:	4b8a7d29 	sub	w9, w9, w10, asr #31
  202b4c:	8b080180 	add	x0, x12, x8
  202b50:	1b02a92b 	msub	w11, w9, w2, w10
    if (!(whole /= 10)) {
  202b54:	2a0903ea 	mov	w10, w9
    buf[len++] = (char)(48 + (whole % 10));
  202b58:	1100c169 	add	w9, w11, #0x30
  202b5c:	381ff009 	sturb	w9, [x0, #-1]
    if (!(whole /= 10)) {
  202b60:	34000e4a 	cbz	w10, 202d28 <_ftoa+0x308>
    buf[len++] = (char)(48 + (whole % 10));
  202b64:	9b217d49 	smull	x9, w10, w1
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
  202b68:	f100811f 	cmp	x8, #0x20
  202b6c:	54fffea1 	b.ne	202b40 <_ftoa+0x120>  // b.any
      break;
    }
  }

  // pad leading zeros
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  202b70:	120004e0 	and	w0, w7, #0x3
  202b74:	7100041f 	cmp	w0, #0x1
  202b78:	54000281 	b.ne	202bc8 <_ftoa+0x1a8>  // b.any
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  202b7c:	34000265 	cbz	w5, 202bc8 <_ftoa+0x1a8>
  202b80:	350013a3 	cbnz	w3, 202df4 <_ftoa+0x3d4>
  202b84:	721e04ff 	tst	w7, #0xc
  202b88:	54001361 	b.ne	202df4 <_ftoa+0x3d4>  // b.any
      width--;
    }
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202b8c:	2a0503e2 	mov	w2, w5
  202b90:	eb02011f 	cmp	x8, x2
  202b94:	54001002 	b.cs	202d94 <_ftoa+0x374>  // b.hs, b.nlast
  202b98:	f100811f 	cmp	x8, #0x20
      buf[len++] = '0';
  202b9c:	52800601 	mov	w1, #0x30                  	// #48
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202ba0:	54000120 	b.eq	202bc4 <_ftoa+0x1a4>  // b.none
  202ba4:	d503201f 	nop
      buf[len++] = '0';
  202ba8:	91000508 	add	x8, x8, #0x1
  202bac:	8b080180 	add	x0, x12, x8
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202bb0:	eb02011f 	cmp	x8, x2
      buf[len++] = '0';
  202bb4:	381ff001 	sturb	w1, [x0, #-1]
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202bb8:	54000be0 	b.eq	202d34 <_ftoa+0x314>  // b.none
  202bbc:	f100811f 	cmp	x8, #0x20
  202bc0:	54ffff41 	b.ne	202ba8 <_ftoa+0x188>  // b.any
    }
    else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
  202bc4:	d2800408 	mov	x8, #0x20                  	// #32
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  202bc8:	2a0503e6 	mov	w6, w5
  202bcc:	aa0c03e4 	mov	x4, x12
  202bd0:	aa0803e5 	mov	x5, x8
  202bd4:	aa1203e3 	mov	x3, x18
  202bd8:	aa1103e2 	mov	x2, x17
  202bdc:	aa1003e1 	mov	x1, x16
  202be0:	aa0f03e0 	mov	x0, x15
  202be4:	97fffe6f 	bl	2025a0 <_out_rev>
}
  202be8:	a8c37bfd 	ldp	x29, x30, [sp], #48
  202bec:	d65f03c0 	ret
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  202bf0:	37100207 	tbnz	w7, #2, 202c30 <_ftoa+0x210>
  202bf4:	d2800060 	mov	x0, #0x3                   	// #3
  202bf8:	2a0503e6 	mov	w6, w5
  202bfc:	d0000004 	adrp	x4, 204000 <sddf_sprintf_+0x70>
  202c00:	91182084 	add	x4, x4, #0x608
  202c04:	aa0003e5 	mov	x5, x0
  202c08:	aa1203e3 	mov	x3, x18
  202c0c:	aa1103e2 	mov	x2, x17
  202c10:	aa1003e1 	mov	x1, x16
  202c14:	aa0f03e0 	mov	x0, x15
  202c18:	17fffe62 	b	2025a0 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  202c1c:	2a0503e6 	mov	w6, w5
  202c20:	d0000004 	adrp	x4, 204000 <sddf_sprintf_+0x70>
  202c24:	d2800065 	mov	x5, #0x3                   	// #3
  202c28:	91184084 	add	x4, x4, #0x610
  202c2c:	17fffe5d 	b	2025a0 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  202c30:	d2800080 	mov	x0, #0x4                   	// #4
  202c34:	2a0503e6 	mov	w6, w5
  202c38:	d0000004 	adrp	x4, 204000 <sddf_sprintf_+0x70>
  202c3c:	91180084 	add	x4, x4, #0x600
  202c40:	aa0003e5 	mov	x5, x0
  202c44:	aa1203e3 	mov	x3, x18
  202c48:	aa1103e2 	mov	x2, x17
  202c4c:	aa1003e1 	mov	x1, x16
  202c50:	aa0f03e0 	mov	x0, x15
  202c54:	17fffe53 	b	2025a0 <_out_rev>
    value = 0 - value;
  202c58:	2f00e401 	movi	d1, #0x0
    negative = true;
  202c5c:	52800023 	mov	w3, #0x1                   	// #1
    value = 0 - value;
  202c60:	1e603820 	fsub	d0, d1, d0
  if (!(flags & FLAGS_PRECISION)) {
  202c64:	3757f1c7 	tbnz	w7, #10, 202a9c <_ftoa+0x7c>
  202c68:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  202c6c:	910043ec 	add	x12, sp, #0x10
  202c70:	f2e825c0 	movk	x0, #0x412e, lsl #48
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  202c74:	528000c4 	mov	w4, #0x6                   	// #6
  202c78:	9e670002 	fmov	d2, x0
  202c7c:	d2800008 	mov	x8, #0x0                   	// #0
  202c80:	17ffff96 	b	202ad8 <_ftoa+0xb8>
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
  202c84:	2a0703e6 	mov	w6, w7
  202c88:	aa1203e3 	mov	x3, x18
  202c8c:	aa1103e2 	mov	x2, x17
  202c90:	aa1003e1 	mov	x1, x16
  202c94:	aa0f03e0 	mov	x0, x15
  202c98:	14000066 	b	202e30 <_etoa>
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  202c9c:	2a0503e6 	mov	w6, w5
  202ca0:	d0000004 	adrp	x4, 204000 <sddf_sprintf_+0x70>
  202ca4:	d2800085 	mov	x5, #0x4                   	// #4
  202ca8:	91186084 	add	x4, x4, #0x618
  202cac:	17fffe3d 	b	2025a0 <_out_rev>
  202cb0:	51008081 	sub	w1, w4, #0x20
      buf[len++] = (char)(48U + (frac % 10U));
  202cb4:	b202e7e2 	mov	x2, #0xcccccccccccccccc    	// #-3689348814741910324
  202cb8:	0b080021 	add	w1, w1, w8
  202cbc:	f29999a2 	movk	x2, #0xcccd
  202cc0:	1400000d 	b	202cf4 <_ftoa+0x2d4>
  202cc4:	d343fd6b 	lsr	x11, x11, #3
      if (!(frac /= 10U)) {
  202cc8:	f10025df 	cmp	x14, #0x9
      --count;
  202ccc:	51000480 	sub	w0, w4, #0x1
      buf[len++] = (char)(48U + (frac % 10U));
  202cd0:	91000509 	add	x9, x8, #0x1
  202cd4:	8b0b096d 	add	x13, x11, x11, lsl #2
  202cd8:	cb0d05cd 	sub	x13, x14, x13, lsl #1
      if (!(frac /= 10U)) {
  202cdc:	aa0b03ee 	mov	x14, x11
      buf[len++] = (char)(48U + (frac % 10U));
  202ce0:	1100c1ab 	add	w11, w13, #0x30
  202ce4:	3828698b 	strb	w11, [x12, x8]
      if (!(frac /= 10U)) {
  202ce8:	54000349 	b.ls	202d50 <_ftoa+0x330>  // b.plast
      --count;
  202cec:	2a0003e4 	mov	w4, w0
      buf[len++] = (char)(48U + (frac % 10U));
  202cf0:	aa0903e8 	mov	x8, x9
  202cf4:	9bc27dcb 	umulh	x11, x14, x2
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
  202cf8:	6b01009f 	cmp	w4, w1
  202cfc:	54fffe41 	b.ne	202cc4 <_ftoa+0x2a4>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  202d00:	d2800408 	mov	x8, #0x20                  	// #32
  202d04:	17ffff8b 	b	202b30 <_ftoa+0x110>
    ++frac;
  202d08:	910005ce 	add	x14, x14, #0x1
    if (frac >= pow10[prec]) {
  202d0c:	9e6301c1 	ucvtf	d1, x14
  202d10:	1e622030 	fcmpe	d1, d2
  202d14:	5400004a 	b.ge	202d1c <_ftoa+0x2fc>  // b.tcont
  202d18:	17ffff7e 	b	202b10 <_ftoa+0xf0>
      ++whole;
  202d1c:	1100054a 	add	w10, w10, #0x1
      frac = 0;
  202d20:	d280000e 	mov	x14, #0x0                   	// #0
  202d24:	17ffff7b 	b	202b10 <_ftoa+0xf0>
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  202d28:	120004e0 	and	w0, w7, #0x3
  202d2c:	7100041f 	cmp	w0, #0x1
  202d30:	54000780 	b.eq	202e20 <_ftoa+0x400>  // b.none
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  202d34:	f100811f 	cmp	x8, #0x20
  202d38:	54fff480 	b.eq	202bc8 <_ftoa+0x1a8>  // b.none
    if (negative) {
  202d3c:	34000323 	cbz	w3, 202da0 <_ftoa+0x380>
      buf[len++] = '-';
  202d40:	528005a0 	mov	w0, #0x2d                  	// #45
  202d44:	38286980 	strb	w0, [x12, x8]
  202d48:	91000508 	add	x8, x8, #0x1
  202d4c:	17ffff9f 	b	202bc8 <_ftoa+0x1a8>
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  202d50:	f100813f 	cmp	x9, #0x20
  202d54:	54fffd60 	b.eq	202d00 <_ftoa+0x2e0>  // b.none
  202d58:	91000901 	add	x1, x8, #0x2
  202d5c:	51000884 	sub	w4, w4, #0x2
  202d60:	8b040021 	add	x1, x1, x4
      buf[len++] = '0';
  202d64:	52800602 	mov	w2, #0x30                  	// #48
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  202d68:	35000080 	cbnz	w0, 202d78 <_ftoa+0x358>
  202d6c:	14000013 	b	202db8 <_ftoa+0x398>
  202d70:	eb01013f 	cmp	x9, x1
  202d74:	54000260 	b.eq	202dc0 <_ftoa+0x3a0>  // b.none
      buf[len++] = '0';
  202d78:	91000529 	add	x9, x9, #0x1
  202d7c:	8b090180 	add	x0, x12, x9
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  202d80:	f100813f 	cmp	x9, #0x20
      buf[len++] = '0';
  202d84:	381ff002 	sturb	w2, [x0, #-1]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  202d88:	54ffff41 	b.ne	202d70 <_ftoa+0x350>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  202d8c:	d2800408 	mov	x8, #0x20                  	// #32
  202d90:	17ffff68 	b	202b30 <_ftoa+0x110>
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  202d94:	f100811f 	cmp	x8, #0x20
  202d98:	54fff180 	b.eq	202bc8 <_ftoa+0x1a8>  // b.none
  202d9c:	d503201f 	nop
    else if (flags & FLAGS_PLUS) {
  202da0:	371001c7 	tbnz	w7, #2, 202dd8 <_ftoa+0x3b8>
    else if (flags & FLAGS_SPACE) {
  202da4:	361ff127 	tbz	w7, #3, 202bc8 <_ftoa+0x1a8>
      buf[len++] = ' ';
  202da8:	52800400 	mov	w0, #0x20                  	// #32
  202dac:	38286980 	strb	w0, [x12, x8]
  202db0:	91000508 	add	x8, x8, #0x1
  202db4:	17ffff85 	b	202bc8 <_ftoa+0x1a8>
      buf[len++] = (char)(48U + (frac % 10U));
  202db8:	aa0903e1 	mov	x1, x9
  202dbc:	d503201f 	nop
      buf[len++] = '.';
  202dc0:	528005c0 	mov	w0, #0x2e                  	// #46
  202dc4:	91000428 	add	x8, x1, #0x1
  202dc8:	38216980 	strb	w0, [x12, x1]
  202dcc:	17ffff59 	b	202b30 <_ftoa+0x110>
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  202dd0:	54ffeacc 	b.gt	202b28 <_ftoa+0x108>
  202dd4:	17ffff57 	b	202b30 <_ftoa+0x110>
      buf[len++] = '+';  // ignore the space if the '+' exists
  202dd8:	52800560 	mov	w0, #0x2b                  	// #43
  202ddc:	38286980 	strb	w0, [x12, x8]
  202de0:	91000508 	add	x8, x8, #0x1
  202de4:	17ffff79 	b	202bc8 <_ftoa+0x1a8>
  else if ((frac == 0U) || (frac & 1U)) {
  202de8:	3607e94e 	tbz	w14, #0, 202b10 <_ftoa+0xf0>
    ++frac;
  202dec:	910005ce 	add	x14, x14, #0x1
  202df0:	17ffff48 	b	202b10 <_ftoa+0xf0>
      width--;
  202df4:	510004a2 	sub	w2, w5, #0x1
  202df8:	aa0203e5 	mov	x5, x2
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202dfc:	eb08005f 	cmp	x2, x8
  202e00:	54ffecc8 	b.hi	202b98 <_ftoa+0x178>  // b.pmore
  202e04:	17ffffcc 	b	202d34 <_ftoa+0x314>
  double tmp = (value - whole) * pow10[prec];
  202e08:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202e0c:	910d4000 	add	x0, x0, #0x350
  202e10:	910043ec 	add	x12, sp, #0x10
  202e14:	d2800008 	mov	x8, #0x0                   	// #0
  202e18:	fc645802 	ldr	d2, [x0, w4, uxtw #3]
  202e1c:	17ffff2f 	b	202ad8 <_ftoa+0xb8>
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  202e20:	34fff8a5 	cbz	w5, 202d34 <_ftoa+0x314>
  202e24:	17ffff57 	b	202b80 <_ftoa+0x160>
  202e28:	d503201f 	nop
  202e2c:	d503201f 	nop

0000000000202e30 <_etoa>:


#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  202e30:	d10203ff 	sub	sp, sp, #0x80
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  202e34:	1e602000 	fcmp	d0, d0
{
  202e38:	a9017bfd 	stp	x29, x30, [sp, #16]
  202e3c:	910043fd 	add	x29, sp, #0x10
  202e40:	a90253f3 	stp	x19, x20, [sp, #32]
  202e44:	aa0203f3 	mov	x19, x2
  202e48:	2a0603f4 	mov	w20, w6
  202e4c:	a9035bf5 	stp	x21, x22, [sp, #48]
  202e50:	aa0003f5 	mov	x21, x0
  202e54:	aa0103f6 	mov	x22, x1
  202e58:	a90463f7 	stp	x23, x24, [sp, #64]
  202e5c:	aa0303f7 	mov	x23, x3
  202e60:	a90673fb 	stp	x27, x28, [sp, #96]
  202e64:	2a0503fb 	mov	w27, w5
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  202e68:	540012c1 	b.ne	2030c0 <_etoa+0x290>  // b.any
  202e6c:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  202e70:	9e670001 	fmov	d1, x0
  202e74:	1e612010 	fcmpe	d0, d1
  202e78:	5400124c 	b.gt	2030c0 <_etoa+0x290>
  202e7c:	92e00200 	mov	x0, #0xffefffffffffffff    	// #-4503599627370497
  202e80:	9e670001 	fmov	d1, x0
  202e84:	1e612010 	fcmpe	d0, d1
  202e88:	540011c4 	b.mi	2030c0 <_etoa+0x290>  // b.first
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  }

  // determine the sign
  const bool negative = value < 0;
  if (negative) {
  202e8c:	1e602018 	fcmpe	d0, #0.0
  202e90:	1e614002 	fneg	d2, d0

  conv.F = value;
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202e94:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202e98:	fd432c16 	ldr	d22, [x0, #1624]
  202e9c:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202ea0:	fd433001 	ldr	d1, [x0, #1632]
  202ea4:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202ea8:	fd433415 	ldr	d21, [x0, #1640]
  202eac:	1e604c42 	fcsel	d2, d2, d0, mi	// mi = first
  // now we want to compute 10^expval but we want to be sure it won't overflow
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202eb0:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202eb4:	fd433814 	ldr	d20, [x0, #1648]
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  202eb8:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202ebc:	fd433c13 	ldr	d19, [x0, #1656]
  202ec0:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202ec4:	fd434012 	ldr	d18, [x0, #1664]
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202ec8:	1e6f1018 	fmov	d24, #1.500000000000000000e+00
  conv.F = value;
  202ecc:	9e660040 	fmov	x0, d2
  202ed0:	a9056bf9 	stp	x25, x26, [sp, #80]
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202ed4:	1e6c1005 	fmov	d5, #5.000000000000000000e-01
  const double z2 = z * z;
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202ed8:	1e659003 	fmov	d3, #1.400000000000000000e+01
  202edc:	1e649007 	fmov	d7, #1.000000000000000000e+01
  202ee0:	1e631011 	fmov	d17, #6.000000000000000000e+00
  202ee4:	1e601006 	fmov	d6, #2.000000000000000000e+00
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  202ee8:	9240cc01 	and	x1, x0, #0xfffffffffffff
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  202eec:	d374f800 	ubfx	x0, x0, #52, #11
  202ef0:	510ffc00 	sub	w0, w0, #0x3ff
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  202ef4:	b24c2421 	orr	x1, x1, #0x3ff0000000000000
  202ef8:	9e670024 	fmov	d4, x1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202efc:	1e6e1010 	fmov	d16, #1.000000000000000000e+00
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202f00:	1e620017 	scvtf	d23, w0
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  202f04:	721600c3 	ands	w3, w6, #0x400
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202f08:	1e783884 	fsub	d4, d4, d24
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  202f0c:	528000c2 	mov	w2, #0x6                   	// #6
  202f10:	1a821084 	csel	w4, w4, w2, ne	// ne = any
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202f14:	1f5606e1 	fmadd	d1, d23, d22, d1
  202f18:	1f550481 	fmadd	d1, d4, d21, d1
  202f1c:	1e780039 	fcvtzs	w25, d1
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202f20:	1e620324 	scvtf	d4, w25
  202f24:	1f541481 	fmadd	d1, d4, d20, d5
  202f28:	1e780020 	fcvtzs	w0, d1
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  202f2c:	1e620001 	scvtf	d1, w0
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  202f30:	110ffc00 	add	w0, w0, #0x3ff
  202f34:	9e670005 	fmov	d5, x0
  202f38:	5f7454a5 	shl	d5, d5, #52
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  202f3c:	1e730821 	fmul	d1, d1, d19
  202f40:	1f728481 	fnmsub	d1, d4, d18, d1
  const double z2 = z * z;
  202f44:	1e610824 	fmul	d4, d1, d1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202f48:	1e6138c6 	fsub	d6, d6, d1
  202f4c:	1e612821 	fadd	d1, d1, d1
  202f50:	1e631883 	fdiv	d3, d4, d3
  202f54:	1e672863 	fadd	d3, d3, d7
  202f58:	1e631883 	fdiv	d3, d4, d3
  202f5c:	1e712863 	fadd	d3, d3, d17
  202f60:	1e631884 	fdiv	d4, d4, d3
  202f64:	1e662884 	fadd	d4, d4, d6
  202f68:	1e641821 	fdiv	d1, d1, d4
  202f6c:	1e702821 	fadd	d1, d1, d16
  202f70:	1e650821 	fmul	d1, d1, d5
  // correct for rounding errors
  if (value < conv.F) {
  202f74:	1e612050 	fcmpe	d2, d1
  202f78:	54000be4 	b.mi	2030f4 <_etoa+0x2c4>  // b.first
    expval--;
    conv.F /= 10;
  }

  // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  202f7c:	11018f20 	add	w0, w25, #0x63
  202f80:	7103181f 	cmp	w0, #0xc6
  202f84:	1a9f97fc 	cset	w28, hi	// hi = pmore
  202f88:	1100139c 	add	w28, w28, #0x4

  // in "%g" mode, "prec" is the number of *significant figures* not decimals
  if (flags & FLAGS_ADAPT_EXP) {
  202f8c:	36580134 	tbz	w20, #11, 202fb0 <_etoa+0x180>
    // do we want to fall-back to "%f" mode?
    if ((value >= 1e-4) && (value < 1e6)) {
  202f90:	d0000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  202f94:	fd434403 	ldr	d3, [x0, #1672]
  202f98:	1e632050 	fcmpe	d2, d3
  202f9c:	54000cea 	b.ge	203138 <_etoa+0x308>  // b.tcont
      minwidth = 0U;
      expval   = 0;
    }
    else {
      // we use one sigfig for the whole part
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
  202fa0:	34000084 	cbz	w4, 202fb0 <_etoa+0x180>
        --prec;
  202fa4:	7100007f 	cmp	w3, #0x0
  202fa8:	1a9f07e0 	cset	w0, ne	// ne = any
  202fac:	4b000084 	sub	w4, w4, w0

  // will everything fit?
  unsigned int fwidth = width;
  if (width > minwidth) {
    // we didn't fall-back so subtract the characters required for the exponent
    fwidth -= minwidth;
  202fb0:	6b1c0365 	subs	w5, w27, w28
  } else {
    // not enough characters, so go back to default sizing
    fwidth = 0U;
  }
  if ((flags & FLAGS_LEFT) && minwidth) {
  202fb4:	121f0280 	and	w0, w20, #0x2
    fwidth -= minwidth;
  202fb8:	1a9f80a5 	csel	w5, w5, wzr, hi	// hi = pmore
  if ((flags & FLAGS_LEFT) && minwidth) {
  202fbc:	7100001f 	cmp	w0, #0x0
  202fc0:	1a9f07e0 	cset	w0, ne	// ne = any
  202fc4:	b9007fe0 	str	w0, [sp, #124]
  202fc8:	1a9f00a5 	csel	w5, w5, wzr, eq	// eq = none
    // if we're padding on the right, DON'T pad the floating part
    fwidth = 0U;
  }

  // rescale the float value
  if (expval) {
  202fcc:	5280003a 	mov	w26, #0x1                   	// #1
  202fd0:	34000059 	cbz	w25, 202fd8 <_etoa+0x1a8>
    value /= conv.F;
  202fd4:	1e611842 	fdiv	d2, d2, d1
  }

  // output the floating part
  const size_t start_idx = idx;
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202fd8:	1e602018 	fcmpe	d0, #0.0
  202fdc:	54000aa4 	b.mi	203130 <_etoa+0x300>  // b.first
  202fe0:	1e604040 	fmov	d0, d2
  202fe4:	12147a86 	and	w6, w20, #0xfffff7ff
  202fe8:	aa1703e3 	mov	x3, x23
  202fec:	aa1303e2 	mov	x2, x19
  202ff0:	aa1603e1 	mov	x1, x22
  202ff4:	aa1503e0 	mov	x0, x21
  202ff8:	97fffe8a 	bl	202a20 <_ftoa>
  202ffc:	aa0003f8 	mov	x24, x0

  // output the exponent part
  if (minwidth) {
  203000:	340004fa 	cbz	w26, 20309c <_etoa+0x26c>
    // output the exponential symbol
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  203004:	f27b029f 	tst	x20, #0x20
  203008:	52800ca1 	mov	w1, #0x65                  	// #101
  20300c:	aa1803e2 	mov	x2, x24
  203010:	aa1703e3 	mov	x3, x23
  203014:	528008a0 	mov	w0, #0x45                  	// #69
  203018:	1a800020 	csel	w0, w1, w0, eq	// eq = none
  20301c:	aa1603e1 	mov	x1, x22
  203020:	d63f02a0 	blr	x21
    // output the exponent value
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  203024:	7100033f 	cmp	w25, #0x0
  203028:	528000a0 	mov	w0, #0x5                   	// #5
  20302c:	5a99a724 	cneg	w4, w25, lt	// lt = tstop
  203030:	5100079c 	sub	w28, w28, #0x1
  203034:	b90003fc 	str	w28, [sp]
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  203038:	91000702 	add	x2, x24, #0x1
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  20303c:	b9000be0 	str	w0, [sp, #8]
  203040:	93407c84 	sxtw	x4, w4
  203044:	531f7f25 	lsr	w5, w25, #31
  203048:	aa1703e3 	mov	x3, x23
  20304c:	aa1603e1 	mov	x1, x22
  203050:	aa1503e0 	mov	x0, x21
  203054:	52800007 	mov	w7, #0x0                   	// #0
  203058:	d2800146 	mov	x6, #0xa                   	// #10
  20305c:	97fffd95 	bl	2026b0 <_ntoa_long>
  203060:	aa0003f8 	mov	x24, x0
    // might need to right-pad spaces
    if (flags & FLAGS_LEFT) {
  203064:	b9407fe0 	ldr	w0, [sp, #124]
  203068:	340001a0 	cbz	w0, 20309c <_etoa+0x26c>
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
  20306c:	cb130313 	sub	x19, x24, x19
  203070:	eb13037f 	cmp	x27, x19
  203074:	54000149 	b.ls	20309c <_etoa+0x26c>  // b.plast
  203078:	aa1803e2 	mov	x2, x24
  20307c:	91000673 	add	x19, x19, #0x1
  203080:	aa1703e3 	mov	x3, x23
  203084:	aa1603e1 	mov	x1, x22
  203088:	52800400 	mov	w0, #0x20                  	// #32
  20308c:	d63f02a0 	blr	x21
  203090:	91000718 	add	x24, x24, #0x1
  203094:	eb1b027f 	cmp	x19, x27
  203098:	54ffff03 	b.cc	203078 <_etoa+0x248>  // b.lo, b.ul, b.last
    }
  }
  return idx;
}
  20309c:	a9417bfd 	ldp	x29, x30, [sp, #16]
  2030a0:	aa1803e0 	mov	x0, x24
  2030a4:	a94253f3 	ldp	x19, x20, [sp, #32]
  2030a8:	a9435bf5 	ldp	x21, x22, [sp, #48]
  2030ac:	a94463f7 	ldp	x23, x24, [sp, #64]
  2030b0:	a9456bf9 	ldp	x25, x26, [sp, #80]
  2030b4:	a94673fb 	ldp	x27, x28, [sp, #96]
  2030b8:	910203ff 	add	sp, sp, #0x80
  2030bc:	d65f03c0 	ret
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  2030c0:	2a1403e6 	mov	w6, w20
  2030c4:	2a1b03e5 	mov	w5, w27
  2030c8:	aa1703e3 	mov	x3, x23
  2030cc:	aa1303e2 	mov	x2, x19
  2030d0:	aa1603e1 	mov	x1, x22
  2030d4:	aa1503e0 	mov	x0, x21
}
  2030d8:	a9417bfd 	ldp	x29, x30, [sp, #16]
  2030dc:	a94253f3 	ldp	x19, x20, [sp, #32]
  2030e0:	a9435bf5 	ldp	x21, x22, [sp, #48]
  2030e4:	a94463f7 	ldp	x23, x24, [sp, #64]
  2030e8:	a94673fb 	ldp	x27, x28, [sp, #96]
  2030ec:	910203ff 	add	sp, sp, #0x80
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  2030f0:	17fffe4c 	b	202a20 <_ftoa>
    conv.F /= 10;
  2030f4:	1e671821 	fdiv	d1, d1, d7
    expval--;
  2030f8:	51000739 	sub	w25, w25, #0x1
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  2030fc:	11018f20 	add	w0, w25, #0x63
  203100:	7103181f 	cmp	w0, #0xc6
  203104:	1a9f97fc 	cset	w28, hi	// hi = pmore
  203108:	1100139c 	add	w28, w28, #0x4
  if (flags & FLAGS_ADAPT_EXP) {
  20310c:	365ff534 	tbz	w20, #11, 202fb0 <_etoa+0x180>
  203110:	17ffffa0 	b	202f90 <_etoa+0x160>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  203114:	2a0103f4 	mov	w20, w1
    fwidth = 0U;
  203118:	52800005 	mov	w5, #0x0                   	// #0
      minwidth = 0U;
  20311c:	5280001c 	mov	w28, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  203120:	5280001a 	mov	w26, #0x0                   	// #0
      expval   = 0;
  203124:	52800019 	mov	w25, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  203128:	b9007fff 	str	wzr, [sp, #124]
  20312c:	d503201f 	nop
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  203130:	1e614042 	fneg	d2, d2
  203134:	17ffffab 	b	202fe0 <_etoa+0x1b0>
    if ((value >= 1e-4) && (value < 1e6)) {
  203138:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  20313c:	f2e825c0 	movk	x0, #0x412e, lsl #48
  203140:	9e670003 	fmov	d3, x0
  203144:	1e632050 	fcmpe	d2, d3
  203148:	54000044 	b.mi	203150 <_etoa+0x320>  // b.first
  20314c:	17ffff95 	b	202fa0 <_etoa+0x170>
        prec = (unsigned)((int)prec - expval - 1);
  203150:	4b190080 	sub	w0, w4, w25
  203154:	6b04033f 	cmp	w25, w4
  203158:	51000400 	sub	w0, w0, #0x1
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  20315c:	32160281 	orr	w1, w20, #0x400
        prec = (unsigned)((int)prec - expval - 1);
  203160:	1a9fb004 	csel	w4, w0, wzr, lt	// lt = tstop
  if (width > minwidth) {
  203164:	350001bb 	cbnz	w27, 203198 <_etoa+0x368>
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  203168:	1e602018 	fcmpe	d0, #0.0
  20316c:	54fffd44 	b.mi	203114 <_etoa+0x2e4>  // b.first
  203170:	12147a86 	and	w6, w20, #0xfffff7ff
  203174:	1e604040 	fmov	d0, d2
  203178:	a9456bf9 	ldp	x25, x26, [sp, #80]
  20317c:	321600c6 	orr	w6, w6, #0x400
  203180:	aa1703e3 	mov	x3, x23
  203184:	aa1303e2 	mov	x2, x19
  203188:	aa1603e1 	mov	x1, x22
  20318c:	aa1503e0 	mov	x0, x21
  203190:	52800005 	mov	w5, #0x0                   	// #0
  203194:	17ffffd1 	b	2030d8 <_etoa+0x2a8>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  203198:	2a0103f4 	mov	w20, w1
  if (width > minwidth) {
  20319c:	2a1b03e5 	mov	w5, w27
      minwidth = 0U;
  2031a0:	5280001c 	mov	w28, #0x0                   	// #0
  if (width > minwidth) {
  2031a4:	52800019 	mov	w25, #0x0                   	// #0
  2031a8:	5280001a 	mov	w26, #0x0                   	// #0
  2031ac:	b9007fff 	str	wzr, [sp, #124]
  2031b0:	17ffff8a 	b	202fd8 <_etoa+0x1a8>
  2031b4:	d503201f 	nop
  2031b8:	d503201f 	nop
  2031bc:	d503201f 	nop

00000000002031c0 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
  2031c0:	d102c3ff 	sub	sp, sp, #0xb0
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
  2031c4:	f100003f 	cmp	x1, #0x0
{
  2031c8:	a9017bfd 	stp	x29, x30, [sp, #16]
  2031cc:	910043fd 	add	x29, sp, #0x10
  2031d0:	a90253f3 	stp	x19, x20, [sp, #32]
    out = _out_null;
  2031d4:	f0fffff3 	adrp	x19, 202000 <init+0x6e0>
  2031d8:	91164273 	add	x19, x19, #0x590
{
  2031dc:	a9035bf5 	stp	x21, x22, [sp, #48]
    out = _out_null;
  2031e0:	9a800273 	csel	x19, x19, x0, eq	// eq = none
{
  2031e4:	aa0103f5 	mov	x21, x1
  2031e8:	a90463f7 	stp	x23, x24, [sp, #64]
  2031ec:	aa0203f4 	mov	x20, x2
  2031f0:	b9401898 	ldr	w24, [x4, #24]
  2031f4:	a90673fb 	stp	x27, x28, [sp, #96]
  }

  while (*format)
  2031f8:	d280001c 	mov	x28, #0x0                   	// #0
  2031fc:	f9400880 	ldr	x0, [x4, #16]
  203200:	f9004fe0 	str	x0, [sp, #152]
  203204:	39400061 	ldrb	w1, [x3]
  203208:	a9400896 	ldp	x22, x2, [x4]
  20320c:	f90047e2 	str	x2, [sp, #136]
  203210:	b9401c80 	ldr	w0, [x4, #28]
  203214:	b90077e0 	str	w0, [sp, #116]
  203218:	34004141 	cbz	w1, 203a40 <_vsnprintf+0x880>
      default :
        break;
    }

    // evaluate specifier
    switch (*format) {
  20321c:	d280003b 	mov	x27, #0x1                   	// #1
  203220:	a9056bf9 	stp	x25, x26, [sp, #80]
  203224:	b0000019 	adrp	x25, 204000 <sddf_sprintf_+0x70>
  203228:	910b0320 	add	x0, x25, #0x2c0
  20322c:	aa0303fa 	mov	x26, x3
  203230:	f9003fe0 	str	x0, [sp, #120]
  203234:	1400000a 	b	20325c <_vsnprintf+0x9c>
      out(*format, buffer, idx++, maxlen);
  203238:	91000784 	add	x4, x28, #0x1
  20323c:	2a0103e0 	mov	w0, w1
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
  203240:	aa1c03e2 	mov	x2, x28
  203244:	aa1403e3 	mov	x3, x20
  203248:	aa1503e1 	mov	x1, x21
  20324c:	aa0403fc 	mov	x28, x4
  203250:	d63f0260 	blr	x19
  while (*format)
  203254:	39400341 	ldrb	w1, [x26]
  203258:	34000cc1 	cbz	w1, 2033f0 <_vsnprintf+0x230>
      format++;
  20325c:	9100075a 	add	x26, x26, #0x1
    if (*format != '%') {
  203260:	7100943f 	cmp	w1, #0x25
  203264:	54fffea1 	b.ne	203238 <_vsnprintf+0x78>  // b.any
      switch (*format) {
  203268:	aa1a03e1 	mov	x1, x26
    flags = 0U;
  20326c:	52800006 	mov	w6, #0x0                   	// #0
      switch (*format) {
  203270:	38401420 	ldrb	w0, [x1], #1
  203274:	7100ac1f 	cmp	w0, #0x2b
  203278:	540001a0 	b.eq	2032ac <_vsnprintf+0xec>  // b.none
  20327c:	d503201f 	nop
  203280:	540001c8 	b.hi	2032b8 <_vsnprintf+0xf8>  // b.pmore
  203284:	7100801f 	cmp	w0, #0x20
  203288:	54000260 	b.eq	2032d4 <_vsnprintf+0x114>  // b.none
  20328c:	71008c1f 	cmp	w0, #0x23
  203290:	540002e1 	b.ne	2032ec <_vsnprintf+0x12c>  // b.any
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
  203294:	321c00c6 	orr	w6, w6, #0x10
      format++;
  203298:	aa0103fa 	mov	x26, x1
      switch (*format) {
  20329c:	aa1a03e1 	mov	x1, x26
  2032a0:	38401420 	ldrb	w0, [x1], #1
  2032a4:	7100ac1f 	cmp	w0, #0x2b
  2032a8:	54fffec1 	b.ne	203280 <_vsnprintf+0xc0>  // b.any
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
  2032ac:	321e00c6 	orr	w6, w6, #0x4
      format++;
  2032b0:	aa0103fa 	mov	x26, x1
  2032b4:	17fffffa 	b	20329c <_vsnprintf+0xdc>
      switch (*format) {
  2032b8:	7100b41f 	cmp	w0, #0x2d
  2032bc:	54000120 	b.eq	2032e0 <_vsnprintf+0x120>  // b.none
  2032c0:	7100c01f 	cmp	w0, #0x30
  2032c4:	54005fe1 	b.ne	203ec0 <_vsnprintf+0xd00>  // b.any
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
  2032c8:	320000c6 	orr	w6, w6, #0x1
      format++;
  2032cc:	aa0103fa 	mov	x26, x1
  2032d0:	17fffff3 	b	20329c <_vsnprintf+0xdc>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
  2032d4:	321d00c6 	orr	w6, w6, #0x8
      format++;
  2032d8:	aa0103fa 	mov	x26, x1
  2032dc:	17fffff0 	b	20329c <_vsnprintf+0xdc>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
  2032e0:	321f00c6 	orr	w6, w6, #0x2
      format++;
  2032e4:	aa0103fa 	mov	x26, x1
  2032e8:	17ffffed 	b	20329c <_vsnprintf+0xdc>
    else if (*format == '*') {
  2032ec:	7100a81f 	cmp	w0, #0x2a
  2032f0:	54000ae0 	b.eq	20344c <_vsnprintf+0x28c>  // b.none
    width = 0U;
  2032f4:	52800019 	mov	w25, #0x0                   	// #0
    precision = 0U;
  2032f8:	52800017 	mov	w23, #0x0                   	// #0
    switch (*format) {
  2032fc:	7101b01f 	cmp	w0, #0x6c
        format++;
  203300:	aa0103e2 	mov	x2, x1
    switch (*format) {
  203304:	54000de0 	b.eq	2034c0 <_vsnprintf+0x300>  // b.none
  203308:	54000969 	b.ls	203434 <_vsnprintf+0x274>  // b.plast
  20330c:	7101d01f 	cmp	w0, #0x74
  203310:	54000060 	b.eq	20331c <_vsnprintf+0x15c>  // b.none
  203314:	7101e81f 	cmp	w0, #0x7a
  203318:	54000241 	b.ne	203360 <_vsnprintf+0x1a0>  // b.any
        if (*format == 'l') {
  20331c:	39400740 	ldrb	w0, [x26, #1]
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  203320:	321800c6 	orr	w6, w6, #0x100
        format++;
  203324:	9100045a 	add	x26, x2, #0x1
    switch (*format) {
  203328:	71019c1f 	cmp	w0, #0x67
  20332c:	540001e8 	b.hi	203368 <_vsnprintf+0x1a8>  // b.pmore
  203330:	7100901f 	cmp	w0, #0x24
  203334:	54000089 	b.ls	203344 <_vsnprintf+0x184>  // b.plast
  203338:	51009401 	sub	w1, w0, #0x25
  20333c:	7101083f 	cmp	w1, #0x42
  203340:	54000069 	b.ls	20334c <_vsnprintf+0x18c>  // b.plast
        out(*format, buffer, idx++, maxlen);
  203344:	91000784 	add	x4, x28, #0x1
  203348:	17ffffbe 	b	203240 <_vsnprintf+0x80>
    switch (*format) {
  20334c:	f9403fe2 	ldr	x2, [sp, #120]
  203350:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
  203354:	10000062 	adr	x2, 203360 <_vsnprintf+0x1a0>
  203358:	8b21a841 	add	x1, x2, w1, sxth #2
  20335c:	d61f0020 	br	x1
        format++;
  203360:	aa0103fa 	mov	x26, x1
  203364:	d503201f 	nop
    switch (*format) {
  203368:	5101a401 	sub	w1, w0, #0x69
  20336c:	12001c21 	and	w1, w1, #0xff
  203370:	71003c3f 	cmp	w1, #0xf
  203374:	54fffe88 	b.hi	203344 <_vsnprintf+0x184>  // b.pmore
  203378:	9ac12362 	lsl	x2, x27, x1
  20337c:	d2920823 	mov	x3, #0x9041                	// #36929
  203380:	ea03005f 	tst	x2, x3
  203384:	54003021 	b.ne	203988 <_vsnprintf+0x7c8>  // b.any
  203388:	7100283f 	cmp	w1, #0xa
  20338c:	540014a0 	b.eq	203620 <_vsnprintf+0x460>  // b.none
  203390:	71001c3f 	cmp	w1, #0x7
  203394:	54fffd81 	b.ne	203344 <_vsnprintf+0x184>  // b.any
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
  203398:	52800420 	mov	w0, #0x21                  	// #33
  20339c:	2a0000c0 	orr	w0, w6, w0
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2033a0:	37f820f8 	tbnz	w24, #31, 2037bc <_vsnprintf+0x5fc>
  2033a4:	91003ec2 	add	x2, x22, #0xf
  2033a8:	aa1603e1 	mov	x1, x22
  2033ac:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2033b0:	2a1703e7 	mov	w7, w23
  2033b4:	aa1c03e2 	mov	x2, x28
  2033b8:	f9400024 	ldr	x4, [x1]
  2033bc:	d2800206 	mov	x6, #0x10                  	// #16
  2033c0:	52800201 	mov	w1, #0x10                  	// #16
  2033c4:	b90003e1 	str	w1, [sp]
  2033c8:	b9000be0 	str	w0, [sp, #8]
  2033cc:	52800005 	mov	w5, #0x0                   	// #0
  2033d0:	aa1503e1 	mov	x1, x21
  2033d4:	aa1403e3 	mov	x3, x20
  2033d8:	aa1303e0 	mov	x0, x19
  2033dc:	97fffcb5 	bl	2026b0 <_ntoa_long>
  while (*format)
  2033e0:	39400341 	ldrb	w1, [x26]
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2033e4:	aa0003fc 	mov	x28, x0
  while (*format)
  2033e8:	35fff3a1 	cbnz	w1, 20325c <_vsnprintf+0x9c>
  2033ec:	d503201f 	nop
  2033f0:	a9456bf9 	ldp	x25, x26, [sp, #80]

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
  2033f4:	2a1c03f6 	mov	w22, w28
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
  2033f8:	eb1c029f 	cmp	x20, x28
  2033fc:	d1000682 	sub	x2, x20, #0x1
  203400:	aa1503e1 	mov	x1, x21
  203404:	9a9c9042 	csel	x2, x2, x28, ls	// ls = plast
  203408:	aa1403e3 	mov	x3, x20
  20340c:	52800000 	mov	w0, #0x0                   	// #0
  203410:	d63f0260 	blr	x19
}
  203414:	a9417bfd 	ldp	x29, x30, [sp, #16]
  203418:	2a1603e0 	mov	w0, w22
  20341c:	a94253f3 	ldp	x19, x20, [sp, #32]
  203420:	a9435bf5 	ldp	x21, x22, [sp, #48]
  203424:	a94463f7 	ldp	x23, x24, [sp, #64]
  203428:	a94673fb 	ldp	x27, x28, [sp, #96]
  20342c:	9102c3ff 	add	sp, sp, #0xb0
  203430:	d65f03c0 	ret
    switch (*format) {
  203434:	7101a01f 	cmp	w0, #0x68
  203438:	54000ea0 	b.eq	20360c <_vsnprintf+0x44c>  // b.none
  20343c:	7101a81f 	cmp	w0, #0x6a
  203440:	54fff6e0 	b.eq	20331c <_vsnprintf+0x15c>  // b.none
  203444:	aa1a03e2 	mov	x2, x26
  203448:	17ffffb7 	b	203324 <_vsnprintf+0x164>
      const int w = va_arg(va, int);
  20344c:	37f80498 	tbnz	w24, #31, 2034dc <_vsnprintf+0x31c>
  203450:	91002ec2 	add	x2, x22, #0xb
  203454:	aa1603e0 	mov	x0, x22
  203458:	927df056 	and	x22, x2, #0xfffffffffffffff8
  20345c:	b9400019 	ldr	w25, [x0]
      if (w < 0) {
  203460:	36f80079 	tbz	w25, #31, 20346c <_vsnprintf+0x2ac>
        flags |= FLAGS_LEFT;    // reverse padding
  203464:	321f00c6 	orr	w6, w6, #0x2
        width = (unsigned int)-w;
  203468:	4b1903f9 	neg	w25, w25
    if (*format == '.') {
  20346c:	39400740 	ldrb	w0, [x26, #1]
      format++;
  203470:	aa0103fa 	mov	x26, x1
  203474:	91000421 	add	x1, x1, #0x1
    if (*format == '.') {
  203478:	7100b81f 	cmp	w0, #0x2e
    precision = 0U;
  20347c:	52800017 	mov	w23, #0x0                   	// #0
    if (*format == '.') {
  203480:	54fff3e1 	b.ne	2032fc <_vsnprintf+0x13c>  // b.any
      if (_is_digit(*format)) {
  203484:	39400740 	ldrb	w0, [x26, #1]
      flags |= FLAGS_PRECISION;
  203488:	321600c6 	orr	w6, w6, #0x400
      format++;
  20348c:	aa0103e2 	mov	x2, x1
  return (ch >= '0') && (ch <= '9');
  203490:	5100c003 	sub	w3, w0, #0x30
      if (_is_digit(*format)) {
  203494:	12001c63 	and	w3, w3, #0xff
  203498:	7100247f 	cmp	w3, #0x9
  20349c:	54001489 	b.ls	20372c <_vsnprintf+0x56c>  // b.plast
      else if (*format == '*') {
  2034a0:	7100a81f 	cmp	w0, #0x2a
  2034a4:	540025c0 	b.eq	20395c <_vsnprintf+0x79c>  // b.none
      format++;
  2034a8:	aa0103fa 	mov	x26, x1
  2034ac:	91000421 	add	x1, x1, #0x1
    switch (*format) {
  2034b0:	7101b01f 	cmp	w0, #0x6c
        format++;
  2034b4:	aa0103e2 	mov	x2, x1
    switch (*format) {
  2034b8:	54fff281 	b.ne	203308 <_vsnprintf+0x148>  // b.any
  2034bc:	d503201f 	nop
        if (*format == 'l') {
  2034c0:	39400740 	ldrb	w0, [x26, #1]
  2034c4:	7101b01f 	cmp	w0, #0x6c
  2034c8:	54fff2c1 	b.ne	203320 <_vsnprintf+0x160>  // b.any
    switch (*format) {
  2034cc:	39400b40 	ldrb	w0, [x26, #2]
          flags |= FLAGS_LONG_LONG;
  2034d0:	321804c6 	orr	w6, w6, #0x300
          format++;
  2034d4:	91000b42 	add	x2, x26, #0x2
  2034d8:	17ffff93 	b	203324 <_vsnprintf+0x164>
      const int w = va_arg(va, int);
  2034dc:	11002302 	add	w2, w24, #0x8
  2034e0:	7100005f 	cmp	w2, #0x0
  2034e4:	540018ed 	b.le	203800 <_vsnprintf+0x640>
  2034e8:	91002ec3 	add	x3, x22, #0xb
  2034ec:	aa1603e0 	mov	x0, x22
  2034f0:	2a0203f8 	mov	w24, w2
  2034f4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  2034f8:	17ffffd9 	b	20345c <_vsnprintf+0x29c>
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  2034fc:	121a7801 	and	w1, w0, #0xffffffdf
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  203500:	121e7800 	and	w0, w0, #0xfffffffd
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  203504:	71011c3f 	cmp	w1, #0x47
  203508:	321500c1 	orr	w1, w6, #0x800
  20350c:	1a860026 	csel	w6, w1, w6, eq	// eq = none
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  203510:	7101141f 	cmp	w0, #0x45
  203514:	321b00c0 	orr	w0, w6, #0x20
  203518:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  20351c:	b94077e0 	ldr	w0, [sp, #116]
  203520:	37f815e0 	tbnz	w0, #31, 2037dc <_vsnprintf+0x61c>
  203524:	91003ec1 	add	x1, x22, #0xf
  203528:	aa1603e0 	mov	x0, x22
  20352c:	927df036 	and	x22, x1, #0xfffffffffffffff8
  203530:	fd400000 	ldr	d0, [x0]
  203534:	aa1c03e2 	mov	x2, x28
  203538:	2a1903e5 	mov	w5, w25
  20353c:	2a1703e4 	mov	w4, w23
  203540:	aa1403e3 	mov	x3, x20
  203544:	aa1503e1 	mov	x1, x21
  203548:	aa1303e0 	mov	x0, x19
  20354c:	97fffe39 	bl	202e30 <_etoa>
  203550:	aa0003fc 	mov	x28, x0
        break;
  203554:	17ffff40 	b	203254 <_vsnprintf+0x94>
        if (*format == 'F') flags |= FLAGS_UPPERCASE;
  203558:	7101181f 	cmp	w0, #0x46
  20355c:	321b00c0 	orr	w0, w6, #0x20
  203560:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  203564:	b94077e0 	ldr	w0, [sp, #116]
  203568:	37f81180 	tbnz	w0, #31, 203798 <_vsnprintf+0x5d8>
  20356c:	91003ec1 	add	x1, x22, #0xf
  203570:	aa1603e0 	mov	x0, x22
  203574:	927df036 	and	x22, x1, #0xfffffffffffffff8
  203578:	fd400000 	ldr	d0, [x0]
  20357c:	aa1c03e2 	mov	x2, x28
  203580:	2a1903e5 	mov	w5, w25
  203584:	2a1703e4 	mov	w4, w23
  203588:	aa1403e3 	mov	x3, x20
  20358c:	aa1503e1 	mov	x1, x21
  203590:	aa1303e0 	mov	x0, x19
  203594:	97fffd23 	bl	202a20 <_ftoa>
  203598:	aa0003fc 	mov	x28, x0
        break;
  20359c:	17ffff2e 	b	203254 <_vsnprintf+0x94>
        unsigned int l = 1U;
  2035a0:	52800020 	mov	w0, #0x1                   	// #1
  2035a4:	b90083e0 	str	w0, [sp, #128]
        if (!(flags & FLAGS_LEFT)) {
  2035a8:	121f00c0 	and	w0, w6, #0x2
  2035ac:	b90093e0 	str	w0, [sp, #144]
  2035b0:	36081ac6 	tbz	w6, #1, 203908 <_vsnprintf+0x748>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  2035b4:	37f80d38 	tbnz	w24, #31, 203758 <_vsnprintf+0x598>
  2035b8:	91002ec1 	add	x1, x22, #0xb
  2035bc:	aa1603e0 	mov	x0, x22
  2035c0:	927df036 	and	x22, x1, #0xfffffffffffffff8
  2035c4:	39400000 	ldrb	w0, [x0]
  2035c8:	aa1403e3 	mov	x3, x20
  2035cc:	aa1c03e2 	mov	x2, x28
  2035d0:	aa1503e1 	mov	x1, x21
  2035d4:	91000797 	add	x23, x28, #0x1
  2035d8:	d63f0260 	blr	x19
        if (flags & FLAGS_LEFT) {
  2035dc:	b94093e0 	ldr	w0, [sp, #144]
  2035e0:	35001700 	cbnz	w0, 2038c0 <_vsnprintf+0x700>
        break;
  2035e4:	aa1703fc 	mov	x28, x23
  2035e8:	17ffff1b 	b	203254 <_vsnprintf+0x94>
        out('%', buffer, idx++, maxlen);
  2035ec:	91000780 	add	x0, x28, #0x1
  2035f0:	aa1c03e2 	mov	x2, x28
  2035f4:	aa1403e3 	mov	x3, x20
  2035f8:	aa0003fc 	mov	x28, x0
  2035fc:	aa1503e1 	mov	x1, x21
  203600:	528004a0 	mov	w0, #0x25                  	// #37
  203604:	d63f0260 	blr	x19
        break;
  203608:	17ffff13 	b	203254 <_vsnprintf+0x94>
        if (*format == 'h') {
  20360c:	39400740 	ldrb	w0, [x26, #1]
  203610:	7101a01f 	cmp	w0, #0x68
  203614:	54002020 	b.eq	203a18 <_vsnprintf+0x858>  // b.none
        flags |= FLAGS_SHORT;
  203618:	321900c6 	orr	w6, w6, #0x80
  20361c:	17ffff42 	b	203324 <_vsnprintf+0x164>
        const char* p = va_arg(va, char*);
  203620:	37f80ad8 	tbnz	w24, #31, 203778 <_vsnprintf+0x5b8>
  203624:	91003ec1 	add	x1, x22, #0xf
  203628:	aa1603e0 	mov	x0, x22
  20362c:	927df036 	and	x22, x1, #0xfffffffffffffff8
  203630:	f940000a 	ldr	x10, [x0]
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
  203634:	710002ff 	cmp	w23, #0x0
  203638:	2a1703e3 	mov	w3, w23
  20363c:	da9f1063 	csinv	x3, x3, xzr, ne	// ne = any
  for (s = str; *s && maxsize--; ++s);
  203640:	39400140 	ldrb	w0, [x10]
  203644:	34003500 	cbz	w0, 203ce4 <_vsnprintf+0xb24>
  203648:	8b030143 	add	x3, x10, x3
  20364c:	aa0a03e1 	mov	x1, x10
  203650:	14000003 	b	20365c <_vsnprintf+0x49c>
  203654:	eb03003f 	cmp	x1, x3
  203658:	54000060 	b.eq	203664 <_vsnprintf+0x4a4>  // b.none
  20365c:	38401c22 	ldrb	w2, [x1, #1]!
  203660:	35ffffa2 	cbnz	w2, 203654 <_vsnprintf+0x494>
  return (unsigned int)(s - str);
  203664:	4b0a0021 	sub	w1, w1, w10
  203668:	b90093e1 	str	w1, [sp, #144]
        if (flags & FLAGS_PRECISION) {
  20366c:	121600c1 	and	w1, w6, #0x400
  203670:	b900abe1 	str	w1, [sp, #168]
  203674:	365000a6 	tbz	w6, #10, 203688 <_vsnprintf+0x4c8>
          l = (l < precision ? l : precision);
  203678:	b94093e1 	ldr	w1, [sp, #144]
  20367c:	6b17003f 	cmp	w1, w23
  203680:	1a979021 	csel	w1, w1, w23, ls	// ls = plast
  203684:	b90093e1 	str	w1, [sp, #144]
        if (!(flags & FLAGS_LEFT)) {
  203688:	121f00c1 	and	w1, w6, #0x2
  20368c:	b900afe1 	str	w1, [sp, #172]
  203690:	36081f26 	tbz	w6, #1, 203a74 <_vsnprintf+0x8b4>
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  203694:	340002a0 	cbz	w0, 2036e8 <_vsnprintf+0x528>
  203698:	b940abe1 	ldr	w1, [sp, #168]
  20369c:	34001aa1 	cbz	w1, 2039f0 <_vsnprintf+0x830>
  2036a0:	8b374381 	add	x1, x28, w23, uxtw
            out(' ', buffer, idx++, maxlen);
  2036a4:	aa1c03e2 	mov	x2, x28
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2036a8:	cb1c0157 	sub	x23, x10, x28
  2036ac:	f90043e1 	str	x1, [sp, #128]
  2036b0:	14000008 	b	2036d0 <_vsnprintf+0x510>
          out(*(p++), buffer, idx++, maxlen);
  2036b4:	9100045c 	add	x28, x2, #0x1
  2036b8:	aa1403e3 	mov	x3, x20
  2036bc:	aa1503e1 	mov	x1, x21
  2036c0:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2036c4:	387c6ae0 	ldrb	w0, [x23, x28]
  2036c8:	340000c0 	cbz	w0, 2036e0 <_vsnprintf+0x520>
          out(*(p++), buffer, idx++, maxlen);
  2036cc:	aa1c03e2 	mov	x2, x28
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2036d0:	f94043e1 	ldr	x1, [sp, #128]
  2036d4:	eb02003f 	cmp	x1, x2
  2036d8:	54fffee1 	b.ne	2036b4 <_vsnprintf+0x4f4>  // b.any
  2036dc:	aa0103fc 	mov	x28, x1
        if (flags & FLAGS_LEFT) {
  2036e0:	b940afe0 	ldr	w0, [sp, #172]
  2036e4:	34ffdb80 	cbz	w0, 203254 <_vsnprintf+0x94>
          while (l++ < width) {
  2036e8:	b94093e1 	ldr	w1, [sp, #144]
  2036ec:	aa1c03f7 	mov	x23, x28
  2036f0:	6b19003f 	cmp	w1, w25
  2036f4:	54ffdb02 	b.cs	203254 <_vsnprintf+0x94>  // b.hs, b.nlast
  2036f8:	51000720 	sub	w0, w25, #0x1
  2036fc:	91000789 	add	x9, x28, #0x1
  203700:	4b010000 	sub	w0, w0, w1
  203704:	8b09001c 	add	x28, x0, x9
            out(' ', buffer, idx++, maxlen);
  203708:	aa1703e2 	mov	x2, x23
  20370c:	aa1403e3 	mov	x3, x20
  203710:	910006f7 	add	x23, x23, #0x1
  203714:	aa1503e1 	mov	x1, x21
  203718:	52800400 	mov	w0, #0x20                  	// #32
  20371c:	d63f0260 	blr	x19
          while (l++ < width) {
  203720:	eb1c02ff 	cmp	x23, x28
  203724:	54ffff21 	b.ne	203708 <_vsnprintf+0x548>  // b.any
  203728:	17fffecb 	b	203254 <_vsnprintf+0x94>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20372c:	52800143 	mov	w3, #0xa                   	// #10
  203730:	1b0302e7 	madd	w7, w23, w3, w0
  while (_is_digit(**str)) {
  203734:	38401c40 	ldrb	w0, [x2, #1]!
  return (ch >= '0') && (ch <= '9');
  203738:	5100c001 	sub	w1, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20373c:	5100c0f7 	sub	w23, w7, #0x30
  while (_is_digit(**str)) {
  203740:	12001c21 	and	w1, w1, #0xff
  203744:	7100243f 	cmp	w1, #0x9
  203748:	54ffff49 	b.ls	203730 <_vsnprintf+0x570>  // b.plast
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20374c:	aa0203fa 	mov	x26, x2
  203750:	91000441 	add	x1, x2, #0x1
  203754:	17fffeea 	b	2032fc <_vsnprintf+0x13c>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  203758:	11002301 	add	w1, w24, #0x8
  20375c:	7100003f 	cmp	w1, #0x0
  203760:	540024ed 	b.le	203bfc <_vsnprintf+0xa3c>
  203764:	91002ec2 	add	x2, x22, #0xb
  203768:	aa1603e0 	mov	x0, x22
  20376c:	2a0103f8 	mov	w24, w1
  203770:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203774:	17ffff94 	b	2035c4 <_vsnprintf+0x404>
        const char* p = va_arg(va, char*);
  203778:	11002301 	add	w1, w24, #0x8
  20377c:	7100003f 	cmp	w1, #0x0
  203780:	540021ad 	b.le	203bb4 <_vsnprintf+0x9f4>
  203784:	91003ec2 	add	x2, x22, #0xf
  203788:	aa1603e0 	mov	x0, x22
  20378c:	2a0103f8 	mov	w24, w1
  203790:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203794:	17ffffa7 	b	203630 <_vsnprintf+0x470>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  203798:	b94077e0 	ldr	w0, [sp, #116]
  20379c:	11004001 	add	w1, w0, #0x10
  2037a0:	7100003f 	cmp	w1, #0x0
  2037a4:	5400218d 	b.le	203bd4 <_vsnprintf+0xa14>
  2037a8:	91003ec2 	add	x2, x22, #0xf
  2037ac:	aa1603e0 	mov	x0, x22
  2037b0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2037b4:	b90077e1 	str	w1, [sp, #116]
  2037b8:	17ffff70 	b	203578 <_vsnprintf+0x3b8>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2037bc:	11002302 	add	w2, w24, #0x8
  2037c0:	7100005f 	cmp	w2, #0x0
  2037c4:	5400200d 	b.le	203bc4 <_vsnprintf+0xa04>
  2037c8:	91003ec3 	add	x3, x22, #0xf
  2037cc:	aa1603e1 	mov	x1, x22
  2037d0:	2a0203f8 	mov	w24, w2
  2037d4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  2037d8:	17fffef6 	b	2033b0 <_vsnprintf+0x1f0>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  2037dc:	b94077e0 	ldr	w0, [sp, #116]
  2037e0:	11004001 	add	w1, w0, #0x10
  2037e4:	7100003f 	cmp	w1, #0x0
  2037e8:	5400200d 	b.le	203be8 <_vsnprintf+0xa28>
  2037ec:	91003ec2 	add	x2, x22, #0xf
  2037f0:	aa1603e0 	mov	x0, x22
  2037f4:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2037f8:	b90077e1 	str	w1, [sp, #116]
  2037fc:	17ffff4d 	b	203530 <_vsnprintf+0x370>
      const int w = va_arg(va, int);
  203800:	f94047e0 	ldr	x0, [sp, #136]
  203804:	8b38c000 	add	x0, x0, w24, sxtw
  203808:	2a0203f8 	mov	w24, w2
  20380c:	17ffff14 	b	20345c <_vsnprintf+0x29c>
        if (*format == 'x' || *format == 'X') {
  203810:	121a7801 	and	w1, w0, #0xffffffdf
  203814:	7101603f 	cmp	w1, #0x58
  203818:	54001080 	b.eq	203a28 <_vsnprintf+0x868>  // b.none
        else if (*format == 'b') {
  20381c:	7101881f 	cmp	w0, #0x62
  203820:	54001920 	b.eq	203b44 <_vsnprintf+0x984>  // b.none
        if ((*format != 'i') && (*format != 'd')) {
  203824:	52800c81 	mov	w1, #0x64                  	// #100
  203828:	7101a41f 	cmp	w0, #0x69
  20382c:	7a411004 	ccmp	w0, w1, #0x4, ne	// ne = any
          flags &= ~FLAGS_HASH;   // no hash for dec format
  203830:	121b78c6 	and	w6, w6, #0xffffffef
        if ((*format != 'i') && (*format != 'd')) {
  203834:	d2800141 	mov	x1, #0xa                   	// #10
  203838:	54000b41 	b.ne	2039a0 <_vsnprintf+0x7e0>  // b.any
          flags &= ~FLAGS_ZEROPAD;
  20383c:	f27600df 	tst	x6, #0x400
  203840:	121f78c2 	and	w2, w6, #0xfffffffe
  203844:	1a861046 	csel	w6, w2, w6, ne	// ne = any
        if ((*format == 'i') || (*format == 'd')) {
  203848:	7101a41f 	cmp	w0, #0x69
  20384c:	52800c82 	mov	w2, #0x64                  	// #100
          if (flags & FLAGS_LONG_LONG) {
  203850:	121700c3 	and	w3, w6, #0x200
        if ((*format == 'i') || (*format == 'd')) {
  203854:	7a421004 	ccmp	w0, w2, #0x4, ne	// ne = any
  203858:	54000b81 	b.ne	2039c8 <_vsnprintf+0x808>  // b.any
          if (flags & FLAGS_LONG_LONG) {
  20385c:	35001903 	cbnz	w3, 203b7c <_vsnprintf+0x9bc>
          else if (flags & FLAGS_LONG) {
  203860:	37401d66 	tbnz	w6, #8, 203c0c <_vsnprintf+0xa4c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203864:	37301626 	tbnz	w6, #6, 203b28 <_vsnprintf+0x968>
  203868:	363822e6 	tbz	w6, #7, 203cc4 <_vsnprintf+0xb04>
  20386c:	37f82d58 	tbnz	w24, #31, 203e14 <_vsnprintf+0xc54>
  203870:	91002ec2 	add	x2, x22, #0xb
  203874:	aa1603e0 	mov	x0, x22
  203878:	927df056 	and	x22, x2, #0xfffffffffffffff8
  20387c:	79c00005 	ldrsh	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  203880:	710000bf 	cmp	w5, #0x0
  203884:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  203888:	12003c84 	and	w4, w4, #0xffff
  20388c:	2a1703e7 	mov	w7, w23
  203890:	531f7ca5 	lsr	w5, w5, #31
  203894:	93407c84 	sxtw	x4, w4
  203898:	aa1c03e2 	mov	x2, x28
  20389c:	b9000be6 	str	w6, [sp, #8]
  2038a0:	aa0103e6 	mov	x6, x1
  2038a4:	b90003f9 	str	w25, [sp]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  2038a8:	aa1403e3 	mov	x3, x20
  2038ac:	aa1503e1 	mov	x1, x21
  2038b0:	aa1303e0 	mov	x0, x19
  2038b4:	97fffb7f 	bl	2026b0 <_ntoa_long>
  2038b8:	aa0003fc 	mov	x28, x0
        break;
  2038bc:	17fffe66 	b	203254 <_vsnprintf+0x94>
          while (l++ < width) {
  2038c0:	b94083e0 	ldr	w0, [sp, #128]
  2038c4:	6b19001f 	cmp	w0, w25
  2038c8:	54ffe8e2 	b.cs	2035e4 <_vsnprintf+0x424>  // b.hs, b.nlast
  2038cc:	51000725 	sub	w5, w25, #0x1
  2038d0:	91000b89 	add	x9, x28, #0x2
  2038d4:	4b0000a0 	sub	w0, w5, w0
  2038d8:	8b090019 	add	x25, x0, x9
  2038dc:	d503201f 	nop
            out(' ', buffer, idx++, maxlen);
  2038e0:	aa1703e2 	mov	x2, x23
  2038e4:	aa1403e3 	mov	x3, x20
  2038e8:	910006f7 	add	x23, x23, #0x1
  2038ec:	aa1503e1 	mov	x1, x21
  2038f0:	52800400 	mov	w0, #0x20                  	// #32
  2038f4:	d63f0260 	blr	x19
          while (l++ < width) {
  2038f8:	eb1902ff 	cmp	x23, x25
  2038fc:	54ffff21 	b.ne	2038e0 <_vsnprintf+0x720>  // b.any
        break;
  203900:	aa1703fc 	mov	x28, x23
  203904:	17fffe54 	b	203254 <_vsnprintf+0x94>
          while (l++ < width) {
  203908:	7100073f 	cmp	w25, #0x1
  20390c:	54002409 	b.ls	203d8c <_vsnprintf+0xbcc>  // b.plast
  203910:	91000784 	add	x4, x28, #0x1
  203914:	51000b20 	sub	w0, w25, #0x2
  203918:	8b000097 	add	x23, x4, x0
  20391c:	14000002 	b	203924 <_vsnprintf+0x764>
  203920:	91000484 	add	x4, x4, #0x1
  203924:	f90043e4 	str	x4, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  203928:	aa1c03e2 	mov	x2, x28
  20392c:	aa1403e3 	mov	x3, x20
  203930:	aa1503e1 	mov	x1, x21
  203934:	52800400 	mov	w0, #0x20                  	// #32
  203938:	d63f0260 	blr	x19
  20393c:	f94043e4 	ldr	x4, [sp, #128]
  203940:	aa0403fc 	mov	x28, x4
          while (l++ < width) {
  203944:	eb17009f 	cmp	x4, x23
  203948:	54fffec1 	b.ne	203920 <_vsnprintf+0x760>  // b.any
  20394c:	11000720 	add	w0, w25, #0x1
  203950:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  203954:	36ffe338 	tbz	w24, #31, 2035b8 <_vsnprintf+0x3f8>
  203958:	17ffff80 	b	203758 <_vsnprintf+0x598>
        const int prec = (int)va_arg(va, int);
  20395c:	37f807d8 	tbnz	w24, #31, 203a54 <_vsnprintf+0x894>
  203960:	91002ec1 	add	x1, x22, #0xb
  203964:	aa1603e0 	mov	x0, x22
  203968:	927df036 	and	x22, x1, #0xfffffffffffffff8
        precision = prec > 0 ? (unsigned int)prec : 0U;
  20396c:	b9400007 	ldr	w7, [x0]
        format++;
  203970:	91000b5a 	add	x26, x26, #0x2
    switch (*format) {
  203974:	39400340 	ldrb	w0, [x26]
  203978:	91000741 	add	x1, x26, #0x1
        precision = prec > 0 ? (unsigned int)prec : 0U;
  20397c:	710000ff 	cmp	w7, #0x0
  203980:	1a9fa0f7 	csel	w23, w7, wzr, ge	// ge = tcont
        format++;
  203984:	17fffe5e 	b	2032fc <_vsnprintf+0x13c>
        if (*format == 'x' || *format == 'X') {
  203988:	121a7801 	and	w1, w0, #0xffffffdf
  20398c:	7101603f 	cmp	w1, #0x58
  203990:	540005c0 	b.eq	203a48 <_vsnprintf+0x888>  // b.none
        else if (*format == 'o') {
  203994:	7101bc1f 	cmp	w0, #0x6f
  203998:	d2800101 	mov	x1, #0x8                   	// #8
  20399c:	54fff441 	b.ne	203824 <_vsnprintf+0x664>  // b.any
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  2039a0:	121c74c6 	and	w6, w6, #0xfffffff3
  2039a4:	d503201f 	nop
          flags &= ~FLAGS_ZEROPAD;
  2039a8:	f27600df 	tst	x6, #0x400
  2039ac:	121f78c2 	and	w2, w6, #0xfffffffe
  2039b0:	1a861046 	csel	w6, w2, w6, ne	// ne = any
        if ((*format == 'i') || (*format == 'd')) {
  2039b4:	7101a41f 	cmp	w0, #0x69
  2039b8:	52800c82 	mov	w2, #0x64                  	// #100
          if (flags & FLAGS_LONG_LONG) {
  2039bc:	121700c3 	and	w3, w6, #0x200
        if ((*format == 'i') || (*format == 'd')) {
  2039c0:	7a421004 	ccmp	w0, w2, #0x4, ne	// ne = any
  2039c4:	54fff4c0 	b.eq	20385c <_vsnprintf+0x69c>  // b.none
          if (flags & FLAGS_LONG_LONG) {
  2039c8:	35000c43 	cbnz	w3, 203b50 <_vsnprintf+0x990>
          else if (flags & FLAGS_LONG) {
  2039cc:	374013c6 	tbnz	w6, #8, 203c44 <_vsnprintf+0xa84>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  2039d0:	37300926 	tbnz	w6, #6, 203af4 <_vsnprintf+0x934>
  2039d4:	363816c6 	tbz	w6, #7, 203cac <_vsnprintf+0xaec>
  2039d8:	37f822f8 	tbnz	w24, #31, 203e34 <_vsnprintf+0xc74>
  2039dc:	aa1603e0 	mov	x0, x22
  2039e0:	91002ec2 	add	x2, x22, #0xb
  2039e4:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2039e8:	79400004 	ldrh	w4, [x0]
  2039ec:	14000047 	b	203b08 <_vsnprintf+0x948>
  2039f0:	cb1c0157 	sub	x23, x10, x28
  2039f4:	d503201f 	nop
          out(*(p++), buffer, idx++, maxlen);
  2039f8:	aa1c03e2 	mov	x2, x28
  2039fc:	9100079c 	add	x28, x28, #0x1
  203a00:	aa1403e3 	mov	x3, x20
  203a04:	aa1503e1 	mov	x1, x21
  203a08:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  203a0c:	387c6ae0 	ldrb	w0, [x23, x28]
  203a10:	35ffff40 	cbnz	w0, 2039f8 <_vsnprintf+0x838>
  203a14:	17ffff33 	b	2036e0 <_vsnprintf+0x520>
    switch (*format) {
  203a18:	39400b40 	ldrb	w0, [x26, #2]
          flags |= FLAGS_CHAR;
  203a1c:	321a04c6 	orr	w6, w6, #0xc0
          format++;
  203a20:	91000b42 	add	x2, x26, #0x2
  203a24:	17fffe40 	b	203324 <_vsnprintf+0x164>
        if (*format == 'X') {
  203a28:	7101601f 	cmp	w0, #0x58
  203a2c:	540000e1 	b.ne	203a48 <_vsnprintf+0x888>  // b.any
          flags |= FLAGS_UPPERCASE;
  203a30:	321b00c6 	orr	w6, w6, #0x20
  203a34:	d2800201 	mov	x1, #0x10                  	// #16
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  203a38:	121c74c6 	and	w6, w6, #0xfffffff3
  203a3c:	17ffffdb 	b	2039a8 <_vsnprintf+0x7e8>
  while (*format)
  203a40:	52800016 	mov	w22, #0x0                   	// #0
  203a44:	17fffe6d 	b	2033f8 <_vsnprintf+0x238>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  203a48:	121c74c6 	and	w6, w6, #0xfffffff3
        if (*format == 'X') {
  203a4c:	d2800201 	mov	x1, #0x10                  	// #16
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  203a50:	17ffffd6 	b	2039a8 <_vsnprintf+0x7e8>
        const int prec = (int)va_arg(va, int);
  203a54:	11002301 	add	w1, w24, #0x8
  203a58:	7100003f 	cmp	w1, #0x0
  203a5c:	5400044d 	b.le	203ae4 <_vsnprintf+0x924>
  203a60:	91002ec2 	add	x2, x22, #0xb
  203a64:	aa1603e0 	mov	x0, x22
  203a68:	2a0103f8 	mov	w24, w1
  203a6c:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203a70:	17ffffbf 	b	20396c <_vsnprintf+0x7ac>
          while (l++ < width) {
  203a74:	b94093e1 	ldr	w1, [sp, #144]
  203a78:	6b19003f 	cmp	w1, w25
  203a7c:	54001902 	b.cs	203d9c <_vsnprintf+0xbdc>  // b.hs, b.nlast
  203a80:	51000720 	sub	w0, w25, #0x1
  203a84:	91000784 	add	x4, x28, #0x1
  203a88:	4b010000 	sub	w0, w0, w1
  203a8c:	8b040000 	add	x0, x0, x4
  203a90:	f90053e0 	str	x0, [sp, #160]
  203a94:	14000002 	b	203a9c <_vsnprintf+0x8dc>
  203a98:	91000484 	add	x4, x4, #0x1
  203a9c:	f90043ea 	str	x10, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  203aa0:	aa1c03e2 	mov	x2, x28
  203aa4:	f9004be4 	str	x4, [sp, #144]
  203aa8:	52800400 	mov	w0, #0x20                  	// #32
  203aac:	aa1403e3 	mov	x3, x20
  203ab0:	aa1503e1 	mov	x1, x21
  203ab4:	d63f0260 	blr	x19
  203ab8:	f9404be4 	ldr	x4, [sp, #144]
          while (l++ < width) {
  203abc:	f94053e0 	ldr	x0, [sp, #160]
            out(' ', buffer, idx++, maxlen);
  203ac0:	aa0403fc 	mov	x28, x4
          while (l++ < width) {
  203ac4:	f94043ea 	ldr	x10, [sp, #128]
  203ac8:	eb00009f 	cmp	x4, x0
  203acc:	54fffe61 	b.ne	203a98 <_vsnprintf+0x8d8>  // b.any
  203ad0:	11000720 	add	w0, w25, #0x1
  203ad4:	b90093e0 	str	w0, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  203ad8:	39400140 	ldrb	w0, [x10]
  203adc:	35ffdde0 	cbnz	w0, 203698 <_vsnprintf+0x4d8>
  203ae0:	17fffddd 	b	203254 <_vsnprintf+0x94>
        const int prec = (int)va_arg(va, int);
  203ae4:	f94047e0 	ldr	x0, [sp, #136]
  203ae8:	8b38c000 	add	x0, x0, w24, sxtw
  203aec:	2a0103f8 	mov	w24, w1
  203af0:	17ffff9f 	b	20396c <_vsnprintf+0x7ac>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203af4:	37f812d8 	tbnz	w24, #31, 203d4c <_vsnprintf+0xb8c>
  203af8:	91002ec2 	add	x2, x22, #0xb
  203afc:	aa1603e0 	mov	x0, x22
  203b00:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203b04:	39400004 	ldrb	w4, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  203b08:	2a1703e7 	mov	w7, w23
  203b0c:	2a0403e4 	mov	w4, w4
  203b10:	b9000be6 	str	w6, [sp, #8]
  203b14:	aa0103e6 	mov	x6, x1
  203b18:	b90003f9 	str	w25, [sp]
  203b1c:	aa1c03e2 	mov	x2, x28
  203b20:	52800005 	mov	w5, #0x0                   	// #0
  203b24:	17ffff61 	b	2038a8 <_vsnprintf+0x6e8>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203b28:	37f80e38 	tbnz	w24, #31, 203cec <_vsnprintf+0xb2c>
  203b2c:	91002ec2 	add	x2, x22, #0xb
  203b30:	aa1603e0 	mov	x0, x22
  203b34:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203b38:	39400005 	ldrb	w5, [x0]
  203b3c:	2a0503e4 	mov	w4, w5
  203b40:	17ffff53 	b	20388c <_vsnprintf+0x6cc>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  203b44:	121c74c6 	and	w6, w6, #0xfffffff3
  203b48:	d2800041 	mov	x1, #0x2                   	// #2
  203b4c:	17ffff97 	b	2039a8 <_vsnprintf+0x7e8>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  203b50:	37f808f8 	tbnz	w24, #31, 203c6c <_vsnprintf+0xaac>
  203b54:	91003ec2 	add	x2, x22, #0xf
  203b58:	aa1603e0 	mov	x0, x22
  203b5c:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203b60:	f9400004 	ldr	x4, [x0]
  203b64:	2a1703e7 	mov	w7, w23
  203b68:	aa1c03e2 	mov	x2, x28
  203b6c:	b90003f9 	str	w25, [sp]
  203b70:	b9000be6 	str	w6, [sp, #8]
  203b74:	aa0103e6 	mov	x6, x1
  203b78:	17fffe15 	b	2033cc <_vsnprintf+0x20c>
            const long long value = va_arg(va, long long);
  203b7c:	37f80898 	tbnz	w24, #31, 203c8c <_vsnprintf+0xacc>
  203b80:	91003ec2 	add	x2, x22, #0xf
  203b84:	aa1603e0 	mov	x0, x22
  203b88:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203b8c:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  203b90:	2a1703e7 	mov	w7, w23
  203b94:	aa1c03e2 	mov	x2, x28
  203b98:	b90003f9 	str	w25, [sp]
  203b9c:	f10000bf 	cmp	x5, #0x0
  203ba0:	b9000be6 	str	w6, [sp, #8]
  203ba4:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  203ba8:	aa0103e6 	mov	x6, x1
  203bac:	d37ffca5 	lsr	x5, x5, #63
  203bb0:	17fffe08 	b	2033d0 <_vsnprintf+0x210>
        const char* p = va_arg(va, char*);
  203bb4:	f94047e0 	ldr	x0, [sp, #136]
  203bb8:	8b38c000 	add	x0, x0, w24, sxtw
  203bbc:	2a0103f8 	mov	w24, w1
  203bc0:	17fffe9c 	b	203630 <_vsnprintf+0x470>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  203bc4:	f94047e1 	ldr	x1, [sp, #136]
  203bc8:	8b38c021 	add	x1, x1, w24, sxtw
  203bcc:	2a0203f8 	mov	w24, w2
  203bd0:	17fffdf8 	b	2033b0 <_vsnprintf+0x1f0>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  203bd4:	f9404fe2 	ldr	x2, [sp, #152]
  203bd8:	b94077e0 	ldr	w0, [sp, #116]
  203bdc:	b90077e1 	str	w1, [sp, #116]
  203be0:	8b20c040 	add	x0, x2, w0, sxtw
  203be4:	17fffe65 	b	203578 <_vsnprintf+0x3b8>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  203be8:	f9404fe2 	ldr	x2, [sp, #152]
  203bec:	b94077e0 	ldr	w0, [sp, #116]
  203bf0:	b90077e1 	str	w1, [sp, #116]
  203bf4:	8b20c040 	add	x0, x2, w0, sxtw
  203bf8:	17fffe4e 	b	203530 <_vsnprintf+0x370>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  203bfc:	f94047e0 	ldr	x0, [sp, #136]
  203c00:	8b38c000 	add	x0, x0, w24, sxtw
  203c04:	2a0103f8 	mov	w24, w1
  203c08:	17fffe6f 	b	2035c4 <_vsnprintf+0x404>
            const long value = va_arg(va, long);
  203c0c:	37f80818 	tbnz	w24, #31, 203d0c <_vsnprintf+0xb4c>
  203c10:	91003ec2 	add	x2, x22, #0xf
  203c14:	aa1603e0 	mov	x0, x22
  203c18:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203c1c:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  203c20:	2a1703e7 	mov	w7, w23
  203c24:	aa1c03e2 	mov	x2, x28
  203c28:	b90003f9 	str	w25, [sp]
  203c2c:	f10000bf 	cmp	x5, #0x0
  203c30:	b9000be6 	str	w6, [sp, #8]
  203c34:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  203c38:	aa0103e6 	mov	x6, x1
  203c3c:	d37ffca5 	lsr	x5, x5, #63
  203c40:	17ffff1a 	b	2038a8 <_vsnprintf+0x6e8>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  203c44:	37f80758 	tbnz	w24, #31, 203d2c <_vsnprintf+0xb6c>
  203c48:	91003ec2 	add	x2, x22, #0xf
  203c4c:	aa1603e0 	mov	x0, x22
  203c50:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203c54:	f9400004 	ldr	x4, [x0]
  203c58:	2a1703e7 	mov	w7, w23
  203c5c:	b90003f9 	str	w25, [sp]
  203c60:	b9000be6 	str	w6, [sp, #8]
  203c64:	aa0103e6 	mov	x6, x1
  203c68:	17ffffad 	b	203b1c <_vsnprintf+0x95c>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  203c6c:	11002302 	add	w2, w24, #0x8
  203c70:	7100005f 	cmp	w2, #0x0
  203c74:	540007cd 	b.le	203d6c <_vsnprintf+0xbac>
  203c78:	91003ec3 	add	x3, x22, #0xf
  203c7c:	aa1603e0 	mov	x0, x22
  203c80:	2a0203f8 	mov	w24, w2
  203c84:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203c88:	17ffffb6 	b	203b60 <_vsnprintf+0x9a0>
            const long long value = va_arg(va, long long);
  203c8c:	11002302 	add	w2, w24, #0x8
  203c90:	7100005f 	cmp	w2, #0x0
  203c94:	5400074d 	b.le	203d7c <_vsnprintf+0xbbc>
  203c98:	91003ec3 	add	x3, x22, #0xf
  203c9c:	aa1603e0 	mov	x0, x22
  203ca0:	2a0203f8 	mov	w24, w2
  203ca4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203ca8:	17ffffb9 	b	203b8c <_vsnprintf+0x9cc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203cac:	37f808b8 	tbnz	w24, #31, 203dc0 <_vsnprintf+0xc00>
  203cb0:	aa1603e0 	mov	x0, x22
  203cb4:	91002ec2 	add	x2, x22, #0xb
  203cb8:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203cbc:	b9400004 	ldr	w4, [x0]
  203cc0:	17ffff92 	b	203b08 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203cc4:	37f80998 	tbnz	w24, #31, 203df4 <_vsnprintf+0xc34>
  203cc8:	91002ec2 	add	x2, x22, #0xb
  203ccc:	aa1603e0 	mov	x0, x22
  203cd0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203cd4:	b9400005 	ldr	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  203cd8:	710000bf 	cmp	w5, #0x0
  203cdc:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  203ce0:	17fffeeb 	b	20388c <_vsnprintf+0x6cc>
  for (s = str; *s && maxsize--; ++s);
  203ce4:	b90093ff 	str	wzr, [sp, #144]
  203ce8:	17fffe61 	b	20366c <_vsnprintf+0x4ac>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203cec:	11002302 	add	w2, w24, #0x8
  203cf0:	7100005f 	cmp	w2, #0x0
  203cf4:	5400078d 	b.le	203de4 <_vsnprintf+0xc24>
  203cf8:	91002ec3 	add	x3, x22, #0xb
  203cfc:	aa1603e0 	mov	x0, x22
  203d00:	2a0203f8 	mov	w24, w2
  203d04:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203d08:	17ffff8c 	b	203b38 <_vsnprintf+0x978>
            const long value = va_arg(va, long);
  203d0c:	11002302 	add	w2, w24, #0x8
  203d10:	7100005f 	cmp	w2, #0x0
  203d14:	54000aad 	b.le	203e68 <_vsnprintf+0xca8>
  203d18:	91003ec3 	add	x3, x22, #0xf
  203d1c:	aa1603e0 	mov	x0, x22
  203d20:	2a0203f8 	mov	w24, w2
  203d24:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203d28:	17ffffbd 	b	203c1c <_vsnprintf+0xa5c>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  203d2c:	11002302 	add	w2, w24, #0x8
  203d30:	7100005f 	cmp	w2, #0x0
  203d34:	540003ed 	b.le	203db0 <_vsnprintf+0xbf0>
  203d38:	91003ec3 	add	x3, x22, #0xf
  203d3c:	aa1603e0 	mov	x0, x22
  203d40:	2a0203f8 	mov	w24, w2
  203d44:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203d48:	17ffffc3 	b	203c54 <_vsnprintf+0xa94>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203d4c:	11002302 	add	w2, w24, #0x8
  203d50:	7100005f 	cmp	w2, #0x0
  203d54:	5400082d 	b.le	203e58 <_vsnprintf+0xc98>
  203d58:	91002ec3 	add	x3, x22, #0xb
  203d5c:	aa1603e0 	mov	x0, x22
  203d60:	2a0203f8 	mov	w24, w2
  203d64:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203d68:	17ffff67 	b	203b04 <_vsnprintf+0x944>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  203d6c:	f94047e0 	ldr	x0, [sp, #136]
  203d70:	8b38c000 	add	x0, x0, w24, sxtw
  203d74:	2a0203f8 	mov	w24, w2
  203d78:	17ffff7a 	b	203b60 <_vsnprintf+0x9a0>
            const long long value = va_arg(va, long long);
  203d7c:	f94047e0 	ldr	x0, [sp, #136]
  203d80:	8b38c000 	add	x0, x0, w24, sxtw
  203d84:	2a0203f8 	mov	w24, w2
  203d88:	17ffff81 	b	203b8c <_vsnprintf+0x9cc>
          while (l++ < width) {
  203d8c:	52800040 	mov	w0, #0x2                   	// #2
  203d90:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  203d94:	36ffc138 	tbz	w24, #31, 2035b8 <_vsnprintf+0x3f8>
  203d98:	17fffe70 	b	203758 <_vsnprintf+0x598>
          while (l++ < width) {
  203d9c:	b94093e1 	ldr	w1, [sp, #144]
  203da0:	11000421 	add	w1, w1, #0x1
  203da4:	b90093e1 	str	w1, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  203da8:	35ffc780 	cbnz	w0, 203698 <_vsnprintf+0x4d8>
  203dac:	17fffd2a 	b	203254 <_vsnprintf+0x94>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  203db0:	f94047e0 	ldr	x0, [sp, #136]
  203db4:	8b38c000 	add	x0, x0, w24, sxtw
  203db8:	2a0203f8 	mov	w24, w2
  203dbc:	17ffffa6 	b	203c54 <_vsnprintf+0xa94>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203dc0:	11002302 	add	w2, w24, #0x8
  203dc4:	7100005f 	cmp	w2, #0x0
  203dc8:	5400060d 	b.le	203e88 <_vsnprintf+0xcc8>
  203dcc:	aa1603e0 	mov	x0, x22
  203dd0:	91002ec3 	add	x3, x22, #0xb
  203dd4:	2a0203f8 	mov	w24, w2
  203dd8:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203ddc:	b9400004 	ldr	w4, [x0]
  203de0:	17ffff4a 	b	203b08 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203de4:	f94047e0 	ldr	x0, [sp, #136]
  203de8:	8b38c000 	add	x0, x0, w24, sxtw
  203dec:	2a0203f8 	mov	w24, w2
  203df0:	17ffff52 	b	203b38 <_vsnprintf+0x978>
  203df4:	11002302 	add	w2, w24, #0x8
  203df8:	7100005f 	cmp	w2, #0x0
  203dfc:	5400050d 	b.le	203e9c <_vsnprintf+0xcdc>
  203e00:	91002ec3 	add	x3, x22, #0xb
  203e04:	aa1603e0 	mov	x0, x22
  203e08:	2a0203f8 	mov	w24, w2
  203e0c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203e10:	17ffffb1 	b	203cd4 <_vsnprintf+0xb14>
  203e14:	11002302 	add	w2, w24, #0x8
  203e18:	7100005f 	cmp	w2, #0x0
  203e1c:	540002ed 	b.le	203e78 <_vsnprintf+0xcb8>
  203e20:	91002ec3 	add	x3, x22, #0xb
  203e24:	aa1603e0 	mov	x0, x22
  203e28:	2a0203f8 	mov	w24, w2
  203e2c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203e30:	17fffe93 	b	20387c <_vsnprintf+0x6bc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203e34:	11002302 	add	w2, w24, #0x8
  203e38:	7100005f 	cmp	w2, #0x0
  203e3c:	5400038d 	b.le	203eac <_vsnprintf+0xcec>
  203e40:	aa1603e0 	mov	x0, x22
  203e44:	91002ec3 	add	x3, x22, #0xb
  203e48:	2a0203f8 	mov	w24, w2
  203e4c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203e50:	79400004 	ldrh	w4, [x0]
  203e54:	17ffff2d 	b	203b08 <_vsnprintf+0x948>
  203e58:	f94047e0 	ldr	x0, [sp, #136]
  203e5c:	8b38c000 	add	x0, x0, w24, sxtw
  203e60:	2a0203f8 	mov	w24, w2
  203e64:	17ffff28 	b	203b04 <_vsnprintf+0x944>
            const long value = va_arg(va, long);
  203e68:	f94047e0 	ldr	x0, [sp, #136]
  203e6c:	8b38c000 	add	x0, x0, w24, sxtw
  203e70:	2a0203f8 	mov	w24, w2
  203e74:	17ffff6a 	b	203c1c <_vsnprintf+0xa5c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203e78:	f94047e0 	ldr	x0, [sp, #136]
  203e7c:	8b38c000 	add	x0, x0, w24, sxtw
  203e80:	2a0203f8 	mov	w24, w2
  203e84:	17fffe7e 	b	20387c <_vsnprintf+0x6bc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203e88:	f94047e0 	ldr	x0, [sp, #136]
  203e8c:	8b38c000 	add	x0, x0, w24, sxtw
  203e90:	2a0203f8 	mov	w24, w2
  203e94:	b9400004 	ldr	w4, [x0]
  203e98:	17ffff1c 	b	203b08 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203e9c:	f94047e0 	ldr	x0, [sp, #136]
  203ea0:	8b38c000 	add	x0, x0, w24, sxtw
  203ea4:	2a0203f8 	mov	w24, w2
  203ea8:	17ffff8b 	b	203cd4 <_vsnprintf+0xb14>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203eac:	f94047e0 	ldr	x0, [sp, #136]
  203eb0:	8b38c000 	add	x0, x0, w24, sxtw
  203eb4:	2a0203f8 	mov	w24, w2
  203eb8:	79400004 	ldrh	w4, [x0]
  203ebc:	17ffff13 	b	203b08 <_vsnprintf+0x948>
  return (ch >= '0') && (ch <= '9');
  203ec0:	5100c002 	sub	w2, w0, #0x30
  unsigned int i = 0U;
  203ec4:	52800019 	mov	w25, #0x0                   	// #0
    if (_is_digit(*format)) {
  203ec8:	12001c42 	and	w2, w2, #0xff
  203ecc:	7100245f 	cmp	w2, #0x9
  203ed0:	54ffad48 	b.hi	203478 <_vsnprintf+0x2b8>  // b.pmore
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  203ed4:	52800143 	mov	w3, #0xa                   	// #10
  203ed8:	1b030325 	madd	w5, w25, w3, w0
  while (_is_digit(**str)) {
  203edc:	39400020 	ldrb	w0, [x1]
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  203ee0:	aa0103fa 	mov	x26, x1
  203ee4:	91000421 	add	x1, x1, #0x1
  return (ch >= '0') && (ch <= '9');
  203ee8:	5100c002 	sub	w2, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  203eec:	5100c0b9 	sub	w25, w5, #0x30
  while (_is_digit(**str)) {
  203ef0:	12001c42 	and	w2, w2, #0xff
  203ef4:	7100245f 	cmp	w2, #0x9
  203ef8:	54ffff09 	b.ls	203ed8 <_vsnprintf+0xd18>  // b.plast
  203efc:	17fffd5f 	b	203478 <_vsnprintf+0x2b8>

0000000000203f00 <sddf_printf_>:


///////////////////////////////////////////////////////////////////////////////

int sddf_printf_(const char* format, ...)
{
  203f00:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  va_list va;
  va_start(va, format);
  203f04:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  203f08:	128006ea 	mov	w10, #0xffffffc8            	// #-56
{
  203f0c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203f10:	910383eb 	add	x11, sp, #0xe0
  203f14:	910483e8 	add	x8, sp, #0x120
  203f18:	a90423e8 	stp	x8, x8, [sp, #64]
{
  203f1c:	aa0003e8 	mov	x8, x0
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203f20:	f0ffffe0 	adrp	x0, 202000 <init+0x6e0>
  203f24:	9127c000 	add	x0, x0, #0x9f0
  va_start(va, format);
  203f28:	f9002beb 	str	x11, [sp, #80]
  203f2c:	290b27ea 	stp	w10, w9, [sp, #88]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203f30:	a94437ec 	ldp	x12, x13, [sp, #64]
  203f34:	a90137ec 	stp	x12, x13, [sp, #16]
  203f38:	a9452fea 	ldp	x10, x11, [sp, #80]
  203f3c:	a9022fea 	stp	x10, x11, [sp, #32]
{
  203f40:	3d801be0 	str	q0, [sp, #96]
  203f44:	3d801fe1 	str	q1, [sp, #112]
  203f48:	3d8023e2 	str	q2, [sp, #128]
  203f4c:	3d8027e3 	str	q3, [sp, #144]
  203f50:	3d802be4 	str	q4, [sp, #160]
  203f54:	3d802fe5 	str	q5, [sp, #176]
  203f58:	3d8033e6 	str	q6, [sp, #192]
  203f5c:	3d8037e7 	str	q7, [sp, #208]
  203f60:	a90e8be1 	stp	x1, x2, [sp, #232]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203f64:	9100e3e1 	add	x1, sp, #0x38
  203f68:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  203f6c:	a90f93e3 	stp	x3, x4, [sp, #248]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203f70:	910043e4 	add	x4, sp, #0x10
  203f74:	aa0803e3 	mov	x3, x8
{
  203f78:	a9109be5 	stp	x5, x6, [sp, #264]
  203f7c:	f9008fe7 	str	x7, [sp, #280]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203f80:	97fffc90 	bl	2031c0 <_vsnprintf>
  va_end(va);
  return ret;
}
  203f84:	a8d27bfd 	ldp	x29, x30, [sp], #288
  203f88:	d65f03c0 	ret
  203f8c:	d503201f 	nop

0000000000203f90 <sddf_sprintf_>:


int sddf_sprintf_(char* buffer, const char* format, ...)
{
  203f90:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  203f94:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  203f98:	128005ea 	mov	w10, #0xffffffd0            	// #-48
{
  203f9c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203fa0:	910343e8 	add	x8, sp, #0xd0
  203fa4:	910403eb 	add	x11, sp, #0x100
  203fa8:	a9032feb 	stp	x11, x11, [sp, #48]
  203fac:	f90023e8 	str	x8, [sp, #64]
{
  203fb0:	aa0103e8 	mov	x8, x1
  va_start(va, format);
  203fb4:	290927ea 	stp	w10, w9, [sp, #72]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203fb8:	aa0003e1 	mov	x1, x0
  203fbc:	a94337ec 	ldp	x12, x13, [sp, #48]
  203fc0:	f0ffffe0 	adrp	x0, 202000 <init+0x6e0>
  203fc4:	a9442fea 	ldp	x10, x11, [sp, #64]
  203fc8:	9115c000 	add	x0, x0, #0x570
  203fcc:	a90137ec 	stp	x12, x13, [sp, #16]
  203fd0:	a9022fea 	stp	x10, x11, [sp, #32]
{
  203fd4:	3d8017e0 	str	q0, [sp, #80]
  203fd8:	3d801be1 	str	q1, [sp, #96]
  203fdc:	3d801fe2 	str	q2, [sp, #112]
  203fe0:	3d8023e3 	str	q3, [sp, #128]
  203fe4:	3d8027e4 	str	q4, [sp, #144]
  203fe8:	3d802be5 	str	q5, [sp, #160]
  203fec:	3d802fe6 	str	q6, [sp, #176]
  203ff0:	3d8033e7 	str	q7, [sp, #192]
  203ff4:	a90d0fe2 	stp	x2, x3, [sp, #208]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203ff8:	aa0803e3 	mov	x3, x8
  203ffc:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  204000:	a90e17e4 	stp	x4, x5, [sp, #224]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  204004:	910043e4 	add	x4, sp, #0x10
{
  204008:	a90f1fe6 	stp	x6, x7, [sp, #240]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  20400c:	97fffc6d 	bl	2031c0 <_vsnprintf>
  va_end(va);
  return ret;
}
  204010:	a8d07bfd 	ldp	x29, x30, [sp], #256
  204014:	d65f03c0 	ret
  204018:	d503201f 	nop
  20401c:	d503201f 	nop

0000000000204020 <sddf_snprintf_>:


int sddf_snprintf_(char* buffer, size_t count, const char* format, ...)
{
  204020:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  204024:	128004e8 	mov	w8, #0xffffffd8            	// #-40
  204028:	12800fea 	mov	w10, #0xffffff80            	// #-128
{
  20402c:	910003fd 	mov	x29, sp
  va_start(va, format);
  204030:	910343e9 	add	x9, sp, #0xd0
  204034:	910403eb 	add	x11, sp, #0x100
  204038:	a9032feb 	stp	x11, x11, [sp, #48]
  20403c:	f90023e9 	str	x9, [sp, #64]
{
  204040:	aa0103e9 	mov	x9, x1
  va_start(va, format);
  204044:	29092be8 	stp	w8, w10, [sp, #72]
{
  204048:	aa0203e8 	mov	x8, x2
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  20404c:	a94337ec 	ldp	x12, x13, [sp, #48]
  204050:	aa0003e1 	mov	x1, x0
  204054:	a9442fea 	ldp	x10, x11, [sp, #64]
  204058:	aa0903e2 	mov	x2, x9
  20405c:	d0ffffe0 	adrp	x0, 202000 <init+0x6e0>
  204060:	9115c000 	add	x0, x0, #0x570
  204064:	a90137ec 	stp	x12, x13, [sp, #16]
  204068:	a9022fea 	stp	x10, x11, [sp, #32]
{
  20406c:	3d8017e0 	str	q0, [sp, #80]
  204070:	3d801be1 	str	q1, [sp, #96]
  204074:	3d801fe2 	str	q2, [sp, #112]
  204078:	3d8023e3 	str	q3, [sp, #128]
  20407c:	3d8027e4 	str	q4, [sp, #144]
  204080:	3d802be5 	str	q5, [sp, #160]
  204084:	3d802fe6 	str	q6, [sp, #176]
  204088:	3d8033e7 	str	q7, [sp, #192]
  20408c:	a90d93e3 	stp	x3, x4, [sp, #216]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  204090:	910043e4 	add	x4, sp, #0x10
  204094:	aa0803e3 	mov	x3, x8
{
  204098:	a90e9be5 	stp	x5, x6, [sp, #232]
  20409c:	f9007fe7 	str	x7, [sp, #248]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  2040a0:	97fffc48 	bl	2031c0 <_vsnprintf>
  va_end(va);
  return ret;
}
  2040a4:	a8d07bfd 	ldp	x29, x30, [sp], #256
  2040a8:	d65f03c0 	ret
  2040ac:	d503201f 	nop

00000000002040b0 <sddf_vprintf_>:


int sddf_vprintf_(const char* format, va_list va)
{
  2040b0:	aa0103e5 	mov	x5, x1
  2040b4:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  2040b8:	aa0003e3 	mov	x3, x0
{
  2040bc:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  2040c0:	a9401ca6 	ldp	x6, x7, [x5]
  2040c4:	f9000be6 	str	x6, [sp, #16]
  2040c8:	910043e4 	add	x4, sp, #0x10
  2040cc:	9100e3e1 	add	x1, sp, #0x38
  2040d0:	f94008a6 	ldr	x6, [x5, #16]
  2040d4:	f9000fe7 	str	x7, [sp, #24]
  2040d8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  2040dc:	d0ffffe0 	adrp	x0, 202000 <init+0x6e0>
  2040e0:	f9400ca5 	ldr	x5, [x5, #24]
  2040e4:	9127c000 	add	x0, x0, #0x9f0
  2040e8:	a90217e6 	stp	x6, x5, [sp, #32]
  2040ec:	97fffc35 	bl	2031c0 <_vsnprintf>
}
  2040f0:	a8c47bfd 	ldp	x29, x30, [sp], #64
  2040f4:	d65f03c0 	ret
  2040f8:	d503201f 	nop
  2040fc:	d503201f 	nop

0000000000204100 <sddf_vsnprintf_>:


int sddf_vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
  204100:	aa0303e5 	mov	x5, x3
  204104:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  204108:	aa0103e4 	mov	x4, x1
  20410c:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_buffer, buffer, count, format, va);
  204110:	a9401ca8 	ldp	x8, x7, [x5]
  204114:	aa0003e1 	mov	x1, x0
  204118:	a94114a6 	ldp	x6, x5, [x5, #16]
  20411c:	aa0203e3 	mov	x3, x2
  204120:	d0ffffe0 	adrp	x0, 202000 <init+0x6e0>
  204124:	9115c000 	add	x0, x0, #0x570
  204128:	aa0403e2 	mov	x2, x4
  20412c:	910043e4 	add	x4, sp, #0x10
  204130:	a9011fe8 	stp	x8, x7, [sp, #16]
  204134:	a90217e6 	stp	x6, x5, [sp, #32]
  204138:	97fffc22 	bl	2031c0 <_vsnprintf>
}
  20413c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  204140:	d65f03c0 	ret
  204144:	d503201f 	nop
  204148:	d503201f 	nop
  20414c:	d503201f 	nop

0000000000204150 <sddf_fctprintf>:


int sddf_fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
  204150:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  va_list va;
  va_start(va, format);
  204154:	12800feb 	mov	w11, #0xffffff80            	// #-128
  204158:	128004e9 	mov	w9, #0xffffffd8            	// #-40
{
  20415c:	910003fd 	mov	x29, sp
  va_start(va, format);
  204160:	910383ea 	add	x10, sp, #0xe0
  204164:	910443e8 	add	x8, sp, #0x110
  204168:	a90423e8 	stp	x8, x8, [sp, #64]
{
  20416c:	aa0203e8 	mov	x8, x2
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  204170:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  va_start(va, format);
  204174:	f9002bea 	str	x10, [sp, #80]
{
  204178:	aa0003ea 	mov	x10, x0
  va_start(va, format);
  20417c:	290b2fe9 	stp	w9, w11, [sp, #88]
{
  204180:	aa0103e9 	mov	x9, x1
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  204184:	a9443fee 	ldp	x14, x15, [sp, #64]
  204188:	9100c3e1 	add	x1, sp, #0x30
  20418c:	a94537ec 	ldp	x12, x13, [sp, #80]
  204190:	d0ffffe0 	adrp	x0, 202000 <init+0x6e0>
  204194:	91280000 	add	x0, x0, #0xa00
  204198:	a9013fee 	stp	x14, x15, [sp, #16]
  20419c:	a90237ec 	stp	x12, x13, [sp, #32]
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  2041a0:	a90327ea 	stp	x10, x9, [sp, #48]
{
  2041a4:	3d801be0 	str	q0, [sp, #96]
  2041a8:	3d801fe1 	str	q1, [sp, #112]
  2041ac:	3d8023e2 	str	q2, [sp, #128]
  2041b0:	3d8027e3 	str	q3, [sp, #144]
  2041b4:	3d802be4 	str	q4, [sp, #160]
  2041b8:	3d802fe5 	str	q5, [sp, #176]
  2041bc:	3d8033e6 	str	q6, [sp, #192]
  2041c0:	3d8037e7 	str	q7, [sp, #208]
  2041c4:	a90e93e3 	stp	x3, x4, [sp, #232]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  2041c8:	910043e4 	add	x4, sp, #0x10
  2041cc:	aa0803e3 	mov	x3, x8
{
  2041d0:	a90f9be5 	stp	x5, x6, [sp, #248]
  2041d4:	f90087e7 	str	x7, [sp, #264]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  2041d8:	97fffbfa 	bl	2031c0 <_vsnprintf>
  va_end(va);
  return ret;
}
  2041dc:	a8d17bfd 	ldp	x29, x30, [sp], #272
  2041e0:	d65f03c0 	ret
	...

00000000002041f0 <_assert_fail>:
 */

#include <sddf/util/printf.h>

void _assert_fail(const char  *assertion, const char  *file, unsigned int line, const char  *function)
{
  2041f0:	2a0203e5 	mov	w5, w2
  2041f4:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  2041f8:	aa0103e4 	mov	x4, x1
  2041fc:	910003fd 	mov	x29, sp
    sddf_dprintf("Failed assertion '%s' at %s:%u in function %s\n", assertion, file, line, function);
  204200:	aa0003e1 	mov	x1, x0
  204204:	aa0403e2 	mov	x2, x4
  204208:	aa0303e4 	mov	x4, x3
  20420c:	90000000 	adrp	x0, 204000 <sddf_sprintf_+0x70>
  204210:	91188000 	add	x0, x0, #0x620
  204214:	2a0503e3 	mov	w3, w5
  204218:	97ffff3a 	bl	203f00 <sddf_printf_>
    __builtin_trap();
  20421c:	d4207d00 	brk	#0x3e8

0000000000204220 <_sddf_putchar>:

static char string_buffer[MAX_STRING_LENGTH + 1];
static uint32_t local_tail;

void _sddf_putchar(char character)
{
  204220:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    string_buffer[local_tail] = character;
  204224:	d0000001 	adrp	x1, 206000 <state+0x178>
  204228:	91160021 	add	x1, x1, #0x580
{
  20422c:	910003fd 	mov	x29, sp
  204230:	f9000bf3 	str	x19, [sp, #16]
    string_buffer[local_tail] = character;
  204234:	d0000013 	adrp	x19, 206000 <state+0x178>
  204238:	b9457263 	ldr	w3, [x19, #1392]
{
  20423c:	12001c00 	and	w0, w0, #0xff
    local_tail++;
  204240:	11000462 	add	w2, w3, #0x1
  204244:	b9057262 	str	w2, [x19, #1392]

    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  204248:	7140045f 	cmp	w2, #0x1, lsl #12
    string_buffer[local_tail] = character;
  20424c:	38234820 	strb	w0, [x1, w3, uxtw]
    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  204250:	7a4a1804 	ccmp	w0, #0xa, #0x4, ne	// ne = any
  204254:	540000a1 	b.ne	204268 <_sddf_putchar+0x48>  // b.any
        string_buffer[local_tail] = '\0';
        microkit_dbg_puts(string_buffer);
  204258:	aa0103e0 	mov	x0, x1
        string_buffer[local_tail] = '\0';
  20425c:	3822483f 	strb	wzr, [x1, w2, uxtw]
        microkit_dbg_puts(string_buffer);
  204260:	97fff834 	bl	202330 <microkit_dbg_puts>
        local_tail = 0;
  204264:	b905727f 	str	wzr, [x19, #1392]
    }
  204268:	f9400bf3 	ldr	x19, [sp, #16]
  20426c:	a8c27bfd 	ldp	x29, x30, [sp], #32
  204270:	d65f03c0 	ret
  204274:	00000000 	udf	#0

0000000000204278 <__FUNCTION__.8>:
  204278:	636f7270 5f737365 5f707261 74696177     process_arp_wait
  204288:	00676e69 00000000                       ing.....

0000000000204290 <__FUNCTION__.5>:
  204290:	74756f72 00000065                       route...

0000000000204298 <__FUNCTION__.2>:
  204298:	74696e69 00000000                       init....

00000000002042a0 <__FUNCTION__.1>:
  2042a0:	5f74656e 66667562 5f737265 74696e69     net_buffers_init
	...
  2042c0:	fff900a3 fff9fff9 fff9fff9 fff9fff9     ................
  2042d0:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  2042e0:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  2042f0:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  204300:	007e0067 fff90067 fff9fff9 fff9fff9     g.~.g...........
  204310:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  204320:	fff9fff9 012cfff9 fff9fff9 fff9fff9     ......,.........
  204330:	fff9fff9 fff9fff9 012cfff9 012c0090     ..........,...,.
  204340:	007e0067 00000067 00000000 00000000     g.~.g...........

0000000000204350 <pow10.0>:
  204350:	00000000 3ff00000 00000000 40240000     .......?......$@
  204360:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  204370:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  204380:	00000000 412e8480 00000000 416312d0     .......A......cA
  204390:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
