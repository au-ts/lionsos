
build/routing.elf:     file format elf64-littleaarch64


Disassembly of section .text:

0000000000200000 <_start>:
  200000:	140007e8 	b	201fa0 <main>
	...

0000000000200010 <hash>:
#include <sddf/serial/config.h>
#include <sddf/timer/client.h>
#include <sddf/timer/config.h>
#include <string.h>

#include "routing.h"
  200010:	5290a3e1 	mov	w1, #0x851f                	// #34079
  200014:	72aa3d61 	movk	w1, #0x51eb, lsl #16
  200018:	52800c82 	mov	w2, #0x64                  	// #100
  20001c:	9ba17c01 	umull	x1, w0, w1
  200020:	d365fc21 	lsr	x1, x1, #37
#include "firewall_arp.h"
  200024:	1b028020 	msub	w0, w1, w2, w0
  200028:	d65f03c0 	ret
  20002c:	d503201f 	nop

0000000000200030 <hashtable_init>:
#include "hashmap.h"
#include "config.h"
#include "linkedlist.h"
#include "protocols.h"
  200030:	9112c001 	add	x1, x0, #0x4b0
  200034:	cb0103e1 	neg	x1, x1
  200038:	f2400c23 	ands	x3, x1, #0xf
  20003c:	540011e0 	b.eq	200278 <hashtable_init+0x248>  // b.none

  200040:	3912c01f 	strb	wzr, [x0, #1200]
#include "protocols.h"
  200044:	f27f083f 	tst	x1, #0xe
  200048:	540010c0 	b.eq	200260 <hashtable_init+0x230>  // b.none

  20004c:	3912c41f 	strb	wzr, [x0, #1201]
#include "protocols.h"
  200050:	f100087f 	cmp	x3, #0x2
  200054:	540010c9 	b.ls	20026c <hashtable_init+0x23c>  // b.plast

  200058:	3912c81f 	strb	wzr, [x0, #1202]
#include "protocols.h"
  20005c:	f27e043f 	tst	x1, #0xc
  200060:	54001120 	b.eq	200284 <hashtable_init+0x254>  // b.none

  200064:	3912cc1f 	strb	wzr, [x0, #1203]
#include "protocols.h"
  200068:	f100107f 	cmp	x3, #0x4
  20006c:	54001129 	b.ls	200290 <hashtable_init+0x260>  // b.plast

  200070:	3912d01f 	strb	wzr, [x0, #1204]
#include "protocols.h"
  200074:	f100147f 	cmp	x3, #0x5
  200078:	54001180 	b.eq	2002a8 <hashtable_init+0x278>  // b.none

  20007c:	3912d41f 	strb	wzr, [x0, #1205]
#include "protocols.h"
  200080:	f100187f 	cmp	x3, #0x6
  200084:	540011e0 	b.eq	2002c0 <hashtable_init+0x290>  // b.none

  200088:	3912d81f 	strb	wzr, [x0, #1206]
#include "protocols.h"
  20008c:	36181141 	tbz	w1, #3, 2002b4 <hashtable_init+0x284>

  200090:	3912dc1f 	strb	wzr, [x0, #1207]
#include "protocols.h"
  200094:	f100207f 	cmp	x3, #0x8
  200098:	540011a9 	b.ls	2002cc <hashtable_init+0x29c>  // b.plast

  20009c:	3912e01f 	strb	wzr, [x0, #1208]
#include "protocols.h"
  2000a0:	f100247f 	cmp	x3, #0x9
  2000a4:	540011a0 	b.eq	2002d8 <hashtable_init+0x2a8>  // b.none

  2000a8:	3912e41f 	strb	wzr, [x0, #1209]
#include "protocols.h"
  2000ac:	f100287f 	cmp	x3, #0xa
  2000b0:	54000f60 	b.eq	20029c <hashtable_init+0x26c>  // b.none

  2000b4:	3912e81f 	strb	wzr, [x0, #1210]
#include "protocols.h"
  2000b8:	f1002c7f 	cmp	x3, #0xb
  2000bc:	54001140 	b.eq	2002e4 <hashtable_init+0x2b4>  // b.none

  2000c0:	3912ec1f 	strb	wzr, [x0, #1211]
#include "protocols.h"
  2000c4:	f100307f 	cmp	x3, #0xc
  2000c8:	540011a0 	b.eq	2002fc <hashtable_init+0x2cc>  // b.none

  2000cc:	3912f01f 	strb	wzr, [x0, #1212]
#include "protocols.h"
  2000d0:	f100347f 	cmp	x3, #0xd
  2000d4:	540011a0 	b.eq	200308 <hashtable_init+0x2d8>  // b.none

  2000d8:	3912f41f 	strb	wzr, [x0, #1213]
#include "protocols.h"
  2000dc:	f1003c7f 	cmp	x3, #0xf
  2000e0:	54001081 	b.ne	2002f0 <hashtable_init+0x2c0>  // b.any
  2000e4:	aa0303e1 	mov	x1, x3
  2000e8:	d2800aa2 	mov	x2, #0x55                  	// #85

  2000ec:	3912f81f 	strb	wzr, [x0, #1214]
  2000f0:	4f000400 	movi	v0.4s, #0x0
  2000f4:	9112c066 	add	x6, x3, #0x4b0
  2000f8:	8b060004 	add	x4, x0, x6
  2000fc:	d2800c85 	mov	x5, #0x64                  	// #100
  200100:	cb0300a3 	sub	x3, x5, x3
  200104:	3ca66800 	str	q0, [x0, x6]
  200108:	d344fc65 	lsr	x5, x3, #4
  20010c:	f10018bf 	cmp	x5, #0x6
  200110:	ad008080 	stp	q0, q0, [x4, #16]
  200114:	ad018080 	stp	q0, q0, [x4, #48]
#include "protocols.h"
  200118:	540009e1 	b.ne	200254 <hashtable_init+0x224>  // b.any

  20011c:	3d801480 	str	q0, [x4, #80]
#include "protocols.h"
  200120:	91018021 	add	x1, x1, #0x60
  200124:	d1018042 	sub	x2, x2, #0x60
  200128:	f101807f 	cmp	x3, #0x60
  20012c:	54000920 	b.eq	200250 <hashtable_init+0x220>  // b.none

  200130:	8b010003 	add	x3, x0, x1
#include "protocols.h"
  200134:	f100045f 	cmp	x2, #0x1
  200138:	91000424 	add	x4, x1, #0x1

  20013c:	3912c07f 	strb	wzr, [x3, #1200]
#include "protocols.h"
  200140:	54000880 	b.eq	200250 <hashtable_init+0x220>  // b.none

  200144:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  200148:	f100085f 	cmp	x2, #0x2
  20014c:	91000823 	add	x3, x1, #0x2

  200150:	3912c09f 	strb	wzr, [x4, #1200]
#include "protocols.h"
  200154:	540007e0 	b.eq	200250 <hashtable_init+0x220>  // b.none

  200158:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  20015c:	f1000c5f 	cmp	x2, #0x3
  200160:	91000c24 	add	x4, x1, #0x3

  200164:	3912c07f 	strb	wzr, [x3, #1200]
#include "protocols.h"
  200168:	54000740 	b.eq	200250 <hashtable_init+0x220>  // b.none

  20016c:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  200170:	f100105f 	cmp	x2, #0x4
  200174:	91001023 	add	x3, x1, #0x4

  200178:	3912c09f 	strb	wzr, [x4, #1200]
#include "protocols.h"
  20017c:	540006a0 	b.eq	200250 <hashtable_init+0x220>  // b.none

  200180:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  200184:	f100145f 	cmp	x2, #0x5
  200188:	91001424 	add	x4, x1, #0x5

  20018c:	3912c07f 	strb	wzr, [x3, #1200]
#include "protocols.h"
  200190:	54000600 	b.eq	200250 <hashtable_init+0x220>  // b.none

  200194:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  200198:	f100185f 	cmp	x2, #0x6
  20019c:	91001823 	add	x3, x1, #0x6

  2001a0:	3912c09f 	strb	wzr, [x4, #1200]
#include "protocols.h"
  2001a4:	54000560 	b.eq	200250 <hashtable_init+0x220>  // b.none

  2001a8:	8b030004 	add	x4, x0, x3
#include "protocols.h"
  2001ac:	f1001c5f 	cmp	x2, #0x7
  2001b0:	91001c23 	add	x3, x1, #0x7

  2001b4:	3912c09f 	strb	wzr, [x4, #1200]
#include "protocols.h"
  2001b8:	540004c0 	b.eq	200250 <hashtable_init+0x220>  // b.none

  2001bc:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  2001c0:	f100205f 	cmp	x2, #0x8
  2001c4:	91002024 	add	x4, x1, #0x8

  2001c8:	3912c07f 	strb	wzr, [x3, #1200]
#include "protocols.h"
  2001cc:	54000420 	b.eq	200250 <hashtable_init+0x220>  // b.none

  2001d0:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  2001d4:	f100245f 	cmp	x2, #0x9
  2001d8:	91002423 	add	x3, x1, #0x9

  2001dc:	3912c09f 	strb	wzr, [x4, #1200]
#include "protocols.h"
  2001e0:	54000380 	b.eq	200250 <hashtable_init+0x220>  // b.none

  2001e4:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  2001e8:	f100285f 	cmp	x2, #0xa
  2001ec:	91002824 	add	x4, x1, #0xa

  2001f0:	3912c07f 	strb	wzr, [x3, #1200]
#include "protocols.h"
  2001f4:	540002e0 	b.eq	200250 <hashtable_init+0x220>  // b.none

  2001f8:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  2001fc:	f1002c5f 	cmp	x2, #0xb
  200200:	91002c23 	add	x3, x1, #0xb

  200204:	3912c09f 	strb	wzr, [x4, #1200]
#include "protocols.h"
  200208:	54000240 	b.eq	200250 <hashtable_init+0x220>  // b.none

  20020c:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  200210:	f100305f 	cmp	x2, #0xc
  200214:	91003024 	add	x4, x1, #0xc

  200218:	3912c07f 	strb	wzr, [x3, #1200]
#include "protocols.h"
  20021c:	540001a0 	b.eq	200250 <hashtable_init+0x220>  // b.none

  200220:	8b040004 	add	x4, x0, x4
#include "protocols.h"
  200224:	f100345f 	cmp	x2, #0xd
  200228:	91003423 	add	x3, x1, #0xd

  20022c:	3912c09f 	strb	wzr, [x4, #1200]
#include "protocols.h"
  200230:	54000100 	b.eq	200250 <hashtable_init+0x220>  // b.none

  200234:	8b030003 	add	x3, x0, x3
#include "protocols.h"
  200238:	91003821 	add	x1, x1, #0xe
  20023c:	f100385f 	cmp	x2, #0xe

  200240:	3912c07f 	strb	wzr, [x3, #1200]
#include "protocols.h"
  200244:	54000060 	b.eq	200250 <hashtable_init+0x220>  // b.none

  200248:	8b010000 	add	x0, x0, x1
  20024c:	3912c01f 	strb	wzr, [x0, #1200]
__attribute__((__section__(".router_config"))) router_config_t router_config;

  200250:	d65f03c0 	ret
  200254:	91014021 	add	x1, x1, #0x50
  200258:	d1014042 	sub	x2, x2, #0x50
  20025c:	17ffffb5 	b	200130 <hashtable_init+0x100>
#include "protocols.h"
  200260:	d2800c62 	mov	x2, #0x63                  	// #99
  200264:	d2800021 	mov	x1, #0x1                   	// #1
  200268:	17ffffa2 	b	2000f0 <hashtable_init+0xc0>
  20026c:	d2800c42 	mov	x2, #0x62                  	// #98
  200270:	d2800041 	mov	x1, #0x2                   	// #2
  200274:	17ffff9f 	b	2000f0 <hashtable_init+0xc0>
  200278:	d2800001 	mov	x1, #0x0                   	// #0
  20027c:	d2800c82 	mov	x2, #0x64                  	// #100
  200280:	17ffff9c 	b	2000f0 <hashtable_init+0xc0>
  200284:	d2800c22 	mov	x2, #0x61                  	// #97
  200288:	d2800061 	mov	x1, #0x3                   	// #3
  20028c:	17ffff99 	b	2000f0 <hashtable_init+0xc0>
  200290:	d2800c02 	mov	x2, #0x60                  	// #96
  200294:	d2800081 	mov	x1, #0x4                   	// #4
  200298:	17ffff96 	b	2000f0 <hashtable_init+0xc0>
  20029c:	aa0303e1 	mov	x1, x3
  2002a0:	d2800b42 	mov	x2, #0x5a                  	// #90
  2002a4:	17ffff93 	b	2000f0 <hashtable_init+0xc0>
  2002a8:	aa0303e1 	mov	x1, x3
  2002ac:	d2800be2 	mov	x2, #0x5f                  	// #95
  2002b0:	17ffff90 	b	2000f0 <hashtable_init+0xc0>
  2002b4:	d2800ba2 	mov	x2, #0x5d                  	// #93
  2002b8:	d28000e1 	mov	x1, #0x7                   	// #7
  2002bc:	17ffff8d 	b	2000f0 <hashtable_init+0xc0>
  2002c0:	aa0303e1 	mov	x1, x3
  2002c4:	d2800bc2 	mov	x2, #0x5e                  	// #94
  2002c8:	17ffff8a 	b	2000f0 <hashtable_init+0xc0>
  2002cc:	d2800b82 	mov	x2, #0x5c                  	// #92
  2002d0:	d2800101 	mov	x1, #0x8                   	// #8
  2002d4:	17ffff87 	b	2000f0 <hashtable_init+0xc0>
  2002d8:	d2800121 	mov	x1, #0x9                   	// #9
  2002dc:	d2800b62 	mov	x2, #0x5b                  	// #91
  2002e0:	17ffff84 	b	2000f0 <hashtable_init+0xc0>
  2002e4:	aa0303e1 	mov	x1, x3
  2002e8:	d2800b22 	mov	x2, #0x59                  	// #89
  2002ec:	17ffff81 	b	2000f0 <hashtable_init+0xc0>
  2002f0:	d2800ac2 	mov	x2, #0x56                  	// #86
  2002f4:	d28001c1 	mov	x1, #0xe                   	// #14
  2002f8:	17ffff7e 	b	2000f0 <hashtable_init+0xc0>
  2002fc:	aa0303e1 	mov	x1, x3
  200300:	d2800b02 	mov	x2, #0x58                  	// #88
  200304:	17ffff7b 	b	2000f0 <hashtable_init+0xc0>
  200308:	aa0303e1 	mov	x1, x3
  20030c:	d2800ae2 	mov	x2, #0x57                  	// #87
  200310:	17ffff78 	b	2000f0 <hashtable_init+0xc0>
  200314:	d503201f 	nop
  200318:	d503201f 	nop
  20031c:	d503201f 	nop

0000000000200320 <hashtable_insert>:
#include "routing.h"
  200320:	5290a3ea 	mov	w10, #0x851f                	// #34079
  200324:	72aa3d6a 	movk	w10, #0x51eb, lsl #16
  200328:	52800c8c 	mov	w12, #0x64                  	// #100
routing_entry_t routing_table[NUM_ROUTES] = {{0}};

/* Booleans to indicate whether packets have been enqueued during notification handling */
static bool notify_tx;
static bool notify_rx;

  20032c:	d280018b 	mov	x11, #0xc                   	// #12
#include "routing.h"
  200330:	9baa7c29 	umull	x9, w1, w10
  200334:	d365fd29 	lsr	x9, x9, #37
  200338:	1b0c8529 	msub	w9, w9, w12, w1
routing_entry_t routing_table[NUM_ROUTES] = {{0}};
  20033c:	2a0903e3 	mov	w3, w9
static bool notify_rx;
  200340:	14000008 	b	200360 <hashtable_insert+0x40>

  200344:	b8676804 	ldr	w4, [x0, x7]
  200348:	6b01009f 	cmp	w4, w1
  20034c:	540004c0 	b.eq	2003e4 <hashtable_insert+0xc4>  // b.none
net_queue_handle_t virt_tx_queue;

typedef struct state {
    net_queue_handle_t filter_queue[61];
} state_t;
  200350:	d365fd03 	lsr	x3, x8, #37
  200354:	1b0c9463 	msub	w3, w3, w12, w5

  200358:	6b03013f 	cmp	w9, w3
  20035c:	54000420 	b.eq	2003e0 <hashtable_insert+0xc0>  // b.none
static bool notify_rx;
  200360:	2a0303e4 	mov	w4, w3
} state_t;
  200364:	11000465 	add	w5, w3, #0x1
static bool notify_rx;
  200368:	8b040006 	add	x6, x0, x4
} state_t;
  20036c:	9baa7ca8 	umull	x8, w5, w10
static bool notify_rx;
  200370:	3952c0c6 	ldrb	w6, [x6, #1200]

  200374:	9b0b7c87 	mul	x7, x4, x11
static bool notify_rx;
  200378:	35fffe66 	cbnz	w6, 200344 <hashtable_insert+0x24>

struct ll_info pkt_waiting_queue;

/* This queue will hold packets that we need to generate an ARP request for. */
net_queue_handle_t arp_waiting;
/* This queue will hold all the ARP requests/responses that are needed by the
  20037c:	d2800185 	mov	x5, #0xc                   	// #12
packets in the arp_waiting queue. */
  200380:	d2800087 	mov	x7, #0x4                   	// #4
  200384:	91000446 	add	x6, x2, #0x1
  200388:	9ba51c63 	umaddl	x3, w3, w5, x7
/* This queue will hold all the ARP requests/responses that are needed by the
  20038c:	9b057c87 	mul	x7, x4, x5
packets in the arp_waiting queue. */
  200390:	8b030005 	add	x5, x0, x3
  200394:	aa0200a8 	orr	x8, x5, x2
  200398:	cb0600a6 	sub	x6, x5, x6
/* This queue will hold all the ARP requests/responses that are needed by the
  20039c:	b8276801 	str	w1, [x0, x7]

static inline void *sddf_memcpy(void *dest, const void *src, size_t n)
{
    unsigned char *to = dest;
    const unsigned char *from = src;
    while (n-- > 0) {
  2003a0:	f240091f 	tst	x8, #0x7
  2003a4:	fa4608c0 	ccmp	x6, #0x6, #0x0, eq	// eq = none
  2003a8:	54000469 	b.ls	200434 <hashtable_insert+0x114>  // b.plast
        *to++ = *from++;
  2003ac:	fd400040 	ldr	d0, [x2]
  2003b0:	fc236800 	str	d0, [x0, x3]
  2003b4:	39402041 	ldrb	w1, [x2, #8]
    }

    // Insert the new entry
    table->entries[index].key = key;
    sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
    table->used[index] = 1;  // Mark this slot as used
  2003b8:	8b040000 	add	x0, x0, x4
  2003bc:	390020a1 	strb	w1, [x5, #8]
  2003c0:	39402441 	ldrb	w1, [x2, #9]
  2003c4:	390024a1 	strb	w1, [x5, #9]
  2003c8:	39402841 	ldrb	w1, [x2, #10]
  2003cc:	390028a1 	strb	w1, [x5, #10]
  2003d0:	39402c41 	ldrb	w1, [x2, #11]
  2003d4:	39002ca1 	strb	w1, [x5, #11]
  2003d8:	52800021 	mov	w1, #0x1                   	// #1
  2003dc:	3912c001 	strb	w1, [x0, #1200]
}
  2003e0:	d65f03c0 	ret
            sddf_memcpy(&table->entries[index].value, value, sizeof(entry_t));
  2003e4:	d2800081 	mov	x1, #0x4                   	// #4
  2003e8:	91000444 	add	x4, x2, #0x1
  2003ec:	9bab0463 	umaddl	x3, w3, w11, x1
  2003f0:	8b030001 	add	x1, x0, x3
    while (n-- > 0) {
  2003f4:	aa020025 	orr	x5, x1, x2
  2003f8:	cb040024 	sub	x4, x1, x4
  2003fc:	f24008bf 	tst	x5, #0x7
  200400:	fa460880 	ccmp	x4, #0x6, #0x0, eq	// eq = none
  200404:	540003a9 	b.ls	200478 <hashtable_insert+0x158>  // b.plast
        *to++ = *from++;
  200408:	fd400040 	ldr	d0, [x2]
  20040c:	fc236800 	str	d0, [x0, x3]
  200410:	39402040 	ldrb	w0, [x2, #8]
  200414:	39002020 	strb	w0, [x1, #8]
  200418:	39402440 	ldrb	w0, [x2, #9]
  20041c:	39002420 	strb	w0, [x1, #9]
  200420:	39402840 	ldrb	w0, [x2, #10]
  200424:	39002820 	strb	w0, [x1, #10]
  200428:	39402c40 	ldrb	w0, [x2, #11]
  20042c:	39002c20 	strb	w0, [x1, #11]
}
  200430:	d65f03c0 	ret
  200434:	39400041 	ldrb	w1, [x2]
  200438:	38236801 	strb	w1, [x0, x3]
  20043c:	39400441 	ldrb	w1, [x2, #1]
  200440:	390004a1 	strb	w1, [x5, #1]
  200444:	39400841 	ldrb	w1, [x2, #2]
  200448:	390008a1 	strb	w1, [x5, #2]
  20044c:	39400c41 	ldrb	w1, [x2, #3]
  200450:	39000ca1 	strb	w1, [x5, #3]
  200454:	39401041 	ldrb	w1, [x2, #4]
  200458:	390010a1 	strb	w1, [x5, #4]
  20045c:	39401441 	ldrb	w1, [x2, #5]
  200460:	390014a1 	strb	w1, [x5, #5]
  200464:	39401841 	ldrb	w1, [x2, #6]
  200468:	390018a1 	strb	w1, [x5, #6]
  20046c:	39401c41 	ldrb	w1, [x2, #7]
  200470:	39001ca1 	strb	w1, [x5, #7]
  200474:	17ffffd0 	b	2003b4 <hashtable_insert+0x94>
  200478:	39400044 	ldrb	w4, [x2]
  20047c:	38236804 	strb	w4, [x0, x3]
  200480:	39400440 	ldrb	w0, [x2, #1]
  200484:	39000420 	strb	w0, [x1, #1]
  200488:	39400840 	ldrb	w0, [x2, #2]
  20048c:	39000820 	strb	w0, [x1, #2]
  200490:	39400c40 	ldrb	w0, [x2, #3]
  200494:	39000c20 	strb	w0, [x1, #3]
  200498:	39401040 	ldrb	w0, [x2, #4]
  20049c:	39001020 	strb	w0, [x1, #4]
  2004a0:	39401440 	ldrb	w0, [x2, #5]
  2004a4:	39001420 	strb	w0, [x1, #5]
  2004a8:	39401840 	ldrb	w0, [x2, #6]
  2004ac:	39001820 	strb	w0, [x1, #6]
  2004b0:	39401c40 	ldrb	w0, [x2, #7]
  2004b4:	39001c20 	strb	w0, [x1, #7]
  2004b8:	17ffffd6 	b	200410 <hashtable_insert+0xf0>
  2004bc:	d503201f 	nop

00000000002004c0 <hashtable_search>:
    return key % TABLE_SIZE;
  2004c0:	5290a3e9 	mov	w9, #0x851f                	// #34079
  2004c4:	72aa3d69 	movk	w9, #0x51eb, lsl #16
  2004c8:	52800c8b 	mov	w11, #0x64                  	// #100
int hashtable_search(hashtable_t *table, uint32_t key, arp_entry_t *value) {
    uint32_t index = hash(key);
    uint32_t original_index = index;

    while (table->used[index]) {
        if (table->entries[index].key == key) {
  2004cc:	d280018a 	mov	x10, #0xc                   	// #12
    return key % TABLE_SIZE;
  2004d0:	9ba97c28 	umull	x8, w1, w9
  2004d4:	d365fd08 	lsr	x8, x8, #37
  2004d8:	1b0b8508 	msub	w8, w8, w11, w1
    uint32_t index = hash(key);
  2004dc:	2a0803e3 	mov	w3, w8
    while (table->used[index]) {
  2004e0:	14000008 	b	200500 <hashtable_search+0x40>
        if (table->entries[index].key == key) {
  2004e4:	b8646804 	ldr	w4, [x0, x4]
  2004e8:	6b01009f 	cmp	w4, w1
  2004ec:	540001c0 	b.eq	200524 <hashtable_search+0x64>  // b.none
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
            return 1;
        }
        index = (index + 1) % TABLE_SIZE;
  2004f0:	d365fce3 	lsr	x3, x7, #37
  2004f4:	1b0b9463 	msub	w3, w3, w11, w5
        if (index == original_index) {
  2004f8:	6b03011f 	cmp	w8, w3
  2004fc:	54000100 	b.eq	20051c <hashtable_search+0x5c>  // b.none
    while (table->used[index]) {
  200500:	2a0303e4 	mov	w4, w3
        index = (index + 1) % TABLE_SIZE;
  200504:	11000465 	add	w5, w3, #0x1
    while (table->used[index]) {
  200508:	8b040006 	add	x6, x0, x4
        index = (index + 1) % TABLE_SIZE;
  20050c:	9ba97ca7 	umull	x7, w5, w9
    while (table->used[index]) {
  200510:	3952c0c6 	ldrb	w6, [x6, #1200]
        if (table->entries[index].key == key) {
  200514:	9b0a7c84 	mul	x4, x4, x10
    while (table->used[index]) {
  200518:	35fffe66 	cbnz	w6, 2004e4 <hashtable_search+0x24>
            // Full cycle completed, element not found
            break;
        }
    }
    return -1;
  20051c:	12800000 	mov	w0, #0xffffffff            	// #-1
}
  200520:	d65f03c0 	ret
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  200524:	9baa7c63 	umull	x3, w3, w10
  200528:	91001065 	add	x5, x3, #0x4
  20052c:	91001463 	add	x3, x3, #0x5
  200530:	8b050001 	add	x1, x0, x5
    while (n-- > 0) {
  200534:	8b030004 	add	x4, x0, x3
  200538:	aa020027 	orr	x7, x1, x2
  20053c:	cb040046 	sub	x6, x2, x4
  200540:	f24008ff 	tst	x7, #0x7
  200544:	fa4608c0 	ccmp	x6, #0x6, #0x0, eq	// eq = none
  200548:	540001a9 	b.ls	20057c <hashtable_search+0xbc>  // b.plast
        *to++ = *from++;
  20054c:	fc656800 	ldr	d0, [x0, x5]
  200550:	fd000040 	str	d0, [x2]
  200554:	39402020 	ldrb	w0, [x1, #8]
  200558:	39002040 	strb	w0, [x2, #8]
  20055c:	39402420 	ldrb	w0, [x1, #9]
  200560:	39002440 	strb	w0, [x2, #9]
  200564:	39402820 	ldrb	w0, [x1, #10]
  200568:	39002840 	strb	w0, [x2, #10]
  20056c:	39402c21 	ldrb	w1, [x1, #11]
            return 1;
  200570:	52800020 	mov	w0, #0x1                   	// #1
  200574:	39002c41 	strb	w1, [x2, #11]
}
  200578:	d65f03c0 	ret
  20057c:	38656801 	ldrb	w1, [x0, x5]
  200580:	39000041 	strb	w1, [x2]
  200584:	38636800 	ldrb	w0, [x0, x3]
  200588:	39000440 	strb	w0, [x2, #1]
  20058c:	39400480 	ldrb	w0, [x4, #1]
  200590:	39000840 	strb	w0, [x2, #2]
  200594:	39400880 	ldrb	w0, [x4, #2]
  200598:	39000c40 	strb	w0, [x2, #3]
  20059c:	39400c80 	ldrb	w0, [x4, #3]
  2005a0:	39001040 	strb	w0, [x2, #4]
  2005a4:	39401080 	ldrb	w0, [x4, #4]
  2005a8:	39001440 	strb	w0, [x2, #5]
  2005ac:	39401480 	ldrb	w0, [x4, #5]
  2005b0:	39001840 	strb	w0, [x2, #6]
  2005b4:	39401880 	ldrb	w0, [x4, #6]
  2005b8:	39001c40 	strb	w0, [x2, #7]
  2005bc:	39401c80 	ldrb	w0, [x4, #7]
  2005c0:	39002040 	strb	w0, [x2, #8]
  2005c4:	39402080 	ldrb	w0, [x4, #8]
  2005c8:	39002440 	strb	w0, [x2, #9]
  2005cc:	39402480 	ldrb	w0, [x4, #9]
  2005d0:	39002840 	strb	w0, [x2, #10]
  2005d4:	39402881 	ldrb	w1, [x4, #10]
    while (n-- > 0) {
  2005d8:	17ffffe6 	b	200570 <hashtable_search+0xb0>
  2005dc:	d503201f 	nop

00000000002005e0 <hashtable_remove>:
    return key % TABLE_SIZE;
  2005e0:	5290a3e9 	mov	w9, #0x851f                	// #34079
  2005e4:	72aa3d69 	movk	w9, #0x51eb, lsl #16
  2005e8:	52800c8a 	mov	w10, #0x64                  	// #100
void hashtable_remove(hashtable_t *table, uint32_t key) {
    uint32_t index = hash(key);
    uint32_t original_index = index;

    while (table->used[index]) {
        if (table->entries[index].key == key) {
  2005ec:	d280018b 	mov	x11, #0xc                   	// #12
    return key % TABLE_SIZE;
  2005f0:	9ba97c28 	umull	x8, w1, w9
  2005f4:	d365fd08 	lsr	x8, x8, #37
  2005f8:	1b0a8508 	msub	w8, w8, w10, w1
    uint32_t index = hash(key);
  2005fc:	2a0803e2 	mov	w2, w8
    while (table->used[index]) {
  200600:	14000007 	b	20061c <hashtable_remove+0x3c>
        if (table->entries[index].key == key) {
  200604:	b8676805 	ldr	w5, [x0, x7]
            // Mark the slot as unused and clear the entry
            table->used[index] = 0;
            return;
        }
        index = (index + 1) % TABLE_SIZE;
  200608:	1b0a8c42 	msub	w2, w2, w10, w3
        if (table->entries[index].key == key) {
  20060c:	6b0100bf 	cmp	w5, w1
  200610:	54000160 	b.eq	20063c <hashtable_remove+0x5c>  // b.none
        if (index == original_index) {
  200614:	6b02011f 	cmp	w8, w2
  200618:	54000100 	b.eq	200638 <hashtable_remove+0x58>  // b.none
    while (table->used[index]) {
  20061c:	8b020004 	add	x4, x0, x2
        index = (index + 1) % TABLE_SIZE;
  200620:	11000443 	add	w3, w2, #0x1
        if (table->entries[index].key == key) {
  200624:	9b0b7c47 	mul	x7, x2, x11
    while (table->used[index]) {
  200628:	3952c085 	ldrb	w5, [x4, #1200]
        index = (index + 1) % TABLE_SIZE;
  20062c:	9ba97c66 	umull	x6, w3, w9
  200630:	d365fcc2 	lsr	x2, x6, #37
    while (table->used[index]) {
  200634:	35fffe85 	cbnz	w5, 200604 <hashtable_remove+0x24>
            // Full cycle completed, element not found
            break;
        }
    }
}
  200638:	d65f03c0 	ret
            table->used[index] = 0;
  20063c:	3912c09f 	strb	wzr, [x4, #1200]
}
  200640:	d65f03c0 	ret
  200644:	d503201f 	nop
  200648:	d503201f 	nop
  20064c:	d503201f 	nop

0000000000200650 <hashtable_empty>:

bool hashtable_empty(hashtable_t *table) {
    bool empty = true;
    for (int i = 0; i < TABLE_SIZE; i++) {
  200650:	9112c001 	add	x1, x0, #0x4b0
  200654:	91145003 	add	x3, x0, #0x514
    bool empty = true;
  200658:	52800022 	mov	w2, #0x1                   	// #1
  20065c:	d503201f 	nop
        if (table->used[i] == 1) {
  200660:	38401420 	ldrb	w0, [x1], #1
            empty = false;
  200664:	7100041f 	cmp	w0, #0x1
  200668:	1a9f1042 	csel	w2, w2, wzr, ne	// ne = any
    for (int i = 0; i < TABLE_SIZE; i++) {
  20066c:	eb03003f 	cmp	x1, x3
  200670:	54ffff81 	b.ne	200660 <hashtable_empty+0x10>  // b.any
        }
    }
    return empty;
  200674:	2a0203e0 	mov	w0, w2
  200678:	d65f03c0 	ret
  20067c:	d503201f 	nop

0000000000200680 <ll_node_find>:
dev_info_t *device_info;

void *ll_node_find(struct ll_info *info, uint32_t ip)
{
    // Loop through the waiting list
    struct llnode_ptrs *curr = LLNODE_PTRS_CAST(info->head);
  200680:	f9400c00 	ldr	x0, [x0, #24]
    while (curr != NULL) {
  200684:	b5000080 	cbnz	x0, 200694 <ll_node_find+0x14>
  200688:	14000006 	b	2006a0 <ll_node_find+0x20>
        // Cast to llnode_pkt_waiting
        struct llnode_pkt_waiting *curr_node = (struct llnode_pkt_waiting *) curr;
        if (curr_node->ip == ip) {
            return (void *) curr;
        }
        curr = LLNODE_PTRS_CAST(curr->next);
  20068c:	f9400000 	ldr	x0, [x0]
    while (curr != NULL) {
  200690:	b4000080 	cbz	x0, 2006a0 <ll_node_find+0x20>
        if (curr_node->ip == ip) {
  200694:	b9401002 	ldr	w2, [x0, #16]
  200698:	6b01005f 	cmp	w2, w1
  20069c:	54ffff81 	b.ne	20068c <ll_node_find+0xc>  // b.any
    }

    return NULL;
}
  2006a0:	d65f03c0 	ret
  2006a4:	d503201f 	nop
  2006a8:	d503201f 	nop
  2006ac:	d503201f 	nop

00000000002006b0 <check_waiting>:

/* Check if there is a packet with this IP address already waiting on an ARP reply. */
bool check_waiting(struct ll_info *info, uint32_t ip)
{
    // Loop through the waiting list
    struct llnode_ptrs *curr = LLNODE_PTRS_CAST(info->head);
  2006b0:	f9400c00 	ldr	x0, [x0, #24]
    while (curr != NULL) {
  2006b4:	b5000080 	cbnz	x0, 2006c4 <check_waiting+0x14>
  2006b8:	14000008 	b	2006d8 <check_waiting+0x28>
        struct llnode_pkt_waiting *curr_node = (struct llnode_pkt_waiting *) curr;
        if (curr_node->ip == ip) {
            return true;
        }
        curr = LLNODE_PTRS_CAST(curr->next);
  2006bc:	f9400000 	ldr	x0, [x0]
    while (curr != NULL) {
  2006c0:	b40000a0 	cbz	x0, 2006d4 <check_waiting+0x24>
        if (curr_node->ip == ip) {
  2006c4:	b9401002 	ldr	w2, [x0, #16]
  2006c8:	6b01005f 	cmp	w2, w1
  2006cc:	54ffff81 	b.ne	2006bc <check_waiting+0xc>  // b.any
            return true;
  2006d0:	52800020 	mov	w0, #0x1                   	// #1
    }

    return false;
}
  2006d4:	d65f03c0 	ret
    return false;
  2006d8:	52800000 	mov	w0, #0x0                   	// #0
}
  2006dc:	d65f03c0 	ret

00000000002006e0 <process_arp_waiting>:

void process_arp_waiting()
{
  2006e0:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  2006e4:	910003fd 	mov	x29, sp
  2006e8:	a90153f3 	stp	x19, x20, [sp, #16]
    /* Loop through all of the ARP responses. If there are any invalid
    responses we will drop the packets associated with the IP address. Otherwise
    we will substitute the MAC address in, and then send the packet out of the NIC. */
    while (!arp_queue_empty_response(arp_queries)) {
  2006ec:	b0000034 	adrp	x20, 205000 <__sel4_ipc_buffer>
  2006f0:	f9472282 	ldr	x2, [x20, #3648]
 *
 * @return true indicates the queue is empty, false otherwise.
 */
static inline bool arp_queue_empty_response(arp_queue_handle_t *queue)
{
    return queue->response.tail - queue->response.head == 0;
  2006f4:	79700c40 	ldrh	w0, [x2, #6150]
  2006f8:	79700841 	ldrh	w1, [x2, #6148]
  2006fc:	6b00003f 	cmp	w1, w0
  200700:	540017a0 	b.eq	2009f4 <process_arp_waiting+0x314>  // b.none
  200704:	91390294 	add	x20, x20, #0xe40
  200708:	a9025bf5 	stp	x21, x22, [sp, #32]
                assert(!err);
                pkt->check = 0;

                // @kwinter: For now we are memcpy'ing the packet from our receive buffer
                // to the transmit buffer.
                sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[waiting_packet->filter].data.vaddr + waiting_packet->buffer.io_or_offset), waiting_packet->buffer.len);
  20070c:	b0000036 	adrp	x22, 205000 <__sel4_ipc_buffer>
  200710:	910022d6 	add	x22, x22, #0x8
  200714:	a90363f7 	stp	x23, x24, [sp, #48]
                struct ipv4_packet *pkt = (struct ipv4_packet *)(router_config.filters[waiting_packet->filter].data.vaddr + waiting_packet->buffer.io_or_offset);
  200718:	b0000037 	adrp	x23, 205000 <__sel4_ipc_buffer>
  20071c:	910262f7 	add	x23, x23, #0x98
{
    if (arp_queue_empty_response(queue)) {
        return -1;
    }

    sddf_memcpy(response, &queue->response.queue[queue->response.head % queue->capacity], sizeof(arp_request_t));
  200720:	52800195 	mov	w21, #0xc                   	// #12
  200724:	f90023f9 	str	x25, [sp, #64]
  200728:	b9700843 	ldr	w3, [x2, #12296]
  20072c:	d2830104 	mov	x4, #0x1808                	// #6152

    queue->response.head++;
  200730:	11000405 	add	w5, w0, #0x1
    struct llnode_ptrs *curr = LLNODE_PTRS_CAST(info->head);
  200734:	f9401293 	ldr	x19, [x20, #32]
    sddf_memcpy(response, &queue->response.queue[queue->response.head % queue->capacity], sizeof(arp_request_t));
  200738:	1ac30801 	udiv	w1, w0, w3
  20073c:	1b038021 	msub	w1, w1, w3, w0
  200740:	9bb51021 	umaddl	x1, w1, w21, x4
  200744:	8b010040 	add	x0, x2, x1
        *to++ = *from++;
  200748:	38616846 	ldrb	w6, [x2, x1]
  20074c:	39400404 	ldrb	w4, [x0, #1]
  200750:	39400801 	ldrb	w1, [x0, #2]
  200754:	39400c03 	ldrb	w3, [x0, #3]
  200758:	aa0420c4 	orr	x4, x6, x4, lsl #8
  20075c:	39401407 	ldrb	w7, [x0, #5]
  200760:	aa014081 	orr	x1, x4, x1, lsl #16
  200764:	39401006 	ldrb	w6, [x0, #4]
  200768:	39401808 	ldrb	w8, [x0, #6]
  20076c:	aa036023 	orr	x3, x1, x3, lsl #24
  200770:	39401c09 	ldrb	w9, [x0, #7]
  200774:	2a0303e1 	mov	w1, w3
  200778:	3940200a 	ldrb	w10, [x0, #8]
  20077c:	3940240b 	ldrb	w11, [x0, #9]
  200780:	39402804 	ldrb	w4, [x0, #10]
    queue->response.head++;
  200784:	79300c45 	strh	w5, [x2, #6150]
    while (curr != NULL) {
  200788:	b5000093 	cbnz	x19, 200798 <process_arp_waiting+0xb8>
  20078c:	1400009d 	b	200a00 <process_arp_waiting+0x320>
        curr = LLNODE_PTRS_CAST(curr->next);
  200790:	f9400273 	ldr	x19, [x19]
    while (curr != NULL) {
  200794:	b4001373 	cbz	x19, 200a00 <process_arp_waiting+0x320>
        if (curr_node->ip == ip) {
  200798:	b9401260 	ldr	w0, [x19, #16]
  20079c:	6b01001f 	cmp	w0, w1
  2007a0:	54ffff81 	b.ne	200790 <process_arp_waiting+0xb0>  // b.any
        if (!response.valid && waiting_packet->valid) {
  2007a4:	350013a4 	cbnz	w4, 200a18 <process_arp_waiting+0x338>
  2007a8:	39405260 	ldrb	w0, [x19, #20]
  2007ac:	340012e0 	cbz	w0, 200a08 <process_arp_waiting+0x328>
 *
 * @return true indicates the queue is full, false otherwise.
 */
static inline bool net_queue_full_free(net_queue_handle_t *queue)
{
    return queue->free->tail - queue->free->head == queue->capacity;
  2007b0:	79405260 	ldrh	w0, [x19, #40]
  2007b4:	d2800302 	mov	x2, #0x18                  	// #24
  2007b8:	9100e281 	add	x1, x20, #0x38
            waiting_packet->buffer.len = 0;
  2007bc:	7900427f 	strh	wzr, [x19, #32]
            err = net_enqueue_free(&state.filter_queue[waiting_packet->filter], waiting_packet->buffer);
  2007c0:	f9400e65 	ldr	x5, [x19, #24]
  2007c4:	9b027c00 	mul	x0, x0, x2
  2007c8:	8b000022 	add	x2, x1, x0
  2007cc:	f8606821 	ldr	x1, [x1, x0]
  2007d0:	b9401043 	ldr	w3, [x2, #16]
  2007d4:	79400420 	ldrh	w0, [x1, #2]
  2007d8:	79400022 	ldrh	w2, [x1]
  2007dc:	4b000040 	sub	w0, w2, w0
 *
 * @return -1 when queue is full, 0 on success.
 */
static inline int net_enqueue_free(net_queue_handle_t *queue, net_buff_desc_t buffer)
{
    if (net_queue_full_free(queue)) {
  2007e0:	6b03001f 	cmp	w0, w3
  2007e4:	54002e20 	b.eq	200da8 <process_arp_waiting+0x6c8>  // b.none
        return -1;
    }

    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  2007e8:	1ac30840 	udiv	w0, w2, w3
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->free->tail++;
  2007ec:	11000444 	add	w4, w2, #0x1
  2007f0:	1b038800 	msub	w0, w0, w3, w2
  2007f4:	8b001020 	add	x0, x1, x0, lsl #4
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  2007f8:	f9000405 	str	x5, [x0, #8]
  2007fc:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  200800:	79000024 	strh	w4, [x1]

static void llfree(struct ll_info *info, void *node)
{
    assert(info && node);

    struct llnode_ptrs *prev = LLNODE_PTRS_CAST(node)->prev;
  200804:	a9400261 	ldp	x1, x0, [x19]
    struct llnode_ptrs *next = LLNODE_PTRS_CAST(node)->next;

    /* A -> node -> B: if A exists, A->next = B */
    if (prev) {
  200808:	b4000040 	cbz	x0, 200810 <process_arp_waiting+0x130>
        prev->next = next;
  20080c:	f9000001 	str	x1, [x0]
    }

    /* A -> node -> B:  if B exists, B->prev = A */
    if (next) {
  200810:	b4001e61 	cbz	x1, 200bdc <process_arp_waiting+0x4fc>
        next->prev = prev;
  200814:	f9000420 	str	x0, [x1, #8]
        /* if node was the tail */
        info->tail = prev;
    }

    /* Return to free list. */
    LLNODE_PTRS_CAST(node)->next = info->empty_head;
  200818:	f9400e81 	ldr	x1, [x20, #24]
  20081c:	f9000261 	str	x1, [x19]
    info->empty_head = node;

    sddf_memset(node, 0, info->node_size);
  200820:	b9401681 	ldr	w1, [x20, #20]
    info->empty_head = node;
  200824:	f9000e93 	str	x19, [x20, #24]
    while (n-- > 0) {
  200828:	d1000422 	sub	x2, x1, #0x1
  20082c:	b4000d41 	cbz	x1, 2009d4 <process_arp_waiting+0x2f4>
  200830:	cb1303e4 	neg	x4, x19
  200834:	d28002e5 	mov	x5, #0x17                  	// #23
  200838:	92400c80 	and	x0, x4, #0xf
  20083c:	91003c03 	add	x3, x0, #0xf
  200840:	eb05007f 	cmp	x3, x5
  200844:	9a852063 	csel	x3, x3, x5, cs	// cs = hs, nlast
  200848:	eb03005f 	cmp	x2, x3
  20084c:	54000b83 	b.cc	2009bc <process_arp_waiting+0x2dc>  // b.lo, b.ul, b.last
  200850:	b4002600 	cbz	x0, 200d10 <process_arp_waiting+0x630>
        *p++ = c;
  200854:	3900027f 	strb	wzr, [x19]
  200858:	91000665 	add	x5, x19, #0x1
    while (n-- > 0) {
  20085c:	d1000822 	sub	x2, x1, #0x2
  200860:	f27f089f 	tst	x4, #0xe
  200864:	540008a0 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  200868:	3900067f 	strb	wzr, [x19, #1]
  20086c:	91000a65 	add	x5, x19, #0x2
    while (n-- > 0) {
  200870:	d1000c22 	sub	x2, x1, #0x3
  200874:	f100081f 	cmp	x0, #0x2
  200878:	54000809 	b.ls	200978 <process_arp_waiting+0x298>  // b.plast
        *p++ = c;
  20087c:	39000a7f 	strb	wzr, [x19, #2]
  200880:	91000e65 	add	x5, x19, #0x3
    while (n-- > 0) {
  200884:	d1001022 	sub	x2, x1, #0x4
  200888:	f27e049f 	tst	x4, #0xc
  20088c:	54000760 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  200890:	39000e7f 	strb	wzr, [x19, #3]
  200894:	91001265 	add	x5, x19, #0x4
    while (n-- > 0) {
  200898:	d1001422 	sub	x2, x1, #0x5
  20089c:	f100101f 	cmp	x0, #0x4
  2008a0:	540006c9 	b.ls	200978 <process_arp_waiting+0x298>  // b.plast
        *p++ = c;
  2008a4:	3900127f 	strb	wzr, [x19, #4]
  2008a8:	91001665 	add	x5, x19, #0x5
    while (n-- > 0) {
  2008ac:	d1001822 	sub	x2, x1, #0x6
  2008b0:	f100141f 	cmp	x0, #0x5
  2008b4:	54000620 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  2008b8:	3900167f 	strb	wzr, [x19, #5]
  2008bc:	91001a65 	add	x5, x19, #0x6
    while (n-- > 0) {
  2008c0:	d1001c22 	sub	x2, x1, #0x7
  2008c4:	f100181f 	cmp	x0, #0x6
  2008c8:	54000580 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  2008cc:	39001a7f 	strb	wzr, [x19, #6]
  2008d0:	91001e65 	add	x5, x19, #0x7
    while (n-- > 0) {
  2008d4:	d1002022 	sub	x2, x1, #0x8
  2008d8:	36180504 	tbz	w4, #3, 200978 <process_arp_waiting+0x298>
        *p++ = c;
  2008dc:	39001e7f 	strb	wzr, [x19, #7]
  2008e0:	91002265 	add	x5, x19, #0x8
    while (n-- > 0) {
  2008e4:	d1002422 	sub	x2, x1, #0x9
  2008e8:	f100201f 	cmp	x0, #0x8
  2008ec:	54000469 	b.ls	200978 <process_arp_waiting+0x298>  // b.plast
        *p++ = c;
  2008f0:	3900227f 	strb	wzr, [x19, #8]
  2008f4:	91002665 	add	x5, x19, #0x9
    while (n-- > 0) {
  2008f8:	d1002822 	sub	x2, x1, #0xa
  2008fc:	f100241f 	cmp	x0, #0x9
  200900:	540003c0 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  200904:	3900267f 	strb	wzr, [x19, #9]
  200908:	91002a65 	add	x5, x19, #0xa
    while (n-- > 0) {
  20090c:	d1002c22 	sub	x2, x1, #0xb
  200910:	f100281f 	cmp	x0, #0xa
  200914:	54000320 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  200918:	39002a7f 	strb	wzr, [x19, #10]
  20091c:	91002e65 	add	x5, x19, #0xb
    while (n-- > 0) {
  200920:	d1003022 	sub	x2, x1, #0xc
  200924:	f1002c1f 	cmp	x0, #0xb
  200928:	54000280 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  20092c:	39002e7f 	strb	wzr, [x19, #11]
  200930:	91003265 	add	x5, x19, #0xc
    while (n-- > 0) {
  200934:	d1003422 	sub	x2, x1, #0xd
  200938:	f100301f 	cmp	x0, #0xc
  20093c:	540001e0 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  200940:	3900327f 	strb	wzr, [x19, #12]
  200944:	91003665 	add	x5, x19, #0xd
    while (n-- > 0) {
  200948:	d1003822 	sub	x2, x1, #0xe
  20094c:	f100341f 	cmp	x0, #0xd
  200950:	54000140 	b.eq	200978 <process_arp_waiting+0x298>  // b.none
        *p++ = c;
  200954:	3900367f 	strb	wzr, [x19, #13]
  200958:	91003a65 	add	x5, x19, #0xe
    while (n-- > 0) {
  20095c:	d1003c22 	sub	x2, x1, #0xf
  200960:	f1003c1f 	cmp	x0, #0xf
  200964:	540000a1 	b.ne	200978 <process_arp_waiting+0x298>  // b.any
        *p++ = c;
  200968:	91003e65 	add	x5, x19, #0xf
    while (n-- > 0) {
  20096c:	d1004022 	sub	x2, x1, #0x10
        *p++ = c;
  200970:	39003a7f 	strb	wzr, [x19, #14]
    while (n-- > 0) {
  200974:	d503201f 	nop
        *p++ = c;
  200978:	4f000400 	movi	v0.4s, #0x0
  20097c:	cb000024 	sub	x4, x1, x0
  200980:	d1004083 	sub	x3, x4, #0x10
  200984:	8b000260 	add	x0, x19, x0
    while (n-- > 0) {
  200988:	d2800001 	mov	x1, #0x0                   	// #0
  20098c:	d344fc63 	lsr	x3, x3, #4
  200990:	91000463 	add	x3, x3, #0x1
  200994:	d503201f 	nop
        *p++ = c;
  200998:	91000421 	add	x1, x1, #0x1
  20099c:	3c810400 	str	q0, [x0], #16
    while (n-- > 0) {
  2009a0:	eb01007f 	cmp	x3, x1
  2009a4:	54ffffa8 	b.hi	200998 <process_arp_waiting+0x2b8>  // b.pmore
  2009a8:	d37cec63 	lsl	x3, x3, #4
  2009ac:	8b0300b3 	add	x19, x5, x3
  2009b0:	cb030042 	sub	x2, x2, x3
  2009b4:	eb04007f 	cmp	x3, x4
  2009b8:	540000e0 	b.eq	2009d4 <process_arp_waiting+0x2f4>  // b.none
  2009bc:	91000440 	add	x0, x2, #0x1
  2009c0:	8b000260 	add	x0, x19, x0
  2009c4:	d503201f 	nop
        *p++ = c;
  2009c8:	3800167f 	strb	wzr, [x19], #1
    while (n-- > 0) {
  2009cc:	eb00027f 	cmp	x19, x0
  2009d0:	54ffffc1 	b.ne	2009c8 <process_arp_waiting+0x2e8>  // b.any
    while (!arp_queue_empty_response(arp_queries)) {
  2009d4:	f9400282 	ldr	x2, [x20]
    return queue->response.tail - queue->response.head == 0;
  2009d8:	79700c40 	ldrh	w0, [x2, #6150]
  2009dc:	79700841 	ldrh	w1, [x2, #6148]
  2009e0:	6b00003f 	cmp	w1, w0
  2009e4:	54ffea21 	b.ne	200728 <process_arp_waiting+0x48>  // b.any
  2009e8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2009ec:	a94363f7 	ldp	x23, x24, [sp, #48]
  2009f0:	f94023f9 	ldr	x25, [sp, #64]
        }

        llfree(&pkt_waiting_queue, (void *)waiting_packet);
    }

}
  2009f4:	a94153f3 	ldp	x19, x20, [sp, #16]
  2009f8:	a8c57bfd 	ldp	x29, x30, [sp], #80
  2009fc:	d65f03c0 	ret
        if (!response.valid && waiting_packet->valid) {
  200a00:	d2800013 	mov	x19, #0x0                   	// #0
  200a04:	34ffed24 	cbz	w4, 2007a8 <process_arp_waiting+0xc8>
            if (response.ip_addr == waiting_packet->ip) {
  200a08:	b9401260 	ldr	w0, [x19, #16]
  200a0c:	6b03001f 	cmp	w0, w3
  200a10:	54ffefa1 	b.ne	200804 <process_arp_waiting+0x124>  // b.any
  200a14:	d503201f 	nop
                struct ipv4_packet *pkt = (struct ipv4_packet *)(router_config.filters[waiting_packet->filter].data.vaddr + waiting_packet->buffer.io_or_offset);
  200a18:	79405260 	ldrh	w0, [x19, #40]
  200a1c:	d2800702 	mov	x2, #0x38                  	// #56
  200a20:	f9400e61 	ldr	x1, [x19, #24]
  200a24:	9b025c00 	madd	x0, x0, x2, x23
  200a28:	f9403800 	ldr	x0, [x0, #112]
  200a2c:	8b010019 	add	x25, x0, x1
        *to++ = *from++;
  200a30:	38216806 	strb	w6, [x0, x1]
  200a34:	39000727 	strb	w7, [x25, #1]
  200a38:	39000b28 	strb	w8, [x25, #2]
  200a3c:	39000f29 	strb	w9, [x25, #3]
  200a40:	3900132a 	strb	w10, [x25, #4]
  200a44:	3900172b 	strb	w11, [x25, #5]
                sddf_memcpy(pkt->ethsrc_addr, device_info->mac, ETH_HWADDR_LEN);
  200a48:	f942fa80 	ldr	x0, [x20, #1520]
  200a4c:	39400001 	ldrb	w1, [x0]
  200a50:	39001b21 	strb	w1, [x25, #6]
  200a54:	39400401 	ldrb	w1, [x0, #1]
  200a58:	39001f21 	strb	w1, [x25, #7]
  200a5c:	39400801 	ldrb	w1, [x0, #2]
  200a60:	39002321 	strb	w1, [x25, #8]
    return queue->free->tail - queue->free->head == 0;
  200a64:	f942fe81 	ldr	x1, [x20, #1528]
  200a68:	39400c02 	ldrb	w2, [x0, #3]
  200a6c:	39002722 	strb	w2, [x25, #9]
  200a70:	39401002 	ldrb	w2, [x0, #4]
  200a74:	39002b22 	strb	w2, [x25, #10]
  200a78:	39401400 	ldrb	w0, [x0, #5]
  200a7c:	39002f20 	strb	w0, [x25, #11]
  200a80:	79400422 	ldrh	w2, [x1, #2]
 *
 * @return -1 when queue is empty, 0 on success.
 */
static inline int net_dequeue_free(net_queue_handle_t *queue, net_buff_desc_t *buffer)
{
    if (net_queue_empty_free(queue)) {
  200a84:	79400020 	ldrh	w0, [x1]
  200a88:	6b02001f 	cmp	w0, w2
  200a8c:	540016a0 	b.eq	200d60 <process_arp_waiting+0x680>  // b.none
        return -1;
    }

    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200a90:	b9460a83 	ldr	w3, [x20, #1544]
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->free->head++;
  200a94:	11000444 	add	w4, w2, #0x1
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  200a98:	1ac30840 	udiv	w0, w2, w3
  200a9c:	1b038800 	msub	w0, w0, w3, w2
  200aa0:	8b001020 	add	x0, x1, x0, lsl #4
  200aa4:	f9400418 	ldr	x24, [x0, #8]
    queue->free->head++;
  200aa8:	79000424 	strh	w4, [x1, #2]
                sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[waiting_packet->filter].data.vaddr + waiting_packet->buffer.io_or_offset), waiting_packet->buffer.len);
  200aac:	79405260 	ldrh	w0, [x19, #40]
  200ab0:	d2800701 	mov	x1, #0x38                  	// #56
  200ab4:	79404264 	ldrh	w4, [x19, #32]
  200ab8:	f9400e63 	ldr	x3, [x19, #24]
    while (n-- > 0) {
  200abc:	d1000486 	sub	x6, x4, #0x1
  200ac0:	9b015c00 	madd	x0, x0, x1, x23
  200ac4:	f94036c1 	ldr	x1, [x22, #104]
  200ac8:	f9403800 	ldr	x0, [x0, #112]
                pkt->check = 0;
  200acc:	3900633f 	strb	wzr, [x25, #24]
  200ad0:	3900673f 	strb	wzr, [x25, #25]
                sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[waiting_packet->filter].data.vaddr + waiting_packet->buffer.io_or_offset), waiting_packet->buffer.len);
  200ad4:	8b180021 	add	x1, x1, x24
  200ad8:	8b030002 	add	x2, x0, x3
  200adc:	b40012c4 	cbz	x4, 200d34 <process_arp_waiting+0x654>
  200ae0:	f10038df 	cmp	x6, #0xe
  200ae4:	540011a9 	b.ls	200d18 <process_arp_waiting+0x638>  // b.plast
  200ae8:	91000463 	add	x3, x3, #0x1
  200aec:	aa020025 	orr	x5, x1, x2
  200af0:	8b030003 	add	x3, x0, x3
  200af4:	d2800000 	mov	x0, #0x0                   	// #0
  200af8:	cb030023 	sub	x3, x1, x3
  200afc:	f2400cbf 	tst	x5, #0xf
  200b00:	fa4e0860 	ccmp	x3, #0xe, #0x0, eq	// eq = none
  200b04:	54000708 	b.hi	200be4 <process_arp_waiting+0x504>  // b.pmore
        *to++ = *from++;
  200b08:	38606843 	ldrb	w3, [x2, x0]
  200b0c:	38206823 	strb	w3, [x1, x0]
    while (n-- > 0) {
  200b10:	91000400 	add	x0, x0, #0x1
  200b14:	eb00009f 	cmp	x4, x0
  200b18:	54ffff81 	b.ne	200b08 <process_arp_waiting+0x428>  // b.any
                buffer_tx.len = waiting_packet->buffer.len;
  200b1c:	79404265 	ldrh	w5, [x19, #32]
    return queue->active->tail - queue->active->head == queue->capacity;
  200b20:	f9430281 	ldr	x1, [x20, #1536]
  200b24:	b9460a83 	ldr	w3, [x20, #1544]
  200b28:	79400022 	ldrh	w2, [x1]
  200b2c:	79400420 	ldrh	w0, [x1, #2]
  200b30:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  200b34:	6b03001f 	cmp	w0, w3
  200b38:	54001020 	b.eq	200d3c <process_arp_waiting+0x65c>  // b.none
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  200b3c:	1ac30840 	udiv	w0, w2, w3
  200b40:	d2800106 	mov	x6, #0x8                   	// #8
    queue->active->tail++;
  200b44:	11000444 	add	w4, w2, #0x1
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  200b48:	1b038800 	msub	w0, w0, w3, w2
  200b4c:	8b2050c0 	add	x0, x6, w0, uxtw #4
  200b50:	8b000022 	add	x2, x1, x0
  200b54:	f8206838 	str	x24, [x1, x0]
  200b58:	79001045 	strh	w5, [x2, #8]
    queue->active->tail++;
  200b5c:	79000024 	strh	w4, [x1]
    return queue->free->tail - queue->free->head == queue->capacity;
  200b60:	79405260 	ldrh	w0, [x19, #40]
  200b64:	d2800302 	mov	x2, #0x18                  	// #24
  200b68:	9100e281 	add	x1, x20, #0x38
                waiting_packet->buffer.len = 0;
  200b6c:	7900427f 	strh	wzr, [x19, #32]
                err = net_enqueue_free(&state.filter_queue[waiting_packet->filter], waiting_packet->buffer);
  200b70:	f9400e65 	ldr	x5, [x19, #24]
  200b74:	9b027c00 	mul	x0, x0, x2
  200b78:	8b000022 	add	x2, x1, x0
  200b7c:	f8606821 	ldr	x1, [x1, x0]
  200b80:	b9401043 	ldr	w3, [x2, #16]
  200b84:	79400420 	ldrh	w0, [x1, #2]
  200b88:	79400022 	ldrh	w2, [x1]
  200b8c:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  200b90:	6b03001f 	cmp	w0, w3
  200b94:	54000f80 	b.eq	200d84 <process_arp_waiting+0x6a4>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200b98:	1ac30840 	udiv	w0, w2, w3
    queue->free->tail++;
  200b9c:	11000444 	add	w4, w2, #0x1
  200ba0:	1b038800 	msub	w0, w0, w3, w2
  200ba4:	8b001020 	add	x0, x1, x0, lsl #4
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  200ba8:	f9000405 	str	x5, [x0, #8]
  200bac:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  200bb0:	79000024 	strh	w4, [x1]

static inline void microkit_deferred_notify(microkit_channel ch)
{
    microkit_have_signal = seL4_True;
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  200bb4:	39418ac0 	ldrb	w0, [x22, #98]
  200bb8:	d0000024 	adrp	x4, 206000 <state+0x188>
    microkit_have_signal = seL4_True;
  200bbc:	d0000022 	adrp	x2, 206000 <state+0x188>
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  200bc0:	d0000021 	adrp	x1, 206000 <state+0x188>
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  200bc4:	91002800 	add	x0, x0, #0xa
    microkit_have_signal = seL4_True;
  200bc8:	52800023 	mov	w3, #0x1                   	// #1
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  200bcc:	f902a080 	str	x0, [x4, #1344]
    microkit_have_signal = seL4_True;
  200bd0:	3914c443 	strb	w3, [x2, #1329]
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  200bd4:	f9029c3f 	str	xzr, [x1, #1336]
    assert(info && node);
  200bd8:	17ffff0b 	b	200804 <process_arp_waiting+0x124>
        info->tail = prev;
  200bdc:	f9001680 	str	x0, [x20, #40]
  200be0:	17ffff0e 	b	200818 <process_arp_waiting+0x138>
  200be4:	d1004083 	sub	x3, x4, #0x10
  200be8:	d2800005 	mov	x5, #0x0                   	// #0
  200bec:	d344fc63 	lsr	x3, x3, #4
  200bf0:	91000463 	add	x3, x3, #0x1
  200bf4:	d503201f 	nop
        *to++ = *from++;
  200bf8:	3ce06840 	ldr	q0, [x2, x0]
  200bfc:	910004a5 	add	x5, x5, #0x1
  200c00:	eb05007f 	cmp	x3, x5
  200c04:	3ca06820 	str	q0, [x1, x0]
    while (n-- > 0) {
  200c08:	91004000 	add	x0, x0, #0x10
  200c0c:	54ffff68 	b.hi	200bf8 <process_arp_waiting+0x518>  // b.pmore
  200c10:	d37cec63 	lsl	x3, x3, #4
  200c14:	eb03009f 	cmp	x4, x3
  200c18:	cb0300c0 	sub	x0, x6, x3
  200c1c:	8b030045 	add	x5, x2, x3
  200c20:	8b030024 	add	x4, x1, x3
  200c24:	54fff7c0 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200c28:	38636842 	ldrb	w2, [x2, x3]
  200c2c:	38236822 	strb	w2, [x1, x3]
    while (n-- > 0) {
  200c30:	b4fff760 	cbz	x0, 200b1c <process_arp_waiting+0x43c>
        *to++ = *from++;
  200c34:	394004a1 	ldrb	w1, [x5, #1]
    while (n-- > 0) {
  200c38:	f100041f 	cmp	x0, #0x1
        *to++ = *from++;
  200c3c:	39000481 	strb	w1, [x4, #1]
    while (n-- > 0) {
  200c40:	54fff6e0 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200c44:	394008a1 	ldrb	w1, [x5, #2]
    while (n-- > 0) {
  200c48:	f100081f 	cmp	x0, #0x2
        *to++ = *from++;
  200c4c:	39000881 	strb	w1, [x4, #2]
    while (n-- > 0) {
  200c50:	54fff660 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200c54:	39400ca1 	ldrb	w1, [x5, #3]
    while (n-- > 0) {
  200c58:	f1000c1f 	cmp	x0, #0x3
        *to++ = *from++;
  200c5c:	39000c81 	strb	w1, [x4, #3]
    while (n-- > 0) {
  200c60:	54fff5e0 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200c64:	394010a1 	ldrb	w1, [x5, #4]
    while (n-- > 0) {
  200c68:	f100101f 	cmp	x0, #0x4
        *to++ = *from++;
  200c6c:	39001081 	strb	w1, [x4, #4]
    while (n-- > 0) {
  200c70:	54fff560 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200c74:	394014a1 	ldrb	w1, [x5, #5]
    while (n-- > 0) {
  200c78:	f100141f 	cmp	x0, #0x5
        *to++ = *from++;
  200c7c:	39001481 	strb	w1, [x4, #5]
    while (n-- > 0) {
  200c80:	54fff4e0 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200c84:	394018a1 	ldrb	w1, [x5, #6]
    while (n-- > 0) {
  200c88:	f100181f 	cmp	x0, #0x6
        *to++ = *from++;
  200c8c:	39001881 	strb	w1, [x4, #6]
    while (n-- > 0) {
  200c90:	54fff460 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200c94:	39401ca1 	ldrb	w1, [x5, #7]
    while (n-- > 0) {
  200c98:	f1001c1f 	cmp	x0, #0x7
        *to++ = *from++;
  200c9c:	39001c81 	strb	w1, [x4, #7]
    while (n-- > 0) {
  200ca0:	54fff3e0 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200ca4:	394020a1 	ldrb	w1, [x5, #8]
    while (n-- > 0) {
  200ca8:	f100201f 	cmp	x0, #0x8
        *to++ = *from++;
  200cac:	39002081 	strb	w1, [x4, #8]
    while (n-- > 0) {
  200cb0:	54fff360 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200cb4:	394024a1 	ldrb	w1, [x5, #9]
    while (n-- > 0) {
  200cb8:	f100241f 	cmp	x0, #0x9
        *to++ = *from++;
  200cbc:	39002481 	strb	w1, [x4, #9]
    while (n-- > 0) {
  200cc0:	54fff2e0 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200cc4:	394028a1 	ldrb	w1, [x5, #10]
    while (n-- > 0) {
  200cc8:	f100281f 	cmp	x0, #0xa
        *to++ = *from++;
  200ccc:	39002881 	strb	w1, [x4, #10]
    while (n-- > 0) {
  200cd0:	54fff260 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200cd4:	39402ca1 	ldrb	w1, [x5, #11]
    while (n-- > 0) {
  200cd8:	f1002c1f 	cmp	x0, #0xb
        *to++ = *from++;
  200cdc:	39002c81 	strb	w1, [x4, #11]
    while (n-- > 0) {
  200ce0:	54fff1e0 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200ce4:	394030a1 	ldrb	w1, [x5, #12]
    while (n-- > 0) {
  200ce8:	f100301f 	cmp	x0, #0xc
        *to++ = *from++;
  200cec:	39003081 	strb	w1, [x4, #12]
    while (n-- > 0) {
  200cf0:	54fff160 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200cf4:	394034a1 	ldrb	w1, [x5, #13]
    while (n-- > 0) {
  200cf8:	f100341f 	cmp	x0, #0xd
        *to++ = *from++;
  200cfc:	39003481 	strb	w1, [x4, #13]
    while (n-- > 0) {
  200d00:	54fff0e0 	b.eq	200b1c <process_arp_waiting+0x43c>  // b.none
        *to++ = *from++;
  200d04:	394038a0 	ldrb	w0, [x5, #14]
  200d08:	39003880 	strb	w0, [x4, #14]
    while (n-- > 0) {
  200d0c:	17ffff84 	b	200b1c <process_arp_waiting+0x43c>
    while (n-- > 0) {
  200d10:	aa1303e5 	mov	x5, x19
  200d14:	17ffff19 	b	200978 <process_arp_waiting+0x298>
    while (n-- > 0) {
  200d18:	d2800000 	mov	x0, #0x0                   	// #0
        *to++ = *from++;
  200d1c:	38606843 	ldrb	w3, [x2, x0]
  200d20:	38206823 	strb	w3, [x1, x0]
    while (n-- > 0) {
  200d24:	91000400 	add	x0, x0, #0x1
  200d28:	eb00009f 	cmp	x4, x0
  200d2c:	54ffeee1 	b.ne	200b08 <process_arp_waiting+0x428>  // b.any
  200d30:	17ffff7b 	b	200b1c <process_arp_waiting+0x43c>
  200d34:	52800005 	mov	w5, #0x0                   	// #0
  200d38:	17ffff7a 	b	200b20 <process_arp_waiting+0x440>
                assert(!err);
  200d3c:	f0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  200d40:	90000021 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  200d44:	913f2063 	add	x3, x3, #0xfc8
  200d48:	9103c021 	add	x1, x1, #0xf0
  200d4c:	90000020 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  200d50:	52800f22 	mov	w2, #0x79                  	// #121
  200d54:	9104e000 	add	x0, x0, #0x138
  200d58:	94000c7a 	bl	203f40 <_assert_fail>
  200d5c:	17ffff81 	b	200b60 <process_arp_waiting+0x480>
                assert(!err);
  200d60:	f0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  200d64:	90000021 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  200d68:	913f2063 	add	x3, x3, #0xfc8
  200d6c:	9103c021 	add	x1, x1, #0xf0
  200d70:	90000020 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  200d74:	52800e22 	mov	w2, #0x71                  	// #113
  200d78:	9104e000 	add	x0, x0, #0x138
  200d7c:	94000c71 	bl	203f40 <_assert_fail>
  200d80:	17ffff4b 	b	200aac <process_arp_waiting+0x3cc>
                assert(!err);
  200d84:	f0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  200d88:	90000021 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  200d8c:	913f2063 	add	x3, x3, #0xfc8
  200d90:	9103c021 	add	x1, x1, #0xf0
  200d94:	90000020 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  200d98:	52800f82 	mov	w2, #0x7c                  	// #124
  200d9c:	9104e000 	add	x0, x0, #0x138
  200da0:	94000c68 	bl	203f40 <_assert_fail>
  200da4:	17ffff84 	b	200bb4 <process_arp_waiting+0x4d4>
            assert(!err);
  200da8:	f0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  200dac:	90000021 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  200db0:	913f2063 	add	x3, x3, #0xfc8
  200db4:	9103c021 	add	x1, x1, #0xf0
  200db8:	90000020 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  200dbc:	52800d22 	mov	w2, #0x69                  	// #105
  200dc0:	9104e000 	add	x0, x0, #0x138
  200dc4:	94000c5f 	bl	203f40 <_assert_fail>
    assert(info && node);
  200dc8:	17fffe8f 	b	200804 <process_arp_waiting+0x124>
  200dcc:	d503201f 	nop

0000000000200dd0 <find_route>:
uint32_t find_route(uint32_t ip)
{
    // TODO: extend this function to match with the longest subnet mask,
    // and if tied in this step, find the route with the least hops.
    for (int i = 0; i < NUM_ROUTES; i++) {
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200dd0:	b0000024 	adrp	x4, 205000 <__sel4_ipc_buffer>
  200dd4:	91390084 	add	x4, x4, #0xe40
{
  200dd8:	2a0003e2 	mov	w2, w0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200ddc:	91184081 	add	x1, x4, #0x610
  200de0:	b9461080 	ldr	w0, [x4, #1552]
  200de4:	b9400423 	ldr	w3, [x1, #4]
  200de8:	4a000040 	eor	w0, w2, w0
  200dec:	6a03001f 	tst	w0, w3
  200df0:	540004e0 	b.eq	200e8c <find_route+0xbc>  // b.none
  200df4:	29418c20 	ldp	w0, w3, [x1, #12]
  200df8:	4a000040 	eor	w0, w2, w0
  200dfc:	6a03001f 	tst	w0, w3
  200e00:	54000500 	b.eq	200ea0 <find_route+0xd0>  // b.none
  200e04:	29430c20 	ldp	w0, w3, [x1, #24]
  200e08:	4a000040 	eor	w0, w2, w0
  200e0c:	6a03001f 	tst	w0, w3
  200e10:	54000500 	b.eq	200eb0 <find_route+0xe0>  // b.none
  200e14:	29448c20 	ldp	w0, w3, [x1, #36]
  200e18:	4a000040 	eor	w0, w2, w0
  200e1c:	6a03001f 	tst	w0, w3
  200e20:	540004c0 	b.eq	200eb8 <find_route+0xe8>  // b.none
  200e24:	29460c20 	ldp	w0, w3, [x1, #48]
  200e28:	4a000040 	eor	w0, w2, w0
  200e2c:	6a03001f 	tst	w0, w3
  200e30:	54000480 	b.eq	200ec0 <find_route+0xf0>  // b.none
  200e34:	29478c20 	ldp	w0, w3, [x1, #60]
  200e38:	4a000040 	eor	w0, w2, w0
  200e3c:	6a03001f 	tst	w0, w3
  200e40:	54000440 	b.eq	200ec8 <find_route+0xf8>  // b.none
  200e44:	29490c20 	ldp	w0, w3, [x1, #72]
  200e48:	4a000040 	eor	w0, w2, w0
  200e4c:	6a03001f 	tst	w0, w3
  200e50:	54000400 	b.eq	200ed0 <find_route+0x100>  // b.none
  200e54:	294a8c20 	ldp	w0, w3, [x1, #84]
  200e58:	4a000040 	eor	w0, w2, w0
  200e5c:	6a03001f 	tst	w0, w3
  200e60:	540003c0 	b.eq	200ed8 <find_route+0x108>  // b.none
  200e64:	294c0c20 	ldp	w0, w3, [x1, #96]
  200e68:	4a000040 	eor	w0, w2, w0
  200e6c:	6a03001f 	tst	w0, w3
  200e70:	54000380 	b.eq	200ee0 <find_route+0x110>  // b.none
  200e74:	294d8423 	ldp	w3, w1, [x1, #108]
            return routing_table[i].next_hop;
        }
    }

    // If we have gotten here, assume on the default gateway.
    return 0;
  200e78:	52800000 	mov	w0, #0x0                   	// #0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200e7c:	4a030042 	eor	w2, w2, w3
  200e80:	6a01005f 	tst	w2, w1
  200e84:	54000120 	b.eq	200ea8 <find_route+0xd8>  // b.none
}
  200e88:	d65f03c0 	ret
    for (int i = 0; i < NUM_ROUTES; i++) {
  200e8c:	d2800000 	mov	x0, #0x0                   	// #0
            return routing_table[i].next_hop;
  200e90:	d2800181 	mov	x1, #0xc                   	// #12
  200e94:	9b011000 	madd	x0, x0, x1, x4
  200e98:	b9461800 	ldr	w0, [x0, #1560]
}
  200e9c:	d65f03c0 	ret
    for (int i = 0; i < NUM_ROUTES; i++) {
  200ea0:	d2800020 	mov	x0, #0x1                   	// #1
  200ea4:	17fffffb 	b	200e90 <find_route+0xc0>
  200ea8:	d2800120 	mov	x0, #0x9                   	// #9
  200eac:	17fffff9 	b	200e90 <find_route+0xc0>
  200eb0:	d2800040 	mov	x0, #0x2                   	// #2
  200eb4:	17fffff7 	b	200e90 <find_route+0xc0>
  200eb8:	d2800060 	mov	x0, #0x3                   	// #3
  200ebc:	17fffff5 	b	200e90 <find_route+0xc0>
  200ec0:	d2800080 	mov	x0, #0x4                   	// #4
  200ec4:	17fffff3 	b	200e90 <find_route+0xc0>
  200ec8:	d28000a0 	mov	x0, #0x5                   	// #5
  200ecc:	17fffff1 	b	200e90 <find_route+0xc0>
  200ed0:	d28000c0 	mov	x0, #0x6                   	// #6
  200ed4:	17ffffef 	b	200e90 <find_route+0xc0>
  200ed8:	d28000e0 	mov	x0, #0x7                   	// #7
  200edc:	17ffffed 	b	200e90 <find_route+0xc0>
  200ee0:	d2800100 	mov	x0, #0x8                   	// #8
  200ee4:	17ffffeb 	b	200e90 <find_route+0xc0>
  200ee8:	d503201f 	nop
  200eec:	d503201f 	nop

0000000000200ef0 <route>:



void route()
{
  200ef0:	a9b87bfd 	stp	x29, x30, [sp, #-128]!
  200ef4:	910003fd 	mov	x29, sp
  200ef8:	a90153f3 	stp	x19, x20, [sp, #16]
    // Check the IP address of the packet.
    bool transmitted = false;
    for (int filter = 0; filter < router_config.num_filters; filter++) {
  200efc:	b0000033 	adrp	x19, 205000 <__sel4_ipc_buffer>
  200f00:	91026273 	add	x19, x19, #0x98
  200f04:	795b4260 	ldrh	w0, [x19, #3488]
  200f08:	34001720 	cbz	w0, 2011ec <route+0x2fc>
  200f0c:	a9025bf5 	stp	x21, x22, [sp, #32]
  200f10:	b0000036 	adrp	x22, 205000 <__sel4_ipc_buffer>
  200f14:	913902d6 	add	x22, x22, #0xe40
  200f18:	a90363f7 	stp	x23, x24, [sp, #48]
  200f1c:	9100e2d7 	add	x23, x22, #0x38
  200f20:	aa1303f8 	mov	x24, x19
                        int err = net_dequeue_free(&virt_tx_queue, &buffer_tx);
                        assert(!err);

                        // @kwinter: For now we are memcpy'ing the packet from our receive buffer
                        // to the transmit buffer.
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  200f24:	b0000034 	adrp	x20, 205000 <__sel4_ipc_buffer>
  200f28:	91002280 	add	x0, x20, #0x8
    bool transmitted = false;
  200f2c:	52800015 	mov	w21, #0x0                   	// #0
  200f30:	a9046bf9 	stp	x25, x26, [sp, #64]
    return key % TABLE_SIZE;
  200f34:	5290a3fa 	mov	w26, #0x851f                	// #34079
  200f38:	72aa3d7a 	movk	w26, #0x51eb, lsl #16
  200f3c:	a90573fb 	stp	x27, x28, [sp, #80]
    for (int filter = 0; filter < router_config.num_filters; filter++) {
  200f40:	5280001b 	mov	w27, #0x0                   	// #0
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  200f44:	f90033e0 	str	x0, [sp, #96]
    return queue->active->tail - queue->active->head == 0;
  200f48:	f94006e3 	ldr	x3, [x23, #8]
  200f4c:	52800c99 	mov	w25, #0x64                  	// #100
  200f50:	79400461 	ldrh	w1, [x3, #2]
  200f54:	79400068 	ldrh	w8, [x3]
            while (!net_queue_empty_active(&state.filter_queue[filter]) && !net_queue_empty_free(&virt_tx_queue)) {
  200f58:	6b01011f 	cmp	w8, w1
  200f5c:	540000a1 	b.ne	200f70 <route+0x80>  // b.any
  200f60:	14000094 	b	2011b0 <route+0x2c0>
  200f64:	79400461 	ldrh	w1, [x3, #2]
  200f68:	6b08003f 	cmp	w1, w8
  200f6c:	54001220 	b.eq	2011b0 <route+0x2c0>  // b.none
    return queue->free->tail - queue->free->head == 0;
  200f70:	f942fec0 	ldr	x0, [x22, #1528]
  200f74:	79400002 	ldrh	w2, [x0]
  200f78:	79400400 	ldrh	w0, [x0, #2]
  200f7c:	6b00005f 	cmp	w2, w0
  200f80:	540013c0 	b.eq	2011f8 <route+0x308>  // b.none
{
    if (net_queue_empty_active(queue)) {
        return -1;
    }

    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  200f84:	b94012e2 	ldr	w2, [x23, #16]
#ifdef CONFIG_ENABLE_SMP_SUPPORT
    THREAD_MEMORY_RELEASE();
#endif
    queue->active->head++;
  200f88:	11000427 	add	w7, w1, #0x1
                struct ipv4_packet *pkt = (struct ipv4_packet *)(router_config.filters[filter].data.vaddr + buffer.io_or_offset);
  200f8c:	f9403b06 	ldr	x6, [x24, #112]
    *buffer = queue->active->buffers[queue->active->head % queue->capacity];
  200f90:	1ac20820 	udiv	w0, w1, w2
  200f94:	1b028400 	msub	w0, w0, w2, w1
  200f98:	8b001060 	add	x0, x3, x0, lsl #4
  200f9c:	f9400414 	ldr	x20, [x0, #8]
  200fa0:	79402005 	ldrh	w5, [x0, #16]
  200fa4:	8b1400c2 	add	x2, x6, x20
    queue->active->head++;
  200fa8:	79000467 	strh	w7, [x3, #2]
                if (pkt->ttl > 1 && pkt->type == HTONS(ETH_TYPE_IP)) {
  200fac:	39405841 	ldrb	w1, [x2, #22]
  200fb0:	7100043f 	cmp	w1, #0x1
  200fb4:	54fffd89 	b.ls	200f64 <route+0x74>  // b.plast
  200fb8:	39403047 	ldrb	w7, [x2, #12]
  200fbc:	39403440 	ldrb	w0, [x2, #13]
  200fc0:	2a0020e0 	orr	w0, w7, w0, lsl #8
  200fc4:	7100201f 	cmp	w0, #0x8
  200fc8:	54fffce1 	b.ne	200f64 <route+0x74>  // b.any
                    uint32_t destIP = pkt->dst_ip;
  200fcc:	39407847 	ldrb	w7, [x2, #30]
                    pkt->ttl -= 1;
  200fd0:	51000421 	sub	w1, w1, #0x1
                    uint32_t destIP = pkt->dst_ip;
  200fd4:	39407c49 	ldrb	w9, [x2, #31]
  200fd8:	39408048 	ldrb	w8, [x2, #32]
  200fdc:	39408440 	ldrb	w0, [x2, #33]
  200fe0:	aa0920e9 	orr	x9, x7, x9, lsl #8
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200fe4:	b94612c7 	ldr	w7, [x22, #1552]
                    uint32_t destIP = pkt->dst_ip;
  200fe8:	aa084128 	orr	x8, x9, x8, lsl #16
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200fec:	b94616c9 	ldr	w9, [x22, #1556]
                    uint32_t destIP = pkt->dst_ip;
  200ff0:	aa006100 	orr	x0, x8, x0, lsl #24
                    pkt->ttl -= 1;
  200ff4:	39005841 	strb	w1, [x2, #22]
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  200ff8:	4a0000e1 	eor	w1, w7, w0
                    uint32_t destIP = pkt->dst_ip;
  200ffc:	2a0003ea 	mov	w10, w0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  201000:	6a09003f 	tst	w1, w9
  201004:	54003120 	b.eq	201628 <route+0x738>  // b.none
  201008:	b9461ec1 	ldr	w1, [x22, #1564]
  20100c:	b94622c7 	ldr	w7, [x22, #1568]
  201010:	4a000021 	eor	w1, w1, w0
  201014:	6a07003f 	tst	w1, w7
  201018:	54003180 	b.eq	201648 <route+0x758>  // b.none
  20101c:	b9462ac1 	ldr	w1, [x22, #1576]
  201020:	b9462ec7 	ldr	w7, [x22, #1580]
  201024:	4a000021 	eor	w1, w1, w0
  201028:	6a07003f 	tst	w1, w7
  20102c:	54003120 	b.eq	201650 <route+0x760>  // b.none
  201030:	b94636c1 	ldr	w1, [x22, #1588]
  201034:	b9463ac7 	ldr	w7, [x22, #1592]
  201038:	4a000021 	eor	w1, w1, w0
  20103c:	6a07003f 	tst	w1, w7
  201040:	540030c0 	b.eq	201658 <route+0x768>  // b.none
  201044:	b94642c1 	ldr	w1, [x22, #1600]
  201048:	b94646c7 	ldr	w7, [x22, #1604]
  20104c:	4a000021 	eor	w1, w1, w0
  201050:	6a07003f 	tst	w1, w7
  201054:	54003060 	b.eq	201660 <route+0x770>  // b.none
  201058:	b9464ec1 	ldr	w1, [x22, #1612]
  20105c:	b94652c7 	ldr	w7, [x22, #1616]
  201060:	4a000021 	eor	w1, w1, w0
  201064:	6a07003f 	tst	w1, w7
  201068:	54003000 	b.eq	201668 <route+0x778>  // b.none
  20106c:	b9465ac1 	ldr	w1, [x22, #1624]
  201070:	b9465ec3 	ldr	w3, [x22, #1628]
  201074:	4a000021 	eor	w1, w1, w0
  201078:	6a03003f 	tst	w1, w3
  20107c:	54002fa0 	b.eq	201670 <route+0x780>  // b.none
  201080:	b94666c3 	ldr	w3, [x22, #1636]
  201084:	b9466ac7 	ldr	w7, [x22, #1640]
  201088:	4a000063 	eor	w3, w3, w0
  20108c:	6a07007f 	tst	w3, w7
  201090:	54002f40 	b.eq	201678 <route+0x788>  // b.none
  201094:	b94672c3 	ldr	w3, [x22, #1648]
  201098:	b94676c7 	ldr	w7, [x22, #1652]
  20109c:	4a000063 	eor	w3, w3, w0
  2010a0:	6a07007f 	tst	w3, w7
  2010a4:	54002ee0 	b.eq	201680 <route+0x790>  // b.none
  2010a8:	b9467ec3 	ldr	w3, [x22, #1660]
                        nextIP = destIP;
  2010ac:	2a0003e9 	mov	w9, w0
        if ((ip & routing_table[i].subnet_mask) == (routing_table[i].network_id & routing_table[i].subnet_mask)) {
  2010b0:	b94682c7 	ldr	w7, [x22, #1664]
  2010b4:	4a000061 	eor	w1, w3, w0
  2010b8:	6a07003f 	tst	w1, w7
  2010bc:	54002e60 	b.eq	201688 <route+0x798>  // b.none
  2010c0:	9bba7d28 	umull	x8, w9, w26
        if (table->entries[index].key == key) {
  2010c4:	d280018b 	mov	x11, #0xc                   	// #12
                    int ret = hashtable_search(arp_table, (uint32_t) nextIP, &hash_entry);
  2010c8:	f94346c3 	ldr	x3, [x22, #1672]
    return key % TABLE_SIZE;
  2010cc:	d365fd08 	lsr	x8, x8, #37
  2010d0:	1b19a508 	msub	w8, w8, w25, w9
    uint32_t index = hash(key);
  2010d4:	2a0803e0 	mov	w0, w8
    while (table->used[index]) {
  2010d8:	1400000b 	b	201104 <route+0x214>
        if (table->entries[index].key == key) {
  2010dc:	9b0b7c21 	mul	x1, x1, x11
  2010e0:	b8616861 	ldr	w1, [x3, x1]
  2010e4:	6b01013f 	cmp	w9, w1
  2010e8:	540008e0 	b.eq	201204 <route+0x314>  // b.none
        index = (index + 1) % TABLE_SIZE;
  2010ec:	11000401 	add	w1, w0, #0x1
  2010f0:	9bba7c20 	umull	x0, w1, w26
  2010f4:	d365fc00 	lsr	x0, x0, #37
  2010f8:	1b198400 	msub	w0, w0, w25, w1
        if (index == original_index) {
  2010fc:	6b00011f 	cmp	w8, w0
  201100:	540000a0 	b.eq	201114 <route+0x224>  // b.none
    while (table->used[index]) {
  201104:	2a0003e1 	mov	w1, w0
  201108:	8b010067 	add	x7, x3, x1
  20110c:	3952c0e7 	ldrb	w7, [x7, #1200]
  201110:	35fffe67 	cbnz	w7, 2010dc <route+0x1ec>
                    if (ret == -1 && !llfull(&pkt_waiting_queue)) {
  201114:	f9400ec0 	ldr	x0, [x22, #24]
  201118:	b40027a0 	cbz	x0, 20160c <route+0x71c>
                        if (!arp_queue_full_request(arp_queries) && !check_waiting(&pkt_waiting_queue, destIP)) {
  20111c:	f94002c2 	ldr	x2, [x22]
    return queue->request.tail - queue->request.head == queue->capacity;
  201120:	79400046 	ldrh	w6, [x2]
  201124:	79400440 	ldrh	w0, [x2, #2]
  201128:	b9700843 	ldr	w3, [x2, #12296]
  20112c:	4b0000c0 	sub	w0, w6, w0
  201130:	6b03001f 	cmp	w0, w3
  201134:	54000120 	b.eq	201158 <route+0x268>  // b.none
    struct llnode_ptrs *curr = LLNODE_PTRS_CAST(info->head);
  201138:	f94012c0 	ldr	x0, [x22, #32]
    while (curr != NULL) {
  20113c:	b5000080 	cbnz	x0, 20114c <route+0x25c>
  201140:	140000fd 	b	201534 <route+0x644>
        curr = LLNODE_PTRS_CAST(curr->next);
  201144:	f9400000 	ldr	x0, [x0]
    while (curr != NULL) {
  201148:	b4001f60 	cbz	x0, 201534 <route+0x644>
        if (curr_node->ip == ip) {
  20114c:	b9401001 	ldr	w1, [x0, #16]
  201150:	6b01015f 	cmp	w10, w1
  201154:	54ffff81 	b.ne	201144 <route+0x254>  // b.any
                            sddf_dprintf("ROUTING| ARP request queue was full!\n");
  201158:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  20115c:	91050000 	add	x0, x0, #0x140
  201160:	94000abc 	bl	203c50 <sddf_printf_>
    return queue->free->tail - queue->free->head == queue->capacity;
  201164:	f94002e1 	ldr	x1, [x23]
  201168:	b94012e3 	ldr	w3, [x23, #16]
  20116c:	79400022 	ldrh	w2, [x1]
  201170:	79400420 	ldrh	w0, [x1, #2]
  201174:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  201178:	6b03001f 	cmp	w0, w3
  20117c:	54002b20 	b.eq	2016e0 <route+0x7f0>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201180:	1ac30840 	udiv	w0, w2, w3
    queue->free->tail++;
  201184:	11000445 	add	w5, w2, #0x1
  201188:	1b038800 	msub	w0, w0, w3, w2
  20118c:	8b001020 	add	x0, x1, x0, lsl #4
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201190:	f9000414 	str	x20, [x0, #8]
  201194:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  201198:	79000025 	strh	w5, [x1]
    return queue->active->tail - queue->active->head == 0;
  20119c:	f94006e3 	ldr	x3, [x23, #8]
  2011a0:	79400068 	ldrh	w8, [x3]
  2011a4:	79400461 	ldrh	w1, [x3, #2]
            while (!net_queue_empty_active(&state.filter_queue[filter]) && !net_queue_empty_free(&virt_tx_queue)) {
  2011a8:	6b08003f 	cmp	w1, w8
  2011ac:	54ffee21 	b.ne	200f70 <route+0x80>  // b.any
    for (int filter = 0; filter < router_config.num_filters; filter++) {
  2011b0:	795b4260 	ldrh	w0, [x19, #3488]
  2011b4:	1100077b 	add	w27, w27, #0x1
 *
 * @param queue queue handle of active queue that requires signalling upon enqueuing.
 */
static inline void net_request_signal_active(net_queue_handle_t *queue)
{
    queue->active->consumer_signalled = 0;
  2011b8:	b900047f 	str	wzr, [x3, #4]
  2011bc:	910062f7 	add	x23, x23, #0x18
  2011c0:	9100e318 	add	x24, x24, #0x38
  2011c4:	6b1b001f 	cmp	w0, w27
  2011c8:	54ffec0c 	b.gt	200f48 <route+0x58>
                reprocess = true;
            }
        }
    }

    if (transmitted && net_require_signal_active(&virt_tx_queue)) {
  2011cc:	34000095 	cbz	w21, 2011dc <route+0x2ec>
 *
 * @param queue queue handle of the active queue to check.
 */
static inline bool net_require_signal_active(net_queue_handle_t *queue)
{
    return !queue->active->consumer_signalled;
  2011d0:	f94302c2 	ldr	x2, [x22, #1536]
  2011d4:	b9400440 	ldr	w0, [x2, #4]
  2011d8:	34002600 	cbz	w0, 201698 <route+0x7a8>
  2011dc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2011e0:	a94363f7 	ldp	x23, x24, [sp, #48]
  2011e4:	a9446bf9 	ldp	x25, x26, [sp, #64]
  2011e8:	a94573fb 	ldp	x27, x28, [sp, #80]
        net_cancel_signal_active(&virt_tx_queue);
        microkit_deferred_notify(net_config.tx.id);
    }

}
  2011ec:	a94153f3 	ldp	x19, x20, [sp, #16]
  2011f0:	a8c87bfd 	ldp	x29, x30, [sp], #128
  2011f4:	d65f03c0 	ret
    queue->active->consumer_signalled = 1;
  2011f8:	52800020 	mov	w0, #0x1                   	// #1
  2011fc:	b9000460 	str	w0, [x3, #4]
                reprocess = true;
  201200:	17ffff56 	b	200f58 <route+0x68>
            sddf_memcpy(value, &table->entries[index].value, sizeof(entry_t));
  201204:	d2800081 	mov	x1, #0x4                   	// #4
  201208:	9bab0400 	umaddl	x0, w0, w11, x1
  20120c:	8b000061 	add	x1, x3, x0
        *to++ = *from++;
  201210:	3860686a 	ldrb	w10, [x3, x0]
  201214:	39400429 	ldrb	w9, [x1, #1]
  201218:	39400828 	ldrb	w8, [x1, #2]
  20121c:	39400c27 	ldrb	w7, [x1, #3]
  201220:	39401023 	ldrb	w3, [x1, #4]
  201224:	39401420 	ldrb	w0, [x1, #5]
  201228:	383468ca 	strb	w10, [x6, x20]
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  20122c:	2a0503f5 	mov	w21, w5
  201230:	39000449 	strb	w9, [x2, #1]
  201234:	39000848 	strb	w8, [x2, #2]
  201238:	39000c47 	strb	w7, [x2, #3]
  20123c:	39001043 	strb	w3, [x2, #4]
  201240:	39001440 	strb	w0, [x2, #5]
                        sddf_memcpy(&pkt->ethsrc_addr, device_info->mac, ETH_HWADDR_LEN);
  201244:	f942fac0 	ldr	x0, [x22, #1520]
  201248:	39400003 	ldrb	w3, [x0]
  20124c:	39001843 	strb	w3, [x2, #6]
  201250:	39400403 	ldrb	w3, [x0, #1]
  201254:	39001c43 	strb	w3, [x2, #7]
  201258:	39400803 	ldrb	w3, [x0, #2]
  20125c:	39002043 	strb	w3, [x2, #8]
    return queue->free->tail - queue->free->head == 0;
  201260:	f942fec3 	ldr	x3, [x22, #1528]
  201264:	39400c06 	ldrb	w6, [x0, #3]
  201268:	39002446 	strb	w6, [x2, #9]
  20126c:	39401006 	ldrb	w6, [x0, #4]
  201270:	39002846 	strb	w6, [x2, #10]
  201274:	39401400 	ldrb	w0, [x0, #5]
  201278:	39002c40 	strb	w0, [x2, #11]
                        pkt->check = 0;
  20127c:	3900605f 	strb	wzr, [x2, #24]
  201280:	79400466 	ldrh	w6, [x3, #2]
    if (net_queue_empty_free(queue)) {
  201284:	79400060 	ldrh	w0, [x3]
  201288:	3900645f 	strb	wzr, [x2, #25]
  20128c:	6b06001f 	cmp	w0, w6
  201290:	540023c0 	b.eq	201708 <route+0x818>  // b.none
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  201294:	f94033e0 	ldr	x0, [sp, #96]
    queue->free->head++;
  201298:	110004c8 	add	w8, w6, #0x1
    *buffer = queue->free->buffers[queue->free->head % queue->capacity];
  20129c:	b9460ac7 	ldr	w7, [x22, #1544]
  2012a0:	f9403b02 	ldr	x2, [x24, #112]
  2012a4:	f9403401 	ldr	x1, [x0, #104]
  2012a8:	8b140042 	add	x2, x2, x20
  2012ac:	1ac708c0 	udiv	w0, w6, w7
  2012b0:	1b079800 	msub	w0, w0, w7, w6
  2012b4:	8b001060 	add	x0, x3, x0, lsl #4
  2012b8:	f940041c 	ldr	x28, [x0, #8]
    queue->free->head++;
  2012bc:	79000468 	strh	w8, [x3, #2]
  2012c0:	8b1c0021 	add	x1, x1, x28
    while (n-- > 0) {
  2012c4:	aa020020 	orr	x0, x1, x2
  2012c8:	91000443 	add	x3, x2, #0x1
  2012cc:	cb030023 	sub	x3, x1, x3
  2012d0:	91008aa7 	add	x7, x21, #0x22
  2012d4:	f2400c1f 	tst	x0, #0xf
    uint32_t index = hash(key);
  2012d8:	d2800000 	mov	x0, #0x0                   	// #0
  2012dc:	fa4e0860 	ccmp	x3, #0xe, #0x0, eq	// eq = none
  2012e0:	54000528 	b.hi	201384 <route+0x494>  // b.pmore
  2012e4:	d503201f 	nop
        *to++ = *from++;
  2012e8:	38606843 	ldrb	w3, [x2, x0]
  2012ec:	38206823 	strb	w3, [x1, x0]
    while (n-- > 0) {
  2012f0:	91000400 	add	x0, x0, #0x1
  2012f4:	eb0000ff 	cmp	x7, x0
  2012f8:	54ffff81 	b.ne	2012e8 <route+0x3f8>  // b.any
    return queue->active->tail - queue->active->head == queue->capacity;
  2012fc:	f94302c1 	ldr	x1, [x22, #1536]
  201300:	b9460ac3 	ldr	w3, [x22, #1544]
  201304:	79400022 	ldrh	w2, [x1]
  201308:	79400420 	ldrh	w0, [x1, #2]
  20130c:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  201310:	6b03001f 	cmp	w0, w3
  201314:	54000dc0 	b.eq	2014cc <route+0x5dc>  // b.none
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  201318:	1ac30840 	udiv	w0, w2, w3
  20131c:	d2800107 	mov	x7, #0x8                   	// #8
    queue->active->tail++;
  201320:	11000446 	add	w6, w2, #0x1
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  201324:	1b038800 	msub	w0, w0, w3, w2
    return queue->free->tail - queue->free->head == queue->capacity;
  201328:	b94012e3 	ldr	w3, [x23, #16]
    queue->active->buffers[queue->active->tail % queue->capacity] = buffer;
  20132c:	8b2050e0 	add	x0, x7, w0, uxtw #4
  201330:	8b000022 	add	x2, x1, x0
  201334:	f820683c 	str	x28, [x1, x0]
  201338:	79001045 	strh	w5, [x2, #8]
    queue->active->tail++;
  20133c:	79000026 	strh	w6, [x1]
    return queue->free->tail - queue->free->head == queue->capacity;
  201340:	f94002e1 	ldr	x1, [x23]
  201344:	79400022 	ldrh	w2, [x1]
  201348:	79400420 	ldrh	w0, [x1, #2]
  20134c:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  201350:	6b03001f 	cmp	w0, w3
  201354:	54000dc0 	b.eq	20150c <route+0x61c>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201358:	1ac30840 	udiv	w0, w2, w3
    queue->free->tail++;
  20135c:	11000445 	add	w5, w2, #0x1
  201360:	1b038800 	msub	w0, w0, w3, w2
  201364:	8b001020 	add	x0, x1, x0, lsl #4
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201368:	f9000414 	str	x20, [x0, #8]
  20136c:	7900201f 	strh	wzr, [x0, #16]
    queue->free->tail++;
  201370:	79000025 	strh	w5, [x1]
    return queue->active->tail - queue->active->head == 0;
  201374:	f94006e3 	ldr	x3, [x23, #8]
                        transmitted = true;
  201378:	52800035 	mov	w21, #0x1                   	// #1
  20137c:	79400068 	ldrh	w8, [x3]
  201380:	17fffef9 	b	200f64 <route+0x74>
  201384:	91004aa3 	add	x3, x21, #0x12
  201388:	d2800006 	mov	x6, #0x0                   	// #0
  20138c:	d344fc63 	lsr	x3, x3, #4
  201390:	91000463 	add	x3, x3, #0x1
  201394:	d503201f 	nop
        *to++ = *from++;
  201398:	3ce06840 	ldr	q0, [x2, x0]
  20139c:	910004c6 	add	x6, x6, #0x1
  2013a0:	eb06007f 	cmp	x3, x6
  2013a4:	3ca06820 	str	q0, [x1, x0]
    while (n-- > 0) {
  2013a8:	91004000 	add	x0, x0, #0x10
  2013ac:	54ffff68 	b.hi	201398 <route+0x4a8>  // b.pmore
  2013b0:	d37cec63 	lsl	x3, x3, #4
  2013b4:	910086a0 	add	x0, x21, #0x21
  2013b8:	eb07007f 	cmp	x3, x7
  2013bc:	cb030000 	sub	x0, x0, x3
  2013c0:	8b030047 	add	x7, x2, x3
  2013c4:	8b030026 	add	x6, x1, x3
  2013c8:	54fff9a0 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  2013cc:	38636842 	ldrb	w2, [x2, x3]
  2013d0:	38236822 	strb	w2, [x1, x3]
    while (n-- > 0) {
  2013d4:	b4fff940 	cbz	x0, 2012fc <route+0x40c>
        *to++ = *from++;
  2013d8:	394004e1 	ldrb	w1, [x7, #1]
    while (n-- > 0) {
  2013dc:	f100041f 	cmp	x0, #0x1
        *to++ = *from++;
  2013e0:	390004c1 	strb	w1, [x6, #1]
    while (n-- > 0) {
  2013e4:	54fff8c0 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  2013e8:	394008e1 	ldrb	w1, [x7, #2]
    while (n-- > 0) {
  2013ec:	f100081f 	cmp	x0, #0x2
        *to++ = *from++;
  2013f0:	390008c1 	strb	w1, [x6, #2]
    while (n-- > 0) {
  2013f4:	54fff840 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  2013f8:	39400ce1 	ldrb	w1, [x7, #3]
    while (n-- > 0) {
  2013fc:	f1000c1f 	cmp	x0, #0x3
        *to++ = *from++;
  201400:	39000cc1 	strb	w1, [x6, #3]
    while (n-- > 0) {
  201404:	54fff7c0 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201408:	394010e1 	ldrb	w1, [x7, #4]
    while (n-- > 0) {
  20140c:	f100101f 	cmp	x0, #0x4
        *to++ = *from++;
  201410:	390010c1 	strb	w1, [x6, #4]
    while (n-- > 0) {
  201414:	54fff740 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201418:	394014e1 	ldrb	w1, [x7, #5]
    while (n-- > 0) {
  20141c:	f100141f 	cmp	x0, #0x5
        *to++ = *from++;
  201420:	390014c1 	strb	w1, [x6, #5]
    while (n-- > 0) {
  201424:	54fff6c0 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201428:	394018e1 	ldrb	w1, [x7, #6]
    while (n-- > 0) {
  20142c:	f100181f 	cmp	x0, #0x6
        *to++ = *from++;
  201430:	390018c1 	strb	w1, [x6, #6]
    while (n-- > 0) {
  201434:	54fff640 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201438:	39401ce1 	ldrb	w1, [x7, #7]
    while (n-- > 0) {
  20143c:	f1001c1f 	cmp	x0, #0x7
        *to++ = *from++;
  201440:	39001cc1 	strb	w1, [x6, #7]
    while (n-- > 0) {
  201444:	54fff5c0 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201448:	394020e1 	ldrb	w1, [x7, #8]
    while (n-- > 0) {
  20144c:	f100201f 	cmp	x0, #0x8
        *to++ = *from++;
  201450:	390020c1 	strb	w1, [x6, #8]
    while (n-- > 0) {
  201454:	54fff540 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201458:	394024e1 	ldrb	w1, [x7, #9]
    while (n-- > 0) {
  20145c:	f100241f 	cmp	x0, #0x9
        *to++ = *from++;
  201460:	390024c1 	strb	w1, [x6, #9]
    while (n-- > 0) {
  201464:	54fff4c0 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201468:	394028e1 	ldrb	w1, [x7, #10]
    while (n-- > 0) {
  20146c:	f100281f 	cmp	x0, #0xa
        *to++ = *from++;
  201470:	390028c1 	strb	w1, [x6, #10]
    while (n-- > 0) {
  201474:	54fff440 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201478:	39402ce1 	ldrb	w1, [x7, #11]
    while (n-- > 0) {
  20147c:	f1002c1f 	cmp	x0, #0xb
        *to++ = *from++;
  201480:	39002cc1 	strb	w1, [x6, #11]
    while (n-- > 0) {
  201484:	54fff3c0 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201488:	394030e1 	ldrb	w1, [x7, #12]
    while (n-- > 0) {
  20148c:	f100301f 	cmp	x0, #0xc
        *to++ = *from++;
  201490:	390030c1 	strb	w1, [x6, #12]
    while (n-- > 0) {
  201494:	54fff340 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  201498:	394034e1 	ldrb	w1, [x7, #13]
    while (n-- > 0) {
  20149c:	f100341f 	cmp	x0, #0xd
        *to++ = *from++;
  2014a0:	390034c1 	strb	w1, [x6, #13]
    while (n-- > 0) {
  2014a4:	54fff2c0 	b.eq	2012fc <route+0x40c>  // b.none
        *to++ = *from++;
  2014a8:	394038e0 	ldrb	w0, [x7, #14]
  2014ac:	390038c0 	strb	w0, [x6, #14]
    return queue->active->tail - queue->active->head == queue->capacity;
  2014b0:	f94302c1 	ldr	x1, [x22, #1536]
  2014b4:	b9460ac3 	ldr	w3, [x22, #1544]
  2014b8:	79400022 	ldrh	w2, [x1]
  2014bc:	79400420 	ldrh	w0, [x1, #2]
  2014c0:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_active(queue)) {
  2014c4:	6b03001f 	cmp	w0, w3
  2014c8:	54fff281 	b.ne	201318 <route+0x428>  // b.any
                        assert(!err);
  2014cc:	d0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  2014d0:	913f2063 	add	x3, x3, #0xfc8
  2014d4:	91006063 	add	x3, x3, #0x18
  2014d8:	52801da2 	mov	w2, #0xed                  	// #237
  2014dc:	f0000001 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  2014e0:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  2014e4:	9103c021 	add	x1, x1, #0xf0
  2014e8:	9104e000 	add	x0, x0, #0x138
  2014ec:	94000a95 	bl	203f40 <_assert_fail>
    return queue->free->tail - queue->free->head == queue->capacity;
  2014f0:	f94002e1 	ldr	x1, [x23]
  2014f4:	b94012e3 	ldr	w3, [x23, #16]
  2014f8:	79400022 	ldrh	w2, [x1]
  2014fc:	79400420 	ldrh	w0, [x1, #2]
  201500:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  201504:	6b03001f 	cmp	w0, w3
  201508:	54fff281 	b.ne	201358 <route+0x468>  // b.any
                    assert(!err);
  20150c:	d0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  201510:	913f2063 	add	x3, x3, #0xfc8
  201514:	91006063 	add	x3, x3, #0x18
  201518:	f0000001 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  20151c:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  201520:	9103c021 	add	x1, x1, #0xf0
  201524:	9104e000 	add	x0, x0, #0x138
  201528:	52801e22 	mov	w2, #0xf1                  	// #241
  20152c:	94000a85 	bl	203f40 <_assert_fail>
  201530:	17ffff91 	b	201374 <route+0x484>
    sddf_memcpy(&queue->request.queue[queue->request.tail % queue->capacity], &request, sizeof(arp_request_t));
  201534:	1ac308c1 	udiv	w1, w6, w3
  201538:	d2800080 	mov	x0, #0x4                   	// #4
  20153c:	5280018d 	mov	w13, #0xc                   	// #12
  201540:	d3483d2c 	ubfx	x12, x9, #8, #8
  201544:	d3505d28 	ubfx	x8, x9, #16, #8
  201548:	53187d27 	lsr	w7, w9, #24
  20154c:	5280002b 	mov	w11, #0x1                   	// #1
  201550:	1b039821 	msub	w1, w1, w3, w6
  201554:	9bad0021 	umaddl	x1, w1, w13, x0
  201558:	8b010040 	add	x0, x2, x1
  20155c:	38216849 	strb	w9, [x2, x1]
  201560:	3900040c 	strb	w12, [x0, #1]
  201564:	39000808 	strb	w8, [x0, #2]
  201568:	39000c07 	strb	w7, [x0, #3]
  20156c:	3900101f 	strb	wzr, [x0, #4]
  201570:	3900141f 	strb	wzr, [x0, #5]
  201574:	3900181f 	strb	wzr, [x0, #6]
  201578:	39001c1f 	strb	wzr, [x0, #7]
  20157c:	3900201f 	strb	wzr, [x0, #8]
  201580:	3900241f 	strb	wzr, [x0, #9]
  201584:	3900280b 	strb	w11, [x0, #10]
  201588:	39002c1f 	strb	wzr, [x0, #11]
    return (info->empty_head == NULL);
  20158c:	f9400ec0 	ldr	x0, [x22, #24]
    queue->request.tail++;
  201590:	79400041 	ldrh	w1, [x2]
  201594:	11000421 	add	w1, w1, #0x1
  201598:	79000041 	strh	w1, [x2]
    if (llfull(info)) {
  20159c:	b4000d80 	cbz	x0, 20174c <route+0x85c>
    info->empty_head = LLNODE_PTRS_CAST(info->empty_head)->next;
  2015a0:	f9400001 	ldr	x1, [x0]
  2015a4:	f9000ec1 	str	x1, [x22, #24]

static void llpush(struct ll_info *info, void *node)
{
    assert(info && node);

    LLNODE_PTRS_CAST(node)->next = info->head;
  2015a8:	f94012c1 	ldr	x1, [x22, #32]
  2015ac:	f9000001 	str	x1, [x0]
                        waiting_packet->ip = nextIP;
  2015b0:	b9001009 	str	w9, [x0, #16]
                        waiting_packet->valid = true;
  2015b4:	3900500b 	strb	w11, [x0, #20]
                        waiting_packet->buffer = buffer;
  2015b8:	f9000c14 	str	x20, [x0, #24]
  2015bc:	79004005 	strh	w5, [x0, #32]
                        waiting_packet->filter = filter;
  2015c0:	7900501b 	strh	w27, [x0, #40]
    if (info->head) {
  2015c4:	b4000041 	cbz	x1, 2015cc <route+0x6dc>
        LLNODE_PTRS_CAST(info->head)->prev = node;
  2015c8:	f9000420 	str	x0, [x1, #8]
    }
    info->head = node;

    if (!info->tail) {
  2015cc:	f94016c2 	ldr	x2, [x22, #40]
    info->head = node;
  2015d0:	f90012c0 	str	x0, [x22, #32]
    if (!info->tail) {
  2015d4:	b40005e2 	cbz	x2, 201690 <route+0x7a0>
        info->tail = node;
    }
    info->curr_size++;
  2015d8:	b94032c0 	ldr	w0, [x22, #48]
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  2015dc:	b0000026 	adrp	x6, 206000 <state+0x188>
  2015e0:	3940e261 	ldrb	w1, [x19, #56]
    microkit_have_signal = seL4_True;
  2015e4:	b0000024 	adrp	x4, 206000 <state+0x188>
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  2015e8:	b0000023 	adrp	x3, 206000 <state+0x188>
  2015ec:	11000400 	add	w0, w0, #0x1
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  2015f0:	91002821 	add	x1, x1, #0xa
    microkit_have_signal = seL4_True;
  2015f4:	52800025 	mov	w5, #0x1                   	// #1
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  2015f8:	f902a0c1 	str	x1, [x6, #1344]
    microkit_have_signal = seL4_True;
  2015fc:	3914c485 	strb	w5, [x4, #1329]
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  201600:	f9029c7f 	str	xzr, [x3, #1336]
  201604:	b90032c0 	str	w0, [x22, #48]
                        continue;
  201608:	17fffee5 	b	20119c <route+0x2ac>
  20160c:	3941e3ea 	ldrb	w10, [sp, #120]
  201610:	3941e7e9 	ldrb	w9, [sp, #121]
  201614:	3941ebe8 	ldrb	w8, [sp, #122]
  201618:	3941efe7 	ldrb	w7, [sp, #123]
  20161c:	3941f3e3 	ldrb	w3, [sp, #124]
  201620:	3941f7e0 	ldrb	w0, [sp, #125]
  201624:	17ffff01 	b	201228 <route+0x338>
    for (int i = 0; i < NUM_ROUTES; i++) {
  201628:	d2800001 	mov	x1, #0x0                   	// #0
  20162c:	d503201f 	nop
            return routing_table[i].next_hop;
  201630:	d2800183 	mov	x3, #0xc                   	// #12
  201634:	9b035821 	madd	x1, x1, x3, x22
  201638:	b9461829 	ldr	w9, [x1, #1560]
                        nextIP = destIP;
  20163c:	7100013f 	cmp	w9, #0x0
  201640:	1a801129 	csel	w9, w9, w0, ne	// ne = any
  201644:	17fffe9f 	b	2010c0 <route+0x1d0>
    for (int i = 0; i < NUM_ROUTES; i++) {
  201648:	d2800021 	mov	x1, #0x1                   	// #1
  20164c:	17fffff9 	b	201630 <route+0x740>
  201650:	d2800041 	mov	x1, #0x2                   	// #2
  201654:	17fffff7 	b	201630 <route+0x740>
  201658:	d2800061 	mov	x1, #0x3                   	// #3
  20165c:	17fffff5 	b	201630 <route+0x740>
  201660:	d2800081 	mov	x1, #0x4                   	// #4
  201664:	17fffff3 	b	201630 <route+0x740>
  201668:	d28000a1 	mov	x1, #0x5                   	// #5
  20166c:	17fffff1 	b	201630 <route+0x740>
  201670:	d28000c1 	mov	x1, #0x6                   	// #6
  201674:	17ffffef 	b	201630 <route+0x740>
  201678:	d28000e1 	mov	x1, #0x7                   	// #7
  20167c:	17ffffed 	b	201630 <route+0x740>
  201680:	d2800101 	mov	x1, #0x8                   	// #8
  201684:	17ffffeb 	b	201630 <route+0x740>
  201688:	d2800121 	mov	x1, #0x9                   	// #9
  20168c:	17ffffe9 	b	201630 <route+0x740>
        info->tail = node;
  201690:	f90016c0 	str	x0, [x22, #40]
  201694:	17ffffd1 	b	2015d8 <route+0x6e8>
}
  201698:	a9425bf5 	ldp	x21, x22, [sp, #32]
    queue->active->consumer_signalled = 1;
  20169c:	52800021 	mov	w1, #0x1                   	// #1
  2016a0:	a94363f7 	ldp	x23, x24, [sp, #48]
        microkit_deferred_notify(net_config.tx.id);
  2016a4:	90000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
}
  2016a8:	a9446bf9 	ldp	x25, x26, [sp, #64]
    microkit_have_signal = seL4_True;
  2016ac:	b0000024 	adrp	x4, 206000 <state+0x188>
  2016b0:	a94573fb 	ldp	x27, x28, [sp, #80]
  2016b4:	b9000441 	str	w1, [x2, #4]
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  2016b8:	b0000023 	adrp	x3, 206000 <state+0x188>
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  2016bc:	b0000022 	adrp	x2, 206000 <state+0x188>
  2016c0:	3941a800 	ldrb	w0, [x0, #106]
    microkit_have_signal = seL4_True;
  2016c4:	3914c481 	strb	w1, [x4, #1329]
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  2016c8:	91002800 	add	x0, x0, #0xa
    microkit_signal_msg = seL4_MessageInfo_new(0, 0, 0, 0);
  2016cc:	f9029c7f 	str	xzr, [x3, #1336]
    microkit_signal_cap = (BASE_OUTPUT_NOTIFICATION_CAP + ch);
  2016d0:	f902a040 	str	x0, [x2, #1344]
  2016d4:	a94153f3 	ldp	x19, x20, [sp, #16]
  2016d8:	a8c87bfd 	ldp	x29, x30, [sp], #128
  2016dc:	d65f03c0 	ret
                            assert(!err);
  2016e0:	d0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  2016e4:	913f2063 	add	x3, x3, #0xfc8
  2016e8:	91006063 	add	x3, x3, #0x18
  2016ec:	f0000001 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  2016f0:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  2016f4:	9103c021 	add	x1, x1, #0xf0
  2016f8:	9104e000 	add	x0, x0, #0x138
  2016fc:	528019a2 	mov	w2, #0xcd                  	// #205
  201700:	94000a10 	bl	203f40 <_assert_fail>
  201704:	17fffea6 	b	20119c <route+0x2ac>
                        assert(!err);
  201708:	d0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  20170c:	913f2063 	add	x3, x3, #0xfc8
  201710:	52801c62 	mov	w2, #0xe3                  	// #227
  201714:	91006063 	add	x3, x3, #0x18
  201718:	f0000001 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  20171c:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  201720:	9103c021 	add	x1, x1, #0xf0
  201724:	9104e000 	add	x0, x0, #0x138
  201728:	b9006fe5 	str	w5, [sp, #108]
  20172c:	94000a05 	bl	203f40 <_assert_fail>
                        sddf_memcpy((net_config.tx_data.vaddr + buffer_tx.io_or_offset), (router_config.filters[filter].data.vaddr + buffer.io_or_offset), buffer.len + (sizeof(struct ipv4_packet)));
  201730:	f9403b02 	ldr	x2, [x24, #112]
  201734:	90000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
  201738:	f9403801 	ldr	x1, [x0, #112]
  20173c:	8b140042 	add	x2, x2, x20
  201740:	b9406fe5 	ldr	w5, [sp, #108]
  201744:	8b1c0021 	add	x1, x1, x28
    while (n-- > 0) {
  201748:	17fffedf 	b	2012c4 <route+0x3d4>
                        waiting_packet->ip = nextIP;
  20174c:	b900101f 	str	wzr, [x0, #16]
  201750:	d4207d00 	brk	#0x3e8
  201754:	d503201f 	nop
  201758:	d503201f 	nop
  20175c:	d503201f 	nop

0000000000201760 <init>:

void init(void)
{
  201760:	a9bb7bfd 	stp	x29, x30, [sp, #-80]!
  201764:	910003fd 	mov	x29, sp
  201768:	a9025bf5 	stp	x21, x22, [sp, #32]

static bool net_config_check_magic(void *config)
{
    char *magic = (char *)config;
    for (int i = 0; i < SDDF_NET_MAGIC_LEN; i++) {
        if (magic[i] != SDDF_NET_MAGIC[i]) {
  20176c:	90000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
  201770:	91002016 	add	x22, x0, #0x8
  201774:	39402000 	ldrb	w0, [x0, #8]
  201778:	a90153f3 	stp	x19, x20, [sp, #16]
  20177c:	7101cc1f 	cmp	w0, #0x73
  201780:	a90363f7 	stp	x23, x24, [sp, #48]
  201784:	f90023f9 	str	x25, [sp, #64]
  201788:	540033e1 	b.ne	201e04 <init+0x6a4>  // b.any
  20178c:	394006c0 	ldrb	w0, [x22, #1]
  201790:	7101101f 	cmp	w0, #0x44
  201794:	54003381 	b.ne	201e04 <init+0x6a4>  // b.any
  201798:	39400ac0 	ldrb	w0, [x22, #2]
  20179c:	7101101f 	cmp	w0, #0x44
  2017a0:	54003321 	b.ne	201e04 <init+0x6a4>  // b.any
  2017a4:	39400ec0 	ldrb	w0, [x22, #3]
  2017a8:	7101181f 	cmp	w0, #0x46
  2017ac:	540032c1 	b.ne	201e04 <init+0x6a4>  // b.any
  2017b0:	394012c0 	ldrb	w0, [x22, #4]
  2017b4:	7100141f 	cmp	w0, #0x5
  2017b8:	54003261 	b.ne	201e04 <init+0x6a4>  // b.any

static bool firewall_config_check_magic(void *config)
{
    char *magic = (char *)config;
    for (int i = 0; i < LIONS_FIREWALL_MAGIC_LEN; i++) {
        if (magic[i] != LIONS_FIREWALL_MAGIC[i]) {
  2017bc:	90000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
  2017c0:	91026018 	add	x24, x0, #0x98
  2017c4:	39426000 	ldrb	w0, [x0, #152]
  2017c8:	7101301f 	cmp	w0, #0x4c
  2017cc:	54003301 	b.ne	201e2c <init+0x6cc>  // b.any
  2017d0:	39400700 	ldrb	w0, [x24, #1]
  2017d4:	7101a41f 	cmp	w0, #0x69
  2017d8:	540032a1 	b.ne	201e2c <init+0x6cc>  // b.any
  2017dc:	39400b00 	ldrb	w0, [x24, #2]
  2017e0:	7101bc1f 	cmp	w0, #0x6f
  2017e4:	54003241 	b.ne	201e2c <init+0x6cc>  // b.any
  2017e8:	39400f00 	ldrb	w0, [x24, #3]
  2017ec:	7101b81f 	cmp	w0, #0x6e
  2017f0:	540031e1 	b.ne	201e2c <init+0x6cc>  // b.any
  2017f4:	39401300 	ldrb	w0, [x24, #4]
  2017f8:	7101cc1f 	cmp	w0, #0x73
  2017fc:	54003181 	b.ne	201e2c <init+0x6cc>  // b.any
  201800:	39401700 	ldrb	w0, [x24, #5]
  201804:	71013c1f 	cmp	w0, #0x4f
  201808:	54003121 	b.ne	201e2c <init+0x6cc>  // b.any
  20180c:	39401b00 	ldrb	w0, [x24, #6]
  201810:	71014c1f 	cmp	w0, #0x53
  201814:	540030c1 	b.ne	201e2c <init+0x6cc>  // b.any
  201818:	39401f00 	ldrb	w0, [x24, #7]
  20181c:	71000c1f 	cmp	w0, #0x3
  201820:	54003061 	b.ne	201e2c <init+0x6cc>  // b.any
    // Init the hashtable here, as we are the first component that will
    // ever access it.
    assert(net_config_check_magic((void *)&net_config));
    assert(firewall_config_check_magic((void*) &router_config));
    arp_table = (hashtable_t*) router_config.router.arp_cache.vaddr;
  201824:	f9401700 	ldr	x0, [x24, #40]
  201828:	90000037 	adrp	x23, 205000 <__sel4_ipc_buffer>
  20182c:	913902f5 	add	x21, x23, #0xe40
  201830:	9112c001 	add	x1, x0, #0x4b0
  201834:	cb0103e1 	neg	x1, x1
  201838:	f90346a0 	str	x0, [x21, #1672]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  20183c:	f2400c23 	ands	x3, x1, #0xf
  201840:	54003220 	b.eq	201e84 <init+0x724>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201844:	3912c01f 	strb	wzr, [x0, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201848:	f27f083f 	tst	x1, #0xe
  20184c:	54003100 	b.eq	201e6c <init+0x70c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201850:	3912c41f 	strb	wzr, [x0, #1201]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201854:	f100087f 	cmp	x3, #0x2
  201858:	54003109 	b.ls	201e78 <init+0x718>  // b.plast
        table->used[i] = 0;  // Mark all slots as unused
  20185c:	3912c81f 	strb	wzr, [x0, #1202]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201860:	f27e043f 	tst	x1, #0xc
  201864:	540031c0 	b.eq	201e9c <init+0x73c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201868:	3912cc1f 	strb	wzr, [x0, #1203]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  20186c:	f100107f 	cmp	x3, #0x4
  201870:	54003109 	b.ls	201e90 <init+0x730>  // b.plast
        table->used[i] = 0;  // Mark all slots as unused
  201874:	3912d01f 	strb	wzr, [x0, #1204]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201878:	f100147f 	cmp	x3, #0x5
  20187c:	540031c0 	b.eq	201eb4 <init+0x754>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201880:	3912d41f 	strb	wzr, [x0, #1205]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201884:	f100187f 	cmp	x3, #0x6
  201888:	54003220 	b.eq	201ecc <init+0x76c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  20188c:	3912d81f 	strb	wzr, [x0, #1206]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201890:	361832a1 	tbz	w1, #3, 201ee4 <init+0x784>
        table->used[i] = 0;  // Mark all slots as unused
  201894:	3912dc1f 	strb	wzr, [x0, #1207]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201898:	f100207f 	cmp	x3, #0x8
  20189c:	540031e9 	b.ls	201ed8 <init+0x778>  // b.plast
        table->used[i] = 0;  // Mark all slots as unused
  2018a0:	3912e01f 	strb	wzr, [x0, #1208]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2018a4:	f100247f 	cmp	x3, #0x9
  2018a8:	540030c0 	b.eq	201ec0 <init+0x760>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2018ac:	3912e41f 	strb	wzr, [x0, #1209]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2018b0:	f100287f 	cmp	x3, #0xa
  2018b4:	54002fa0 	b.eq	201ea8 <init+0x748>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2018b8:	3912e81f 	strb	wzr, [x0, #1210]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2018bc:	f1002c7f 	cmp	x3, #0xb
  2018c0:	54003180 	b.eq	201ef0 <init+0x790>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2018c4:	3912ec1f 	strb	wzr, [x0, #1211]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2018c8:	f100307f 	cmp	x3, #0xc
  2018cc:	54003180 	b.eq	201efc <init+0x79c>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2018d0:	3912f01f 	strb	wzr, [x0, #1212]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2018d4:	f100347f 	cmp	x3, #0xd
  2018d8:	54003180 	b.eq	201f08 <init+0x7a8>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2018dc:	3912f41f 	strb	wzr, [x0, #1213]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2018e0:	f1003c7f 	cmp	x3, #0xf
  2018e4:	54003181 	b.ne	201f14 <init+0x7b4>  // b.any
  2018e8:	aa0303e1 	mov	x1, x3
  2018ec:	d2800aa2 	mov	x2, #0x55                  	// #85
        table->used[i] = 0;  // Mark all slots as unused
  2018f0:	3912f81f 	strb	wzr, [x0, #1214]
  2018f4:	4f000400 	movi	v0.4s, #0x0
  2018f8:	9112c066 	add	x6, x3, #0x4b0
  2018fc:	8b060004 	add	x4, x0, x6
  201900:	d2800c85 	mov	x5, #0x64                  	// #100
  201904:	cb0300a3 	sub	x3, x5, x3
  201908:	3ca66800 	str	q0, [x0, x6]
  20190c:	d344fc65 	lsr	x5, x3, #4
  201910:	f10018bf 	cmp	x5, #0x6
  201914:	ad008080 	stp	q0, q0, [x4, #16]
  201918:	ad018080 	stp	q0, q0, [x4, #48]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  20191c:	540029c1 	b.ne	201e54 <init+0x6f4>  // b.any
        table->used[i] = 0;  // Mark all slots as unused
  201920:	3d801480 	str	q0, [x4, #80]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201924:	91018021 	add	x1, x1, #0x60
  201928:	d1018042 	sub	x2, x2, #0x60
  20192c:	f101807f 	cmp	x3, #0x60
  201930:	54000920 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201934:	8b010003 	add	x3, x0, x1
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201938:	f100045f 	cmp	x2, #0x1
  20193c:	91000424 	add	x4, x1, #0x1
        table->used[i] = 0;  // Mark all slots as unused
  201940:	3912c07f 	strb	wzr, [x3, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201944:	54000880 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201948:	8b040004 	add	x4, x0, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  20194c:	f100085f 	cmp	x2, #0x2
  201950:	91000823 	add	x3, x1, #0x2
        table->used[i] = 0;  // Mark all slots as unused
  201954:	3912c09f 	strb	wzr, [x4, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201958:	540007e0 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  20195c:	8b030003 	add	x3, x0, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201960:	f1000c5f 	cmp	x2, #0x3
  201964:	91000c24 	add	x4, x1, #0x3
        table->used[i] = 0;  // Mark all slots as unused
  201968:	3912c07f 	strb	wzr, [x3, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  20196c:	54000740 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201970:	8b040004 	add	x4, x0, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201974:	f100105f 	cmp	x2, #0x4
  201978:	91001023 	add	x3, x1, #0x4
        table->used[i] = 0;  // Mark all slots as unused
  20197c:	3912c09f 	strb	wzr, [x4, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201980:	540006a0 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201984:	8b030003 	add	x3, x0, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201988:	f100145f 	cmp	x2, #0x5
  20198c:	91001424 	add	x4, x1, #0x5
        table->used[i] = 0;  // Mark all slots as unused
  201990:	3912c07f 	strb	wzr, [x3, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201994:	54000600 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201998:	8b040004 	add	x4, x0, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  20199c:	f100185f 	cmp	x2, #0x6
  2019a0:	91001823 	add	x3, x1, #0x6
        table->used[i] = 0;  // Mark all slots as unused
  2019a4:	3912c09f 	strb	wzr, [x4, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019a8:	54000560 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2019ac:	8b030004 	add	x4, x0, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019b0:	f1001c5f 	cmp	x2, #0x7
  2019b4:	91001c23 	add	x3, x1, #0x7
        table->used[i] = 0;  // Mark all slots as unused
  2019b8:	3912c09f 	strb	wzr, [x4, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019bc:	540004c0 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2019c0:	8b030003 	add	x3, x0, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019c4:	f100205f 	cmp	x2, #0x8
  2019c8:	91002024 	add	x4, x1, #0x8
        table->used[i] = 0;  // Mark all slots as unused
  2019cc:	3912c07f 	strb	wzr, [x3, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019d0:	54000420 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2019d4:	8b040004 	add	x4, x0, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019d8:	f100245f 	cmp	x2, #0x9
  2019dc:	91002423 	add	x3, x1, #0x9
        table->used[i] = 0;  // Mark all slots as unused
  2019e0:	3912c09f 	strb	wzr, [x4, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019e4:	54000380 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2019e8:	8b030003 	add	x3, x0, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019ec:	f100285f 	cmp	x2, #0xa
  2019f0:	91002824 	add	x4, x1, #0xa
        table->used[i] = 0;  // Mark all slots as unused
  2019f4:	3912c07f 	strb	wzr, [x3, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  2019f8:	540002e0 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  2019fc:	8b040004 	add	x4, x0, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a00:	f1002c5f 	cmp	x2, #0xb
  201a04:	91002c23 	add	x3, x1, #0xb
        table->used[i] = 0;  // Mark all slots as unused
  201a08:	3912c09f 	strb	wzr, [x4, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a0c:	54000240 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a10:	8b030003 	add	x3, x0, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a14:	f100305f 	cmp	x2, #0xc
  201a18:	91003024 	add	x4, x1, #0xc
        table->used[i] = 0;  // Mark all slots as unused
  201a1c:	3912c07f 	strb	wzr, [x3, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a20:	540001a0 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a24:	8b040004 	add	x4, x0, x4
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a28:	f100345f 	cmp	x2, #0xd
  201a2c:	91003423 	add	x3, x1, #0xd
        table->used[i] = 0;  // Mark all slots as unused
  201a30:	3912c09f 	strb	wzr, [x4, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a34:	54000100 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a38:	8b030003 	add	x3, x0, x3
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a3c:	91003821 	add	x1, x1, #0xe
  201a40:	f100385f 	cmp	x2, #0xe
        table->used[i] = 0;  // Mark all slots as unused
  201a44:	3912c07f 	strb	wzr, [x3, #1200]
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201a48:	54000060 	b.eq	201a54 <init+0x2f4>  // b.none
        table->used[i] = 0;  // Mark all slots as unused
  201a4c:	8b010000 	add	x0, x0, x1
  201a50:	3912c01f 	strb	wzr, [x0, #1200]
    hashtable_init(arp_table);

    // Setup all the queues for the filters
    for (int i = 0; i < router_config.num_filters; i++) {
  201a54:	795b4300 	ldrh	w0, [x24, #3488]
  201a58:	34000240 	cbz	w0, 201aa0 <init+0x340>
  201a5c:	51000403 	sub	w3, w0, #0x1
  201a60:	9100e302 	add	x2, x24, #0x38
  201a64:	52800704 	mov	w4, #0x38                  	// #56
  201a68:	aa1803e0 	mov	x0, x24
  201a6c:	9100e2a1 	add	x1, x21, #0x38
  201a70:	9ba40863 	umaddl	x3, w3, w4, x2
  201a74:	d503201f 	nop
    queue->free = free;
  201a78:	f9402402 	ldr	x2, [x0, #72]
  201a7c:	f9000022 	str	x2, [x1]
        net_queue_init(&state.filter_queue[i], router_config.filters[i].conn.free_queue.vaddr,
            router_config.filters[i].conn.active_queue.vaddr, router_config.filters[i].conn.num_buffers);
  201a80:	f9402c02 	ldr	x2, [x0, #88]
    queue->active = active;
  201a84:	f9000422 	str	x2, [x1, #8]
        net_queue_init(&state.filter_queue[i], router_config.filters[i].conn.free_queue.vaddr,
  201a88:	7940d002 	ldrh	w2, [x0, #104]
    for (int i = 0; i < router_config.num_filters; i++) {
  201a8c:	9100e000 	add	x0, x0, #0x38
    queue->capacity = capacity;
  201a90:	b9001022 	str	w2, [x1, #16]
  201a94:	eb00007f 	cmp	x3, x0
  201a98:	91006021 	add	x1, x1, #0x18
  201a9c:	54fffee1 	b.ne	201a78 <init+0x318>  // b.any
    }
    net_queue_init(&virt_tx_queue, net_config.tx.free_queue.vaddr, net_config.tx.active_queue.vaddr,
  201aa0:	7940c2c3 	ldrh	w3, [x22, #96]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201aa4:	52800014 	mov	w20, #0x0                   	// #0
  201aa8:	f94022c1 	ldr	x1, [x22, #64]
    queue->free = free;
  201aac:	f902fea1 	str	x1, [x21, #1528]
  201ab0:	f9402ac2 	ldr	x2, [x22, #80]
    queue->active = active;
  201ab4:	f90302a2 	str	x2, [x21, #1536]
    queue->capacity = capacity;
  201ab8:	b9060aa3 	str	w3, [x21, #1544]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201abc:	52800013 	mov	w19, #0x0                   	// #0
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201ac0:	d2800119 	mov	x25, #0x8                   	// #8
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201ac4:	34000463 	cbz	w3, 201b50 <init+0x3f0>
    return queue->free->tail - queue->free->head == queue->capacity;
  201ac8:	79400022 	ldrh	w2, [x1]
        net_buff_desc_t buffer = {(NET_BUFFER_SIZE * i) + base_addr, 0};
  201acc:	2a1403e5 	mov	w5, w20
    return queue->free->tail - queue->free->head == queue->capacity;
  201ad0:	79400420 	ldrh	w0, [x1, #2]
    queue->free->tail++;
  201ad4:	11000444 	add	w4, w2, #0x1
    return queue->free->tail - queue->free->head == queue->capacity;
  201ad8:	4b000040 	sub	w0, w2, w0
    if (net_queue_full_free(queue)) {
  201adc:	6b03001f 	cmp	w0, w3
  201ae0:	540001c0 	b.eq	201b18 <init+0x3b8>  // b.none
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201ae4:	1ac30840 	udiv	w0, w2, w3
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201ae8:	11000673 	add	w19, w19, #0x1
  201aec:	6b03027f 	cmp	w19, w3
  201af0:	11200294 	add	w20, w20, #0x800
    queue->free->buffers[queue->free->tail % queue->capacity] = buffer;
  201af4:	1b038800 	msub	w0, w0, w3, w2
  201af8:	8b205320 	add	x0, x25, w0, uxtw #4
  201afc:	8b000022 	add	x2, x1, x0
  201b00:	f8206825 	str	x5, [x1, x0]
  201b04:	7900105f 	strh	wzr, [x2, #8]
    queue->free->tail++;
  201b08:	79000024 	strh	w4, [x1]
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201b0c:	54000222 	b.cs	201b50 <init+0x3f0>  // b.hs, b.nlast
    return queue->free->tail - queue->free->head == queue->capacity;
  201b10:	f942fea1 	ldr	x1, [x21, #1528]
  201b14:	17ffffed 	b	201ac8 <init+0x368>
        assert(!err);
  201b18:	d0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  201b1c:	913f2063 	add	x3, x3, #0xfc8
  201b20:	9100a063 	add	x3, x3, #0x28
  201b24:	f0000001 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  201b28:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  201b2c:	91074021 	add	x1, x1, #0x1d0
  201b30:	9104e000 	add	x0, x0, #0x138
  201b34:	52801ba2 	mov	w2, #0xdd                  	// #221
  201b38:	94000902 	bl	203f40 <_assert_fail>
    for (uint32_t i = 0; i < queue->capacity; i++) {
  201b3c:	11000673 	add	w19, w19, #0x1
  201b40:	b9460aa3 	ldr	w3, [x21, #1544]
  201b44:	11200294 	add	w20, w20, #0x800
  201b48:	6b03027f 	cmp	w19, w3
  201b4c:	54fffe23 	b.cc	201b10 <init+0x3b0>  // b.lo, b.ul, b.last
        net_config.tx.num_buffers);
    net_buffers_init(&virt_tx_queue, 0);

    arp_queries = (arp_queue_handle_t *) router_config.router.arp_queue.vaddr;
  201b50:	f9400f04 	ldr	x4, [x24, #24]

    device_info = (dev_info_t *) net_config.dev_info.vaddr;

    // Init the waiting queue from a pool of memory
    pkt_waiting_queue.llnode_pool = (uint8_t *) router_config.packet_queue.vaddr;
    pkt_waiting_queue.pool_size = 10;
  201b54:	f0000002 	adrp	x2, 204000 <__FUNCTION__.1+0x10>
  201b58:	fd416c40 	ldr	d0, [x2, #728]
 * @param active pointer to active queue in shared memory.
 * @param capacity capacity of the free and active queues.
 */
static inline void arp_handle_init(arp_queue_handle_t *queue, uint32_t capacity)
{
    queue->capacity = capacity;
  201b5c:	52802005 	mov	w5, #0x100                 	// #256
    pkt_waiting_queue.llnode_pool = (uint8_t *) router_config.packet_queue.vaddr;
  201b60:	f9400700 	ldr	x0, [x24, #8]
    arp_queries = (arp_queue_handle_t *) router_config.router.arp_queue.vaddr;
  201b64:	f90722e4 	str	x4, [x23, #3648]
    device_info = (dev_info_t *) net_config.dev_info.vaddr;
  201b68:	f94042c6 	ldr	x6, [x22, #128]
    pkt_waiting_queue.llnode_pool = (uint8_t *) router_config.packet_queue.vaddr;
  201b6c:	f90006a0 	str	x0, [x21, #8]
    pkt_waiting_queue.node_size = sizeof(struct llnode_pkt_waiting);
    pkt_waiting_queue.empty_head = NULL;
    pkt_waiting_queue.head = NULL;
    pkt_waiting_queue.tail = NULL;
  201b70:	a9027ebf 	stp	xzr, xzr, [x21, #32]
  201b74:	cb0003e3 	neg	x3, x0
  201b78:	f2400c62 	ands	x2, x3, #0xf
    device_info = (dev_info_t *) net_config.dev_info.vaddr;
  201b7c:	f902faa6 	str	x6, [x21, #1520]
  201b80:	b9300885 	str	w5, [x4, #12296]
    pkt_waiting_queue.pool_size = 10;
  201b84:	fd000aa0 	str	d0, [x21, #16]
    while (n-- > 0) {
  201b88:	540016c0 	b.eq	201e60 <init+0x700>  // b.none
        *p++ = c;
  201b8c:	3900001f 	strb	wzr, [x0]
  201b90:	91000404 	add	x4, x0, #0x1
  201b94:	f27f087f 	tst	x3, #0xe
    while (n-- > 0) {
  201b98:	d2803be1 	mov	x1, #0x1df                 	// #479
  201b9c:	54000880 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201ba0:	3900041f 	strb	wzr, [x0, #1]
  201ba4:	91000804 	add	x4, x0, #0x2
  201ba8:	f100085f 	cmp	x2, #0x2
    while (n-- > 0) {
  201bac:	d2803bc1 	mov	x1, #0x1de                 	// #478
  201bb0:	540007e9 	b.ls	201cac <init+0x54c>  // b.plast
        *p++ = c;
  201bb4:	3900081f 	strb	wzr, [x0, #2]
  201bb8:	91000c04 	add	x4, x0, #0x3
  201bbc:	f27e047f 	tst	x3, #0xc
    while (n-- > 0) {
  201bc0:	d2803ba1 	mov	x1, #0x1dd                 	// #477
  201bc4:	54000740 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201bc8:	39000c1f 	strb	wzr, [x0, #3]
  201bcc:	91001004 	add	x4, x0, #0x4
  201bd0:	f100105f 	cmp	x2, #0x4
    while (n-- > 0) {
  201bd4:	d2803b81 	mov	x1, #0x1dc                 	// #476
  201bd8:	540006a9 	b.ls	201cac <init+0x54c>  // b.plast
        *p++ = c;
  201bdc:	3900101f 	strb	wzr, [x0, #4]
  201be0:	91001404 	add	x4, x0, #0x5
  201be4:	f100145f 	cmp	x2, #0x5
    while (n-- > 0) {
  201be8:	d2803b61 	mov	x1, #0x1db                 	// #475
  201bec:	54000600 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201bf0:	3900141f 	strb	wzr, [x0, #5]
  201bf4:	91001804 	add	x4, x0, #0x6
  201bf8:	f100185f 	cmp	x2, #0x6
    while (n-- > 0) {
  201bfc:	d2803b41 	mov	x1, #0x1da                 	// #474
  201c00:	54000560 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201c04:	3900181f 	strb	wzr, [x0, #6]
  201c08:	91001c04 	add	x4, x0, #0x7
    while (n-- > 0) {
  201c0c:	d2803b21 	mov	x1, #0x1d9                 	// #473
  201c10:	361804e3 	tbz	w3, #3, 201cac <init+0x54c>
        *p++ = c;
  201c14:	39001c1f 	strb	wzr, [x0, #7]
  201c18:	91002004 	add	x4, x0, #0x8
  201c1c:	f100205f 	cmp	x2, #0x8
    while (n-- > 0) {
  201c20:	d2803b01 	mov	x1, #0x1d8                 	// #472
  201c24:	54000449 	b.ls	201cac <init+0x54c>  // b.plast
        *p++ = c;
  201c28:	3900201f 	strb	wzr, [x0, #8]
  201c2c:	91002404 	add	x4, x0, #0x9
  201c30:	f100245f 	cmp	x2, #0x9
    while (n-- > 0) {
  201c34:	d2803ae1 	mov	x1, #0x1d7                 	// #471
  201c38:	540003a0 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201c3c:	3900241f 	strb	wzr, [x0, #9]
  201c40:	91002804 	add	x4, x0, #0xa
  201c44:	f100285f 	cmp	x2, #0xa
    while (n-- > 0) {
  201c48:	d2803ac1 	mov	x1, #0x1d6                 	// #470
  201c4c:	54000300 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201c50:	3900281f 	strb	wzr, [x0, #10]
  201c54:	91002c04 	add	x4, x0, #0xb
  201c58:	f1002c5f 	cmp	x2, #0xb
    while (n-- > 0) {
  201c5c:	d2803aa1 	mov	x1, #0x1d5                 	// #469
  201c60:	54000260 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201c64:	39002c1f 	strb	wzr, [x0, #11]
  201c68:	91003004 	add	x4, x0, #0xc
  201c6c:	f100305f 	cmp	x2, #0xc
    while (n-- > 0) {
  201c70:	d2803a81 	mov	x1, #0x1d4                 	// #468
  201c74:	540001c0 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201c78:	3900301f 	strb	wzr, [x0, #12]
  201c7c:	91003404 	add	x4, x0, #0xd
  201c80:	f100345f 	cmp	x2, #0xd
    while (n-- > 0) {
  201c84:	d2803a61 	mov	x1, #0x1d3                 	// #467
  201c88:	54000120 	b.eq	201cac <init+0x54c>  // b.none
        *p++ = c;
  201c8c:	3900341f 	strb	wzr, [x0, #13]
  201c90:	91003804 	add	x4, x0, #0xe
  201c94:	f1003c5f 	cmp	x2, #0xf
    while (n-- > 0) {
  201c98:	d2803a41 	mov	x1, #0x1d2                 	// #466
  201c9c:	54000081 	b.ne	201cac <init+0x54c>  // b.any
        *p++ = c;
  201ca0:	91003c04 	add	x4, x0, #0xf
    while (n-- > 0) {
  201ca4:	d2803a21 	mov	x1, #0x1d1                 	// #465
        *p++ = c;
  201ca8:	3900381f 	strb	wzr, [x0, #14]
    while (n-- > 0) {
  201cac:	d2803c03 	mov	x3, #0x1e0                 	// #480
  201cb0:	cb020063 	sub	x3, x3, x2
        *p++ = c;
  201cb4:	4f000400 	movi	v0.4s, #0x0
  201cb8:	8b020000 	add	x0, x0, x2
  201cbc:	927cec62 	and	x2, x3, #0xfffffffffffffff0
  201cc0:	8b000042 	add	x2, x2, x0
  201cc4:	d503201f 	nop
  201cc8:	3c810400 	str	q0, [x0], #16
    while (n-- > 0) {
  201ccc:	eb02001f 	cmp	x0, x2
  201cd0:	54ffffc1 	b.ne	201cc8 <init+0x568>  // b.any
  201cd4:	927cec62 	and	x2, x3, #0xfffffffffffffff0
  201cd8:	f2400c7f 	tst	x3, #0xf
  201cdc:	cb020020 	sub	x0, x1, x2
  201ce0:	8b020081 	add	x1, x4, x2
  201ce4:	54000580 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201ce8:	3822689f 	strb	wzr, [x4, x2]
    while (n-- > 0) {
  201cec:	f100041f 	cmp	x0, #0x1
  201cf0:	54000520 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201cf4:	3900043f 	strb	wzr, [x1, #1]
    while (n-- > 0) {
  201cf8:	f100081f 	cmp	x0, #0x2
  201cfc:	540004c0 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d00:	3900083f 	strb	wzr, [x1, #2]
    while (n-- > 0) {
  201d04:	f1000c1f 	cmp	x0, #0x3
  201d08:	54000460 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d0c:	39000c3f 	strb	wzr, [x1, #3]
    while (n-- > 0) {
  201d10:	f100101f 	cmp	x0, #0x4
  201d14:	54000400 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d18:	3900103f 	strb	wzr, [x1, #4]
    while (n-- > 0) {
  201d1c:	f100141f 	cmp	x0, #0x5
  201d20:	540003a0 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d24:	3900143f 	strb	wzr, [x1, #5]
    while (n-- > 0) {
  201d28:	f100181f 	cmp	x0, #0x6
  201d2c:	54000340 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d30:	3900183f 	strb	wzr, [x1, #6]
    while (n-- > 0) {
  201d34:	f1001c1f 	cmp	x0, #0x7
  201d38:	540002e0 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d3c:	39001c3f 	strb	wzr, [x1, #7]
    while (n-- > 0) {
  201d40:	f100201f 	cmp	x0, #0x8
  201d44:	54000280 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d48:	3900203f 	strb	wzr, [x1, #8]
    while (n-- > 0) {
  201d4c:	f100241f 	cmp	x0, #0x9
  201d50:	54000220 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d54:	3900243f 	strb	wzr, [x1, #9]
    while (n-- > 0) {
  201d58:	f100281f 	cmp	x0, #0xa
  201d5c:	540001c0 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d60:	3900283f 	strb	wzr, [x1, #10]
    while (n-- > 0) {
  201d64:	f1002c1f 	cmp	x0, #0xb
  201d68:	54000160 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d6c:	39002c3f 	strb	wzr, [x1, #11]
    while (n-- > 0) {
  201d70:	f100301f 	cmp	x0, #0xc
  201d74:	54000100 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d78:	3900303f 	strb	wzr, [x1, #12]
    while (n-- > 0) {
  201d7c:	f100341f 	cmp	x0, #0xd
  201d80:	540000a0 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d84:	3900343f 	strb	wzr, [x1, #13]
    while (n-- > 0) {
  201d88:	f100381f 	cmp	x0, #0xe
  201d8c:	54000040 	b.eq	201d94 <init+0x634>  // b.none
        *p++ = c;
  201d90:	3900383f 	strb	wzr, [x1, #14]
    info->empty_head = info->llnode_pool;
  201d94:	f94006a6 	ldr	x6, [x21, #8]
  201d98:	f9000ea6 	str	x6, [x21, #24]
    for (size_t i = 1; i < info->pool_size; i++) {
  201d9c:	b94012a3 	ldr	w3, [x21, #16]
    curr->prev = NULL;
  201da0:	f90004df 	str	xzr, [x6, #8]
    for (size_t i = 1; i < info->pool_size; i++) {
  201da4:	7100047f 	cmp	w3, #0x1
  201da8:	2a0303e3 	mov	w3, w3
  201dac:	540001c9 	b.ls	201de4 <init+0x684>  // b.plast
        curr->next = &info->llnode_pool[i * info->node_size];
  201db0:	b94016a4 	ldr	w4, [x21, #20]
  201db4:	aa0603e0 	mov	x0, x6
    for (size_t i = 1; i < info->pool_size; i++) {
  201db8:	d2800021 	mov	x1, #0x1                   	// #1
  201dbc:	d503201f 	nop
        curr->next = &info->llnode_pool[i * info->node_size];
  201dc0:	aa0003e2 	mov	x2, x0
  201dc4:	8b040000 	add	x0, x0, x4
  201dc8:	aa0103e5 	mov	x5, x1
    for (size_t i = 1; i < info->pool_size; i++) {
  201dcc:	91000421 	add	x1, x1, #0x1
  201dd0:	eb01007f 	cmp	x3, x1
        curr->next = &info->llnode_pool[i * info->node_size];
  201dd4:	f9000040 	str	x0, [x2]
        LLNODE_PTRS_CAST(curr->next)->prev = curr;
  201dd8:	f9000402 	str	x2, [x0, #8]
    for (size_t i = 1; i < info->pool_size; i++) {
  201ddc:	54ffff21 	b.ne	201dc0 <init+0x660>  // b.any
        curr->next = &info->llnode_pool[i * info->node_size];
  201de0:	9b051886 	madd	x6, x4, x5, x6

    llinit(&pkt_waiting_queue);
    // routing_table[0].network_id = 0;
    // routing_table[0].subnet_mask = 0xFFFFFF00;
    // routing_table[0].next_hop = 0;
}
  201de4:	a94153f3 	ldp	x19, x20, [sp, #16]
  201de8:	a94363f7 	ldp	x23, x24, [sp, #48]
  201dec:	f94023f9 	ldr	x25, [sp, #64]
    curr->next = NULL;
  201df0:	f90000df 	str	xzr, [x6]
    info->curr_size = 0;
  201df4:	b90032bf 	str	wzr, [x21, #48]
  201df8:	a9425bf5 	ldp	x21, x22, [sp, #32]
  201dfc:	a8c57bfd 	ldp	x29, x30, [sp], #80
  201e00:	d65f03c0 	ret
    assert(net_config_check_magic((void *)&net_config));
  201e04:	d0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  201e08:	913f2063 	add	x3, x3, #0xfc8
  201e0c:	91008063 	add	x3, x3, #0x20
  201e10:	f0000001 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  201e14:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  201e18:	9103c021 	add	x1, x1, #0xf0
  201e1c:	9105a000 	add	x0, x0, #0x168
  201e20:	52802162 	mov	w2, #0x10b                 	// #267
  201e24:	94000847 	bl	203f40 <_assert_fail>
  201e28:	17fffe65 	b	2017bc <init+0x5c>
    assert(firewall_config_check_magic((void*) &router_config));
  201e2c:	d0000003 	adrp	x3, 203000 <_vsnprintf+0xf0>
  201e30:	913f2063 	add	x3, x3, #0xfc8
  201e34:	91008063 	add	x3, x3, #0x20
  201e38:	f0000001 	adrp	x1, 204000 <__FUNCTION__.1+0x10>
  201e3c:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  201e40:	9103c021 	add	x1, x1, #0xf0
  201e44:	91066000 	add	x0, x0, #0x198
  201e48:	52802182 	mov	w2, #0x10c                 	// #268
  201e4c:	9400083d 	bl	203f40 <_assert_fail>
  201e50:	17fffe75 	b	201824 <init+0xc4>
  201e54:	91014021 	add	x1, x1, #0x50
  201e58:	d1014042 	sub	x2, x2, #0x50
  201e5c:	17fffeb6 	b	201934 <init+0x1d4>
    unsigned char *p = s;
  201e60:	aa0003e4 	mov	x4, x0
    pkt_waiting_queue.tail = NULL;
  201e64:	d2803c01 	mov	x1, #0x1e0                 	// #480
  201e68:	17ffff91 	b	201cac <init+0x54c>
    for (size_t i = 0; i < TABLE_SIZE; i++) {
  201e6c:	d2800c62 	mov	x2, #0x63                  	// #99
  201e70:	d2800021 	mov	x1, #0x1                   	// #1
  201e74:	17fffea0 	b	2018f4 <init+0x194>
  201e78:	d2800c42 	mov	x2, #0x62                  	// #98
  201e7c:	d2800041 	mov	x1, #0x2                   	// #2
  201e80:	17fffe9d 	b	2018f4 <init+0x194>
  201e84:	d2800001 	mov	x1, #0x0                   	// #0
    arp_table = (hashtable_t*) router_config.router.arp_cache.vaddr;
  201e88:	d2800c82 	mov	x2, #0x64                  	// #100
  201e8c:	17fffe9a 	b	2018f4 <init+0x194>
  201e90:	d2800c02 	mov	x2, #0x60                  	// #96
  201e94:	d2800081 	mov	x1, #0x4                   	// #4
  201e98:	17fffe97 	b	2018f4 <init+0x194>
  201e9c:	d2800c22 	mov	x2, #0x61                  	// #97
  201ea0:	d2800061 	mov	x1, #0x3                   	// #3
  201ea4:	17fffe94 	b	2018f4 <init+0x194>
  201ea8:	aa0303e1 	mov	x1, x3
  201eac:	d2800b42 	mov	x2, #0x5a                  	// #90
  201eb0:	17fffe91 	b	2018f4 <init+0x194>
  201eb4:	aa0303e1 	mov	x1, x3
  201eb8:	d2800be2 	mov	x2, #0x5f                  	// #95
  201ebc:	17fffe8e 	b	2018f4 <init+0x194>
  201ec0:	d2800121 	mov	x1, #0x9                   	// #9
  201ec4:	d2800b62 	mov	x2, #0x5b                  	// #91
  201ec8:	17fffe8b 	b	2018f4 <init+0x194>
  201ecc:	aa0303e1 	mov	x1, x3
  201ed0:	d2800bc2 	mov	x2, #0x5e                  	// #94
  201ed4:	17fffe88 	b	2018f4 <init+0x194>
  201ed8:	d2800b82 	mov	x2, #0x5c                  	// #92
  201edc:	d2800101 	mov	x1, #0x8                   	// #8
  201ee0:	17fffe85 	b	2018f4 <init+0x194>
  201ee4:	d2800ba2 	mov	x2, #0x5d                  	// #93
  201ee8:	d28000e1 	mov	x1, #0x7                   	// #7
  201eec:	17fffe82 	b	2018f4 <init+0x194>
  201ef0:	aa0303e1 	mov	x1, x3
  201ef4:	d2800b22 	mov	x2, #0x59                  	// #89
  201ef8:	17fffe7f 	b	2018f4 <init+0x194>
  201efc:	aa0303e1 	mov	x1, x3
  201f00:	d2800b02 	mov	x2, #0x58                  	// #88
  201f04:	17fffe7c 	b	2018f4 <init+0x194>
  201f08:	aa0303e1 	mov	x1, x3
  201f0c:	d2800ae2 	mov	x2, #0x57                  	// #87
  201f10:	17fffe79 	b	2018f4 <init+0x194>
  201f14:	d2800ac2 	mov	x2, #0x56                  	// #86
  201f18:	d28001c1 	mov	x1, #0xe                   	// #14
  201f1c:	17fffe76 	b	2018f4 <init+0x194>

0000000000201f20 <notified>:

void notified(microkit_channel ch)
{
    // Popualate with the rx ch number
    if (ch == router_config.router.id) {
  201f20:	90000021 	adrp	x1, 205000 <__sel4_ipc_buffer>
  201f24:	39434021 	ldrb	w1, [x1, #208]
  201f28:	6b00003f 	cmp	w1, w0
  201f2c:	54000040 	b.eq	201f34 <notified+0x14>  // b.none
        /* This is the channel between the ARP component and the routing component. */
        process_arp_waiting();
    } else {
        route();
  201f30:	17fffbf0 	b	200ef0 <route>
        process_arp_waiting();
  201f34:	17fff9eb 	b	2006e0 <process_arp_waiting>
	...

0000000000201f40 <protected>:
  201f40:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  201f44:	b0000020 	adrp	x0, 206000 <state+0x188>
  201f48:	9113c000 	add	x0, x0, #0x4f0
  201f4c:	910003fd 	mov	x29, sp
  201f50:	94000078 	bl	202130 <microkit_dbg_puts>
  201f54:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  201f58:	91088000 	add	x0, x0, #0x220
  201f5c:	94000075 	bl	202130 <microkit_dbg_puts>
  201f60:	d2800000 	mov	x0, #0x0                   	// #0
  201f64:	b900001f 	str	wzr, [x0]
  201f68:	d4207d00 	brk	#0x3e8
  201f6c:	d503201f 	nop

0000000000201f70 <fault>:
  201f70:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  201f74:	b0000020 	adrp	x0, 206000 <state+0x188>
  201f78:	9113c000 	add	x0, x0, #0x4f0
  201f7c:	910003fd 	mov	x29, sp
  201f80:	9400006c 	bl	202130 <microkit_dbg_puts>
  201f84:	f0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  201f88:	91094000 	add	x0, x0, #0x250
  201f8c:	94000069 	bl	202130 <microkit_dbg_puts>
  201f90:	d2800000 	mov	x0, #0x0                   	// #0
  201f94:	b900001f 	str	wzr, [x0]
  201f98:	d4207d00 	brk	#0x3e8
  201f9c:	00000000 	udf	#0

0000000000201fa0 <main>:
  201fa0:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  201fa4:	90000020 	adrp	x0, 205000 <__sel4_ipc_buffer>
  201fa8:	91000000 	add	x0, x0, #0x0
  201fac:	910003fd 	mov	x29, sp
  201fb0:	a90153f3 	stp	x19, x20, [sp, #16]
  201fb4:	90000034 	adrp	x20, 205000 <__sel4_ipc_buffer>
  201fb8:	91000294 	add	x20, x20, #0x0
  201fbc:	a9025bf5 	stp	x21, x22, [sp, #32]
  201fc0:	eb140015 	subs	x21, x0, x20
  201fc4:	54000100 	b.eq	201fe4 <main+0x44>  // b.none
  201fc8:	9343feb5 	asr	x21, x21, #3
  201fcc:	d2800013 	mov	x19, #0x0                   	// #0
  201fd0:	f8737a80 	ldr	x0, [x20, x19, lsl #3]
  201fd4:	91000673 	add	x19, x19, #0x1
  201fd8:	d63f0000 	blr	x0
  201fdc:	eb1302bf 	cmp	x21, x19
  201fe0:	54ffff88 	b.hi	201fd0 <main+0x30>  // b.pmore
  201fe4:	b0000036 	adrp	x22, 206000 <state+0x188>
  201fe8:	9113c2d6 	add	x22, x22, #0x4f0
  201fec:	97fffddd 	bl	201760 <init>
  201ff0:	394102c0 	ldrb	w0, [x22, #64]
  201ff4:	340000a0 	cbz	w0, 202008 <main+0x68>
  201ff8:	52800021 	mov	w1, #0x1                   	// #1
  201ffc:	d28000a0 	mov	x0, #0x5                   	// #5
  202000:	390106c1 	strb	w1, [x22, #65]
  202004:	a90482df 	stp	xzr, x0, [x22, #72]
  202008:	f0000015 	adrp	x21, 205000 <__sel4_ipc_buffer>
  20200c:	910002b5 	add	x21, x21, #0x0
  202010:	52800000 	mov	w0, #0x0                   	// #0
  202014:	d503201f 	nop
  202018:	35000220 	cbnz	w0, 20205c <main+0xbc>
  20201c:	39c106c0 	ldrsb	w0, [x22, #65]
  202020:	350004e0 	cbnz	w0, 2020bc <main+0x11c>
  202024:	d2800020 	mov	x0, #0x1                   	// #1
  202028:	d2800086 	mov	x6, #0x4                   	// #4
  20202c:	928000c7 	mov	x7, #0xfffffffffffffff9    	// #-7
  202030:	d4000001 	svc	#0x0
  202034:	f94002a6 	ldr	x6, [x21]
  202038:	aa0003f3 	mov	x19, x0
  20203c:	a9008cc2 	stp	x2, x3, [x6, #8]
  202040:	a90194c4 	stp	x4, x5, [x6, #24]
  202044:	b7f00313 	tbnz	x19, #62, 2020a4 <main+0x104>
  202048:	52800014 	mov	w20, #0x0                   	// #0
  20204c:	b6f801b3 	tbz	x19, #63, 202080 <main+0xe0>
  202050:	12001660 	and	w0, w19, #0x3f
  202054:	97ffffbb 	bl	201f40 <protected>
  202058:	f9001fe0 	str	x0, [sp, #56]
  20205c:	f94002a5 	ldr	x5, [x21]
  202060:	d2800020 	mov	x0, #0x1                   	// #1
  202064:	f9401fe1 	ldr	x1, [sp, #56]
  202068:	d2800086 	mov	x6, #0x4                   	// #4
  20206c:	a9408ca2 	ldp	x2, x3, [x5, #8]
  202070:	92800027 	mov	x7, #0xfffffffffffffffe    	// #-2
  202074:	a94194a4 	ldp	x4, x5, [x5, #24]
  202078:	d4000001 	svc	#0x0
  20207c:	17ffffee 	b	202034 <main+0x94>
  202080:	370000d3 	tbnz	w19, #0, 202098 <main+0xf8>
  202084:	d503201f 	nop
  202088:	d341fe73 	lsr	x19, x19, #1
  20208c:	11000694 	add	w20, w20, #0x1
  202090:	b4fffc73 	cbz	x19, 20201c <main+0x7c>
  202094:	3607ffb3 	tbz	w19, #0, 202088 <main+0xe8>
  202098:	2a1403e0 	mov	w0, w20
  20209c:	97ffffa1 	bl	201f20 <notified>
  2020a0:	17fffffa 	b	202088 <main+0xe8>
  2020a4:	12001e60 	and	w0, w19, #0xff
  2020a8:	9100e3e2 	add	x2, sp, #0x38
  2020ac:	97ffffb1 	bl	201f70 <fault>
  2020b0:	72001c1f 	tst	w0, #0xff
  2020b4:	1a9f07e0 	cset	w0, ne	// ne = any
  2020b8:	17ffffd8 	b	202018 <main+0x78>
  2020bc:	f94002a5 	ldr	x5, [x21]
  2020c0:	d2800020 	mov	x0, #0x1                   	// #1
  2020c4:	a944a2c1 	ldp	x1, x8, [x22, #72]
  2020c8:	d2800086 	mov	x6, #0x4                   	// #4
  2020cc:	a9408ca2 	ldp	x2, x3, [x5, #8]
  2020d0:	92800047 	mov	x7, #0xfffffffffffffffd    	// #-3
  2020d4:	a94194a4 	ldp	x4, x5, [x5, #24]
  2020d8:	d4000001 	svc	#0x0
  2020dc:	f94002a6 	ldr	x6, [x21]
  2020e0:	aa0003f3 	mov	x19, x0
  2020e4:	390106df 	strb	wzr, [x22, #65]
  2020e8:	a9008cc2 	stp	x2, x3, [x6, #8]
  2020ec:	a90194c4 	stp	x4, x5, [x6, #24]
  2020f0:	17ffffd5 	b	202044 <main+0xa4>
	...

0000000000202100 <microkit_dbg_putc>:
  202100:	d2800001 	mov	x1, #0x0                   	// #0
  202104:	92401c00 	and	x0, x0, #0xff
  202108:	d2800002 	mov	x2, #0x0                   	// #0
  20210c:	d2800003 	mov	x3, #0x0                   	// #0
  202110:	d2800004 	mov	x4, #0x0                   	// #0
  202114:	d2800005 	mov	x5, #0x0                   	// #0
  202118:	d2800006 	mov	x6, #0x0                   	// #0
  20211c:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  202120:	d4000001 	svc	#0x0
  202124:	d65f03c0 	ret
  202128:	d503201f 	nop
  20212c:	d503201f 	nop

0000000000202130 <microkit_dbg_puts>:
  202130:	aa0003e8 	mov	x8, x0
  202134:	39400000 	ldrb	w0, [x0]
  202138:	34000180 	cbz	w0, 202168 <microkit_dbg_puts+0x38>
  20213c:	d503201f 	nop
  202140:	d2800001 	mov	x1, #0x0                   	// #0
  202144:	d2800002 	mov	x2, #0x0                   	// #0
  202148:	d2800003 	mov	x3, #0x0                   	// #0
  20214c:	d2800004 	mov	x4, #0x0                   	// #0
  202150:	d2800005 	mov	x5, #0x0                   	// #0
  202154:	d2800006 	mov	x6, #0x0                   	// #0
  202158:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  20215c:	d4000001 	svc	#0x0
  202160:	38401d00 	ldrb	w0, [x8, #1]!
  202164:	35fffee0 	cbnz	w0, 202140 <microkit_dbg_puts+0x10>
  202168:	d65f03c0 	ret
  20216c:	d503201f 	nop

0000000000202170 <__assert_fail>:
  202170:	d000000b 	adrp	x11, 204000 <__FUNCTION__.1+0x10>
  202174:	9109e16b 	add	x11, x11, #0x278
  202178:	aa0103e9 	mov	x9, x1
  20217c:	aa0303e8 	mov	x8, x3
  202180:	aa0003ea 	mov	x10, x0
  202184:	d2800c20 	mov	x0, #0x61                  	// #97
  202188:	d2800001 	mov	x1, #0x0                   	// #0
  20218c:	d2800002 	mov	x2, #0x0                   	// #0
  202190:	d2800003 	mov	x3, #0x0                   	// #0
  202194:	d2800004 	mov	x4, #0x0                   	// #0
  202198:	d2800005 	mov	x5, #0x0                   	// #0
  20219c:	d2800006 	mov	x6, #0x0                   	// #0
  2021a0:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2021a4:	d4000001 	svc	#0x0
  2021a8:	38401d60 	ldrb	w0, [x11, #1]!
  2021ac:	35fffee0 	cbnz	w0, 202188 <__assert_fail+0x18>
  2021b0:	39400140 	ldrb	w0, [x10]
  2021b4:	34000160 	cbz	w0, 2021e0 <__assert_fail+0x70>
  2021b8:	d2800001 	mov	x1, #0x0                   	// #0
  2021bc:	d2800002 	mov	x2, #0x0                   	// #0
  2021c0:	d2800003 	mov	x3, #0x0                   	// #0
  2021c4:	d2800004 	mov	x4, #0x0                   	// #0
  2021c8:	d2800005 	mov	x5, #0x0                   	// #0
  2021cc:	d2800006 	mov	x6, #0x0                   	// #0
  2021d0:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2021d4:	d4000001 	svc	#0x0
  2021d8:	38401d40 	ldrb	w0, [x10, #1]!
  2021dc:	35fffee0 	cbnz	w0, 2021b8 <__assert_fail+0x48>
  2021e0:	d2800400 	mov	x0, #0x20                  	// #32
  2021e4:	d2800001 	mov	x1, #0x0                   	// #0
  2021e8:	d2800002 	mov	x2, #0x0                   	// #0
  2021ec:	d2800003 	mov	x3, #0x0                   	// #0
  2021f0:	d2800004 	mov	x4, #0x0                   	// #0
  2021f4:	d2800005 	mov	x5, #0x0                   	// #0
  2021f8:	d2800006 	mov	x6, #0x0                   	// #0
  2021fc:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  202200:	d4000001 	svc	#0x0
  202204:	39400120 	ldrb	w0, [x9]
  202208:	34000180 	cbz	w0, 202238 <__assert_fail+0xc8>
  20220c:	d503201f 	nop
  202210:	d2800001 	mov	x1, #0x0                   	// #0
  202214:	d2800002 	mov	x2, #0x0                   	// #0
  202218:	d2800003 	mov	x3, #0x0                   	// #0
  20221c:	d2800004 	mov	x4, #0x0                   	// #0
  202220:	d2800005 	mov	x5, #0x0                   	// #0
  202224:	d2800006 	mov	x6, #0x0                   	// #0
  202228:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  20222c:	d4000001 	svc	#0x0
  202230:	38401d20 	ldrb	w0, [x9, #1]!
  202234:	35fffee0 	cbnz	w0, 202210 <__assert_fail+0xa0>
  202238:	d2800400 	mov	x0, #0x20                  	// #32
  20223c:	d2800001 	mov	x1, #0x0                   	// #0
  202240:	d2800002 	mov	x2, #0x0                   	// #0
  202244:	d2800003 	mov	x3, #0x0                   	// #0
  202248:	d2800004 	mov	x4, #0x0                   	// #0
  20224c:	d2800005 	mov	x5, #0x0                   	// #0
  202250:	d2800006 	mov	x6, #0x0                   	// #0
  202254:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  202258:	d4000001 	svc	#0x0
  20225c:	39400100 	ldrb	w0, [x8]
  202260:	34000180 	cbz	w0, 202290 <__assert_fail+0x120>
  202264:	d503201f 	nop
  202268:	d2800001 	mov	x1, #0x0                   	// #0
  20226c:	d2800002 	mov	x2, #0x0                   	// #0
  202270:	d2800003 	mov	x3, #0x0                   	// #0
  202274:	d2800004 	mov	x4, #0x0                   	// #0
  202278:	d2800005 	mov	x5, #0x0                   	// #0
  20227c:	d2800006 	mov	x6, #0x0                   	// #0
  202280:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  202284:	d4000001 	svc	#0x0
  202288:	38401d00 	ldrb	w0, [x8, #1]!
  20228c:	35fffee0 	cbnz	w0, 202268 <__assert_fail+0xf8>
  202290:	d2800140 	mov	x0, #0xa                   	// #10
  202294:	d2800001 	mov	x1, #0x0                   	// #0
  202298:	d2800002 	mov	x2, #0x0                   	// #0
  20229c:	d2800003 	mov	x3, #0x0                   	// #0
  2022a0:	d2800004 	mov	x4, #0x0                   	// #0
  2022a4:	d2800005 	mov	x5, #0x0                   	// #0
  2022a8:	d2800006 	mov	x6, #0x0                   	// #0
  2022ac:	92800167 	mov	x7, #0xfffffffffffffff4    	// #-12
  2022b0:	d4000001 	svc	#0x0
  2022b4:	d65f03c0 	ret
	...

00000000002022c0 <_out_buffer>:


// internal buffer output
static inline void _out_buffer(char character, void* buffer, size_t idx, size_t maxlen)
{
  if (idx < maxlen) {
  2022c0:	eb03005f 	cmp	x2, x3
{
  2022c4:	12001c00 	and	w0, w0, #0xff
  if (idx < maxlen) {
  2022c8:	54000042 	b.cs	2022d0 <_out_buffer+0x10>  // b.hs, b.nlast
    ((char*)buffer)[idx] = character;
  2022cc:	38226820 	strb	w0, [x1, x2]
  }
}
  2022d0:	d65f03c0 	ret
  2022d4:	d503201f 	nop
  2022d8:	d503201f 	nop
  2022dc:	d503201f 	nop

00000000002022e0 <_out_null>:

// internal null output
static inline void _out_null(char character, void* buffer, size_t idx, size_t maxlen)
{
  (void)character; (void)buffer; (void)idx; (void)maxlen;
}
  2022e0:	d65f03c0 	ret
  2022e4:	d503201f 	nop
  2022e8:	d503201f 	nop
  2022ec:	d503201f 	nop

00000000002022f0 <_out_rev>:
}


// output the specified string in reverse, taking care of any zero-padding
static size_t _out_rev(out_fct_type out, char* buffer, size_t idx, size_t maxlen, const char* buf, size_t len, unsigned int width, unsigned int flags)
{
  2022f0:	a9ba7bfd 	stp	x29, x30, [sp, #-96]!
  2022f4:	910003fd 	mov	x29, sp
  2022f8:	a90153f3 	stp	x19, x20, [sp, #16]
  2022fc:	aa0503f3 	mov	x19, x5
  202300:	aa0203f4 	mov	x20, x2
  202304:	a9025bf5 	stp	x21, x22, [sp, #32]
  202308:	aa0003f5 	mov	x21, x0
  20230c:	aa0103f6 	mov	x22, x1
  202310:	a90363f7 	stp	x23, x24, [sp, #48]
  202314:	aa0203f8 	mov	x24, x2
  202318:	aa0303f7 	mov	x23, x3
  20231c:	a9046bf9 	stp	x25, x26, [sp, #64]
  202320:	aa0403f9 	mov	x25, x4
  202324:	2a0603fa 	mov	w26, w6
  202328:	a90573fb 	stp	x27, x28, [sp, #80]
  20232c:	2a0703fb 	mov	w27, w7
  const size_t start_idx = idx;

  // pad spaces up to given width
  if (!(flags & FLAGS_LEFT) && !(flags & FLAGS_ZEROPAD)) {
  202330:	f240077f 	tst	x27, #0x3
  202334:	540001e1 	b.ne	202370 <_out_rev+0x80>  // b.any
    for (size_t i = len; i < width; i++) {
  202338:	2a1a03e0 	mov	w0, w26
  20233c:	aa0203fc 	mov	x28, x2
  202340:	cb050014 	sub	x20, x0, x5
  202344:	eb0000bf 	cmp	x5, x0
  202348:	8b020294 	add	x20, x20, x2
  20234c:	54000502 	b.cs	2023ec <_out_rev+0xfc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  202350:	aa1c03e2 	mov	x2, x28
  202354:	aa1703e3 	mov	x3, x23
  202358:	9100079c 	add	x28, x28, #0x1
  20235c:	aa1603e1 	mov	x1, x22
  202360:	52800400 	mov	w0, #0x20                  	// #32
  202364:	d63f02a0 	blr	x21
    for (size_t i = len; i < width; i++) {
  202368:	eb1c029f 	cmp	x20, x28
  20236c:	54ffff21 	b.ne	202350 <_out_rev+0x60>  // b.any
    }
  }

  // reverse string
  while (len) {
  202370:	8b14027c 	add	x28, x19, x20
  202374:	b4000133 	cbz	x19, 202398 <_out_rev+0xa8>
  202378:	cb130382 	sub	x2, x28, x19
    out(buf[--len], buffer, idx++, maxlen);
  20237c:	d1000673 	sub	x19, x19, #0x1
  202380:	aa1c03f4 	mov	x20, x28
  202384:	aa1703e3 	mov	x3, x23
  202388:	aa1603e1 	mov	x1, x22
  20238c:	38736b20 	ldrb	w0, [x25, x19]
  202390:	d63f02a0 	blr	x21
  while (len) {
  202394:	b5ffff33 	cbnz	x19, 202378 <_out_rev+0x88>
  }

  // append pad spaces up to given width
  if (flags & FLAGS_LEFT) {
  202398:	360801bb 	tbz	w27, #1, 2023cc <_out_rev+0xdc>
    while (idx - start_idx < width) {
  20239c:	cb180298 	sub	x24, x20, x24
  2023a0:	eb1a031f 	cmp	x24, x26
  2023a4:	54000142 	b.cs	2023cc <_out_rev+0xdc>  // b.hs, b.nlast
      out(' ', buffer, idx++, maxlen);
  2023a8:	aa1403e2 	mov	x2, x20
    while (idx - start_idx < width) {
  2023ac:	91000718 	add	x24, x24, #0x1
      out(' ', buffer, idx++, maxlen);
  2023b0:	aa1703e3 	mov	x3, x23
  2023b4:	aa1603e1 	mov	x1, x22
  2023b8:	52800400 	mov	w0, #0x20                  	// #32
  2023bc:	d63f02a0 	blr	x21
  2023c0:	91000694 	add	x20, x20, #0x1
    while (idx - start_idx < width) {
  2023c4:	eb1a031f 	cmp	x24, x26
  2023c8:	54ffff03 	b.cc	2023a8 <_out_rev+0xb8>  // b.lo, b.ul, b.last
    }
  }

  return idx;
}
  2023cc:	a9425bf5 	ldp	x21, x22, [sp, #32]
  2023d0:	aa1403e0 	mov	x0, x20
  2023d4:	a94153f3 	ldp	x19, x20, [sp, #16]
  2023d8:	a94363f7 	ldp	x23, x24, [sp, #48]
  2023dc:	a9446bf9 	ldp	x25, x26, [sp, #64]
  2023e0:	a94573fb 	ldp	x27, x28, [sp, #80]
  2023e4:	a8c67bfd 	ldp	x29, x30, [sp], #96
  2023e8:	d65f03c0 	ret
    for (size_t i = len; i < width; i++) {
  2023ec:	aa0203f4 	mov	x20, x2
  2023f0:	17ffffe0 	b	202370 <_out_rev+0x80>
  2023f4:	d503201f 	nop
  2023f8:	d503201f 	nop
  2023fc:	d503201f 	nop

0000000000202400 <_ntoa_long>:
}


// internal itoa for 'long' type
static size_t _ntoa_long(out_fct_type out, char* buffer, size_t idx, size_t maxlen, unsigned long value, bool negative, unsigned long base, unsigned int prec, unsigned int width, unsigned int flags)
{
  202400:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  202404:	aa0603eb 	mov	x11, x6
  202408:	aa0403ea 	mov	x10, x4
  20240c:	910003fd 	mov	x29, sp
  202410:	b9403be8 	ldr	w8, [sp, #56]
  202414:	2a0703ef 	mov	w15, w7
  202418:	b94033e6 	ldr	w6, [sp, #48]
  20241c:	12001cb2 	and	w18, w5, #0xff
  if (!value) {
    flags &= ~FLAGS_HASH;
  }

  // write if precision != 0 and value is != 0
  if (!(flags & FLAGS_PRECISION) || value) {
  202420:	12160110 	and	w16, w8, #0x400
  if (!value) {
  202424:	b4000764 	cbz	x4, 202510 <_ntoa_long+0x110>
  if (flags & FLAGS_HASH) {
  202428:	121c0111 	and	w17, w8, #0x10
  20242c:	2a0803e7 	mov	w7, w8
    do {
      const char digit = (char)(value % base);
  202430:	9acb094c 	udiv	x12, x10, x11
  202434:	f27b00ff 	tst	x7, #0x20
  202438:	52800c24 	mov	w4, #0x61                  	// #97
  20243c:	5280082d 	mov	w13, #0x41                  	// #65
  202440:	1a8411ad 	csel	w13, w13, w4, ne	// ne = any
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202444:	d2800005 	mov	x5, #0x0                   	// #0
  202448:	510029ad 	sub	w13, w13, #0xa
  20244c:	910043e4 	add	x4, sp, #0x10
      const char digit = (char)(value % base);
  202450:	9b0ba988 	msub	x8, x12, x11, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202454:	910004a5 	add	x5, x5, #0x1
  202458:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  20245c:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202460:	1100c10e 	add	w14, w8, #0x30
  202464:	0b0d0108 	add	w8, w8, w13
  202468:	54000248 	b.hi	2024b0 <_ntoa_long+0xb0>  // b.pmore
  20246c:	d503201f 	nop
  202470:	8b050088 	add	x8, x4, x5
      value /= base;
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  202474:	f1007cbf 	cmp	x5, #0x1f
  202478:	1a9f87e9 	cset	w9, ls	// ls = plast
  20247c:	7100013f 	cmp	w9, #0x0
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  202480:	381ff10e 	sturb	w14, [x8, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  202484:	fa4a1162 	ccmp	x11, x10, #0x2, ne	// ne = any
  202488:	54000228 	b.hi	2024cc <_ntoa_long+0xcc>  // b.pmore
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  20248c:	aa0c03ea 	mov	x10, x12
  202490:	910004a5 	add	x5, x5, #0x1
      const char digit = (char)(value % base);
  202494:	9acb094c 	udiv	x12, x10, x11
  202498:	9b0ba988 	msub	x8, x12, x11, x10
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  20249c:	f100251f 	cmp	x8, #0x9
      const char digit = (char)(value % base);
  2024a0:	12001d08 	and	w8, w8, #0xff
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  2024a4:	1100c10e 	add	w14, w8, #0x30
  2024a8:	0b0d0108 	add	w8, w8, w13
  2024ac:	54fffe29 	b.ls	202470 <_ntoa_long+0x70>  // b.plast
  2024b0:	8b05008e 	add	x14, x4, x5
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  2024b4:	f1007cbf 	cmp	x5, #0x1f
  2024b8:	1a9f87e9 	cset	w9, ls	// ls = plast
  2024bc:	7100013f 	cmp	w9, #0x0
      buf[len++] = digit < 10 ? '0' + digit : (flags & FLAGS_UPPERCASE ? 'A' : 'a') + digit - 10;
  2024c0:	381ff1c8 	sturb	w8, [x14, #-1]
    } while (value && (len < PRINTF_NTOA_BUFFER_SIZE));
  2024c4:	fa4a1162 	ccmp	x11, x10, #0x2, ne	// ne = any
  2024c8:	54fffe29 	b.ls	20248c <_ntoa_long+0x8c>  // b.plast
  if (!(flags & FLAGS_LEFT)) {
  2024cc:	36080307 	tbz	w7, #1, 20252c <_ntoa_long+0x12c>
  if (flags & FLAGS_HASH) {
  2024d0:	34000771 	cbz	w17, 2025bc <_ntoa_long+0x1bc>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  2024d4:	34000850 	cbz	w16, 2025dc <_ntoa_long+0x1dc>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2024d8:	f100417f 	cmp	x11, #0x10
  2024dc:	54000de0 	b.eq	202698 <_ntoa_long+0x298>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2024e0:	7100013f 	cmp	w9, #0x0
  2024e4:	7a421960 	ccmp	w11, #0x2, #0x0, ne	// ne = any
  2024e8:	540000a1 	b.ne	2024fc <_ntoa_long+0xfc>  // b.any
      buf[len++] = 'b';
  2024ec:	aa0503e8 	mov	x8, x5
  2024f0:	910004a5 	add	x5, x5, #0x1
  2024f4:	52800c49 	mov	w9, #0x62                  	// #98
  2024f8:	38286889 	strb	w9, [x4, x8]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  2024fc:	f10080bf 	cmp	x5, #0x20
  202500:	54000881 	b.ne	202610 <_ntoa_long+0x210>  // b.any
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  202504:	97ffff7b 	bl	2022f0 <_out_rev>
  }

  return _ntoa_format(out, buffer, idx, maxlen, buf, len, negative, (unsigned int)base, prec, width, flags);
}
  202508:	a8c37bfd 	ldp	x29, x30, [sp], #48
  20250c:	d65f03c0 	ret
    flags &= ~FLAGS_HASH;
  202510:	121b7907 	and	w7, w8, #0xffffffef
  if (!(flags & FLAGS_PRECISION) || value) {
  202514:	340008d0 	cbz	w16, 20262c <_ntoa_long+0x22c>
  if (!(flags & FLAGS_LEFT)) {
  202518:	121f0111 	and	w17, w8, #0x2
  20251c:	37080a08 	tbnz	w8, #1, 20265c <_ntoa_long+0x25c>
  202520:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  202524:	d2800005 	mov	x5, #0x0                   	// #0
  if (!(flags & FLAGS_LEFT)) {
  202528:	52800029 	mov	w9, #0x1                   	// #1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20252c:	2a0f03ea 	mov	w10, w15
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  202530:	120000ed 	and	w13, w7, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202534:	eb0a00bf 	cmp	x5, x10
  202538:	1a9f27e8 	cset	w8, cc	// cc = lo, ul, last
  20253c:	0a080128 	and	w8, w9, w8
    if (width && (flags & FLAGS_ZEROPAD) && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  202540:	340007a6 	cbz	w6, 202634 <_ntoa_long+0x234>
  202544:	3400088d 	cbz	w13, 202654 <_ntoa_long+0x254>
  202548:	35000072 	cbnz	w18, 202554 <_ntoa_long+0x154>
  20254c:	721e04ff 	tst	w7, #0xc
  202550:	54000040 	b.eq	202558 <_ntoa_long+0x158>  // b.none
      width--;
  202554:	510004c6 	sub	w6, w6, #0x1
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202558:	34000168 	cbz	w8, 202584 <_ntoa_long+0x184>
      buf[len++] = '0';
  20255c:	5280060c 	mov	w12, #0x30                  	// #48
  202560:	910004a5 	add	x5, x5, #0x1
  202564:	8b050088 	add	x8, x4, x5
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202568:	f1007cbf 	cmp	x5, #0x1f
  20256c:	1a9f87e9 	cset	w9, ls	// ls = plast
  202570:	7100013f 	cmp	w9, #0x0
      buf[len++] = '0';
  202574:	381ff10c 	sturb	w12, [x8, #-1]
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202578:	fa4a10a2 	ccmp	x5, x10, #0x2, ne	// ne = any
  20257c:	54ffff23 	b.cc	202560 <_ntoa_long+0x160>  // b.lo, b.ul, b.last
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202580:	34fffa8d 	cbz	w13, 2024d0 <_ntoa_long+0xd0>
  202584:	7100013f 	cmp	w9, #0x0
  202588:	2a0603ea 	mov	w10, w6
  20258c:	fa451140 	ccmp	x10, x5, #0x0, ne	// ne = any
  202590:	54fffa09 	b.ls	2024d0 <_ntoa_long+0xd0>  // b.plast
      buf[len++] = '0';
  202594:	5280060c 	mov	w12, #0x30                  	// #48
  202598:	910004a5 	add	x5, x5, #0x1
  20259c:	8b050088 	add	x8, x4, x5
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2025a0:	f1007cbf 	cmp	x5, #0x1f
  2025a4:	1a9f87e9 	cset	w9, ls	// ls = plast
  2025a8:	7100013f 	cmp	w9, #0x0
      buf[len++] = '0';
  2025ac:	381ff10c 	sturb	w12, [x8, #-1]
    while ((flags & FLAGS_ZEROPAD) && (len < width) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2025b0:	fa4a10a2 	ccmp	x5, x10, #0x2, ne	// ne = any
  2025b4:	54ffff23 	b.cc	202598 <_ntoa_long+0x198>  // b.lo, b.ul, b.last
  if (flags & FLAGS_HASH) {
  2025b8:	35fff8f1 	cbnz	w17, 2024d4 <_ntoa_long+0xd4>
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  2025bc:	f10080bf 	cmp	x5, #0x20
  2025c0:	54fffa20 	b.eq	202504 <_ntoa_long+0x104>  // b.none
    if (negative) {
  2025c4:	350003d2 	cbnz	w18, 20263c <_ntoa_long+0x23c>
    else if (flags & FLAGS_PLUS) {
  2025c8:	36100787 	tbz	w7, #2, 2026b8 <_ntoa_long+0x2b8>
      buf[len++] = '+';  // ignore the space if the '+' exists
  2025cc:	52800568 	mov	w8, #0x2b                  	// #43
  2025d0:	38256888 	strb	w8, [x4, x5]
  2025d4:	910004a5 	add	x5, x5, #0x1
  2025d8:	17ffffcb 	b	202504 <_ntoa_long+0x104>
    if (!(flags & FLAGS_PRECISION) && len && ((len == prec) || (len == width))) {
  2025dc:	b4000485 	cbz	x5, 20266c <_ntoa_long+0x26c>
  2025e0:	eb2f40bf 	cmp	x5, w15, uxtw
  2025e4:	54000060 	b.eq	2025f0 <_ntoa_long+0x1f0>  // b.none
  2025e8:	eb2640bf 	cmp	x5, w6, uxtw
  2025ec:	54fff761 	b.ne	2024d8 <_ntoa_long+0xd8>  // b.any
      if (len && (base == 16U)) {
  2025f0:	f10004a8 	subs	x8, x5, #0x1
  2025f4:	7a501960 	ccmp	w11, #0x10, #0x0, ne	// ne = any
  2025f8:	54000821 	b.ne	2026fc <_ntoa_long+0x2fc>  // b.any
        len--;
  2025fc:	d10008a9 	sub	x9, x5, #0x2
      buf[len++] = 'x';
  202600:	aa0803e5 	mov	x5, x8
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202604:	36280907 	tbz	w7, #5, 202724 <_ntoa_long+0x324>
      buf[len++] = 'X';
  202608:	52800b08 	mov	w8, #0x58                  	// #88
  20260c:	38296888 	strb	w8, [x4, x9]
      buf[len++] = '0';
  202610:	aa0503e8 	mov	x8, x5
  202614:	910004a5 	add	x5, x5, #0x1
  202618:	52800609 	mov	w9, #0x30                  	// #48
  20261c:	38286889 	strb	w9, [x4, x8]
  if (len < PRINTF_NTOA_BUFFER_SIZE) {
  202620:	f10080bf 	cmp	x5, #0x20
  202624:	54fff700 	b.eq	202504 <_ntoa_long+0x104>  // b.none
  202628:	17ffffe7 	b	2025c4 <_ntoa_long+0x1c4>
  if (!(flags & FLAGS_PRECISION) || value) {
  20262c:	52800011 	mov	w17, #0x0                   	// #0
  202630:	17ffff80 	b	202430 <_ntoa_long+0x30>
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202634:	35fff948 	cbnz	w8, 20255c <_ntoa_long+0x15c>
  202638:	17ffffd2 	b	202580 <_ntoa_long+0x180>
      buf[len++] = '-';
  20263c:	528005a8 	mov	w8, #0x2d                  	// #45
  202640:	38256888 	strb	w8, [x4, x5]
  202644:	910004a5 	add	x5, x5, #0x1
  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  202648:	97ffff2a 	bl	2022f0 <_out_rev>
}
  20264c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  202650:	d65f03c0 	ret
    while ((len < prec) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202654:	35fff848 	cbnz	w8, 20255c <_ntoa_long+0x15c>
  202658:	17ffff9e 	b	2024d0 <_ntoa_long+0xd0>
  20265c:	910043e4 	add	x4, sp, #0x10
  size_t len = 0U;
  202660:	d2800005 	mov	x5, #0x0                   	// #0
    if (negative) {
  202664:	34fffb32 	cbz	w18, 2025c8 <_ntoa_long+0x1c8>
  202668:	17fffff5 	b	20263c <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20266c:	f100417f 	cmp	x11, #0x10
  202670:	54000500 	b.eq	202710 <_ntoa_long+0x310>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202674:	f100097f 	cmp	x11, #0x2
  202678:	54000381 	b.ne	2026e8 <_ntoa_long+0x2e8>  // b.any
  20267c:	52800c48 	mov	w8, #0x62                  	// #98
      buf[len++] = '0';
  202680:	52800609 	mov	w9, #0x30                  	// #48
      buf[len++] = 'x';
  202684:	390043e8 	strb	w8, [sp, #16]
      buf[len++] = '0';
  202688:	390047e9 	strb	w9, [sp, #17]
  20268c:	d2800045 	mov	x5, #0x2                   	// #2
    if (negative) {
  202690:	34fff9d2 	cbz	w18, 2025c8 <_ntoa_long+0x1c8>
  202694:	17ffffea 	b	20263c <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202698:	362801a7 	tbz	w7, #5, 2026cc <_ntoa_long+0x2cc>
    else if ((base == 16U) && (flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  20269c:	f10080bf 	cmp	x5, #0x20
  2026a0:	54fff320 	b.eq	202504 <_ntoa_long+0x104>  // b.none
      buf[len++] = 'b';
  2026a4:	910004a9 	add	x9, x5, #0x1
      buf[len++] = 'X';
  2026a8:	52800b08 	mov	w8, #0x58                  	// #88
  2026ac:	38256888 	strb	w8, [x4, x5]
  2026b0:	aa0903e5 	mov	x5, x9
  2026b4:	17ffff92 	b	2024fc <_ntoa_long+0xfc>
    else if (flags & FLAGS_SPACE) {
  2026b8:	361ff267 	tbz	w7, #3, 202504 <_ntoa_long+0x104>
      buf[len++] = ' ';
  2026bc:	52800408 	mov	w8, #0x20                  	// #32
  2026c0:	38256888 	strb	w8, [x4, x5]
  2026c4:	910004a5 	add	x5, x5, #0x1
  2026c8:	17ffff8f 	b	202504 <_ntoa_long+0x104>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2026cc:	f10080bf 	cmp	x5, #0x20
  2026d0:	54fff1a0 	b.eq	202504 <_ntoa_long+0x104>  // b.none
      buf[len++] = 'b';
  2026d4:	aa0503e8 	mov	x8, x5
  2026d8:	910004a5 	add	x5, x5, #0x1
      buf[len++] = 'x';
  2026dc:	52800f09 	mov	w9, #0x78                  	// #120
  2026e0:	38286889 	strb	w9, [x4, x8]
  2026e4:	17ffff86 	b	2024fc <_ntoa_long+0xfc>
      buf[len++] = '0';
  2026e8:	52800608 	mov	w8, #0x30                  	// #48
  2026ec:	390043e8 	strb	w8, [sp, #16]
  2026f0:	d2800025 	mov	x5, #0x1                   	// #1
    if (negative) {
  2026f4:	34fff6b2 	cbz	w18, 2025c8 <_ntoa_long+0x1c8>
  2026f8:	17ffffd1 	b	20263c <_ntoa_long+0x23c>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  2026fc:	f100417f 	cmp	x11, #0x10
  202700:	54000180 	b.eq	202730 <_ntoa_long+0x330>  // b.none
    else if ((base == 2U) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202704:	f100097f 	cmp	x11, #0x2
  202708:	54ffef60 	b.eq	2024f4 <_ntoa_long+0xf4>  // b.none
  20270c:	17ffffc3 	b	202618 <_ntoa_long+0x218>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202710:	f27b00ff 	tst	x7, #0x20
  202714:	52800f08 	mov	w8, #0x78                  	// #120
  202718:	52800b05 	mov	w5, #0x58                  	// #88
  20271c:	1a850108 	csel	w8, w8, w5, eq	// eq = none
  202720:	17ffffd8 	b	202680 <_ntoa_long+0x280>
      buf[len++] = 'x';
  202724:	52800f08 	mov	w8, #0x78                  	// #120
  202728:	38296888 	strb	w8, [x4, x9]
    if (len < PRINTF_NTOA_BUFFER_SIZE) {
  20272c:	17ffffb9 	b	202610 <_ntoa_long+0x210>
    if ((base == 16U) && !(flags & FLAGS_UPPERCASE) && (len < PRINTF_NTOA_BUFFER_SIZE)) {
  202730:	362ffd67 	tbz	w7, #5, 2026dc <_ntoa_long+0x2dc>
  202734:	aa0503e9 	mov	x9, x5
      len--;
  202738:	aa0803e5 	mov	x5, x8
  20273c:	17ffffdb 	b	2026a8 <_ntoa_long+0x2a8>

0000000000202740 <_out_char>:
  if (character) {
  202740:	72001c00 	ands	w0, w0, #0xff
  202744:	54000041 	b.ne	20274c <_out_char+0xc>  // b.any
}
  202748:	d65f03c0 	ret
    _sddf_putchar(character);
  20274c:	14000609 	b	203f70 <_sddf_putchar>

0000000000202750 <_out_fct>:
  if (character) {
  202750:	72001c00 	ands	w0, w0, #0xff
  202754:	54000080 	b.eq	202764 <_out_fct+0x14>  // b.none
    ((out_fct_wrap_type*)buffer)->fct(character, ((out_fct_wrap_type*)buffer)->arg);
  202758:	a9400422 	ldp	x2, x1, [x1]
  20275c:	aa0203f0 	mov	x16, x2
  202760:	d61f0200 	br	x16
}
  202764:	d65f03c0 	ret
  202768:	d503201f 	nop
  20276c:	d503201f 	nop

0000000000202770 <_ftoa>:

  // powers of 10
  static const double pow10[] = { 1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 };

  // test for special values
  if (value != value)
  202770:	1e602000 	fcmp	d0, d0
{
  202774:	2a0603e7 	mov	w7, w6
  if (value != value)
  202778:	54000fa1 	b.ne	20296c <_ftoa+0x1fc>  // b.any
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  if (value < -DBL_MAX)
  20277c:	92e00206 	mov	x6, #0xffefffffffffffff    	// #-4503599627370497
  202780:	9e6700c1 	fmov	d1, x6
  202784:	1e612010 	fcmpe	d0, d1
  202788:	54001324 	b.mi	2029ec <_ftoa+0x27c>  // b.first
  20278c:	aa0003ef 	mov	x15, x0
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  if (value > DBL_MAX)
  202790:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  202794:	9e670001 	fmov	d1, x0
  202798:	aa0103f0 	mov	x16, x1
  20279c:	aa0203f1 	mov	x17, x2
  2027a0:	aa0303f2 	mov	x18, x3
  2027a4:	1e612010 	fcmpe	d0, d1
  2027a8:	54000ccc 	b.gt	202940 <_ftoa+0x1d0>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);

  // test for very large values
  // standard printf behavior is to print EVERY whole number digit -- which could be 100s of characters overflowing your buffers == bad
  if ((value > PRINTF_MAX_FLOAT) || (value < -PRINTF_MAX_FLOAT)) {
  2027ac:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  2027b0:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  2027b4:	9e670001 	fmov	d1, x0
  2027b8:	1e612010 	fcmpe	d0, d1
  2027bc:	540010cc 	b.gt	2029d4 <_ftoa+0x264>
  2027c0:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  2027c4:	f2f839a0 	movk	x0, #0xc1cd, lsl #48
  2027c8:	9e670001 	fmov	d1, x0
  2027cc:	1e612010 	fcmpe	d0, d1
  2027d0:	54001024 	b.mi	2029d4 <_ftoa+0x264>  // b.first
#endif
  }

  // test for negative
  bool negative = false;
  if (value < 0) {
  2027d4:	1e602018 	fcmpe	d0, #0.0
{
  2027d8:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  2027dc:	910003fd 	mov	x29, sp
  if (value < 0) {
  2027e0:	54000e44 	b.mi	2029a8 <_ftoa+0x238>  // b.first
  bool negative = false;
  2027e4:	52800003 	mov	w3, #0x0                   	// #0
    negative = true;
    value = 0 - value;
  }

  // set default precision, if not set explicitly
  if (!(flags & FLAGS_PRECISION)) {
  2027e8:	36500e87 	tbz	w7, #10, 2029b8 <_ftoa+0x248>
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  }
  // limit precision to 9, cause a prec >= 10 can lead to overflow errors
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  2027ec:	7100249f 	cmp	w4, #0x9
  2027f0:	54001b49 	b.ls	202b58 <_ftoa+0x3e8>  // b.plast
  2027f4:	910043ec 	add	x12, sp, #0x10
  2027f8:	d2800008 	mov	x8, #0x0                   	// #0
    buf[len++] = '0';
  2027fc:	52800601 	mov	w1, #0x30                  	// #48
  202800:	91000508 	add	x8, x8, #0x1
    prec--;
  202804:	51000484 	sub	w4, w4, #0x1
    buf[len++] = '0';
  202808:	8b080180 	add	x0, x12, x8
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  20280c:	f1007d1f 	cmp	x8, #0x1f
  202810:	7a499880 	ccmp	w4, #0x9, #0x0, ls	// ls = plast
    buf[len++] = '0';
  202814:	381ff001 	sturb	w1, [x0, #-1]
  while ((len < PRINTF_FTOA_BUFFER_SIZE) && (prec > 9U)) {
  202818:	54ffff48 	b.hi	202800 <_ftoa+0x90>  // b.pmore
  20281c:	d2d9aca0 	mov	x0, #0xcd6500000000        	// #225833675390976
  202820:	f2e839a0 	movk	x0, #0x41cd, lsl #48
  202824:	9e670002 	fmov	d2, x0
  }

  int whole = (int)value;
  202828:	1e78000a 	fcvtzs	w10, d0
  double tmp = (value - whole) * pow10[prec];
  unsigned long frac = (unsigned long)tmp;
  diff = tmp - frac;

  if (diff > 0.5) {
  20282c:	1e6c1003 	fmov	d3, #5.000000000000000000e-01
  double tmp = (value - whole) * pow10[prec];
  202830:	1e620141 	scvtf	d1, w10
  202834:	1e613801 	fsub	d1, d0, d1
  202838:	1e620821 	fmul	d1, d1, d2
  unsigned long frac = (unsigned long)tmp;
  20283c:	9e79002e 	fcvtzu	x14, d1
  diff = tmp - frac;
  202840:	9e6301c4 	ucvtf	d4, x14
  202844:	1e643821 	fsub	d1, d1, d4
  if (diff > 0.5) {
  202848:	1e632030 	fcmpe	d1, d3
  20284c:	5400106c 	b.gt	202a58 <_ftoa+0x2e8>
    if (frac >= pow10[prec]) {
      frac = 0;
      ++whole;
    }
  }
  else if (diff < 0.5) {
  202850:	54000084 	b.mi	202860 <_ftoa+0xf0>  // b.first
  }
  else if ((frac == 0U) || (frac & 1U)) {
  202854:	b500172e 	cbnz	x14, 202b38 <_ftoa+0x3c8>
    // if halfway, round up if odd OR if last digit is 0
    ++frac;
  202858:	910005ce 	add	x14, x14, #0x1
  20285c:	d503201f 	nop
  }

  if (prec == 0U) {
  202860:	35000d04 	cbnz	w4, 202a00 <_ftoa+0x290>
    diff = value - (double)whole;
  202864:	1e620141 	scvtf	d1, w10
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  202868:	1e6c1002 	fmov	d2, #5.000000000000000000e-01
    diff = value - (double)whole;
  20286c:	1e613800 	fsub	d0, d0, d1
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  202870:	1e622010 	fcmpe	d0, d2
  202874:	54001564 	b.mi	202b20 <_ftoa+0x3b0>  // b.first
      // exactly 0.5 and ODD, then round up
      // 1.5 -> 2, but 2.5 -> 2
      ++whole;
  202878:	12000140 	and	w0, w10, #0x1
  20287c:	0b00014a 	add	w10, w10, w0
    }
  }

  // do whole part, number is reversed
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
    buf[len++] = (char)(48 + (whole % 10));
  202880:	528ccce1 	mov	w1, #0x6667                	// #26215
  202884:	72acccc1 	movk	w1, #0x6666, lsl #16
  202888:	52800142 	mov	w2, #0xa                   	// #10
  20288c:	1400000a 	b	2028b4 <_ftoa+0x144>
  202890:	9362fd29 	asr	x9, x9, #34
  202894:	91000508 	add	x8, x8, #0x1
  202898:	4b8a7d29 	sub	w9, w9, w10, asr #31
  20289c:	8b080180 	add	x0, x12, x8
  2028a0:	1b02a92b 	msub	w11, w9, w2, w10
    if (!(whole /= 10)) {
  2028a4:	2a0903ea 	mov	w10, w9
    buf[len++] = (char)(48 + (whole % 10));
  2028a8:	1100c169 	add	w9, w11, #0x30
  2028ac:	381ff009 	sturb	w9, [x0, #-1]
    if (!(whole /= 10)) {
  2028b0:	34000e4a 	cbz	w10, 202a78 <_ftoa+0x308>
    buf[len++] = (char)(48 + (whole % 10));
  2028b4:	9b217d49 	smull	x9, w10, w1
  while (len < PRINTF_FTOA_BUFFER_SIZE) {
  2028b8:	f100811f 	cmp	x8, #0x20
  2028bc:	54fffea1 	b.ne	202890 <_ftoa+0x120>  // b.any
      break;
    }
  }

  // pad leading zeros
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  2028c0:	120004e0 	and	w0, w7, #0x3
  2028c4:	7100041f 	cmp	w0, #0x1
  2028c8:	54000281 	b.ne	202918 <_ftoa+0x1a8>  // b.any
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  2028cc:	34000265 	cbz	w5, 202918 <_ftoa+0x1a8>
  2028d0:	350013a3 	cbnz	w3, 202b44 <_ftoa+0x3d4>
  2028d4:	721e04ff 	tst	w7, #0xc
  2028d8:	54001361 	b.ne	202b44 <_ftoa+0x3d4>  // b.any
      width--;
    }
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  2028dc:	2a0503e2 	mov	w2, w5
  2028e0:	eb02011f 	cmp	x8, x2
  2028e4:	54001002 	b.cs	202ae4 <_ftoa+0x374>  // b.hs, b.nlast
  2028e8:	f100811f 	cmp	x8, #0x20
      buf[len++] = '0';
  2028ec:	52800601 	mov	w1, #0x30                  	// #48
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  2028f0:	54000120 	b.eq	202914 <_ftoa+0x1a4>  // b.none
  2028f4:	d503201f 	nop
      buf[len++] = '0';
  2028f8:	91000508 	add	x8, x8, #0x1
  2028fc:	8b080180 	add	x0, x12, x8
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202900:	eb02011f 	cmp	x8, x2
      buf[len++] = '0';
  202904:	381ff001 	sturb	w1, [x0, #-1]
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202908:	54000be0 	b.eq	202a84 <_ftoa+0x314>  // b.none
  20290c:	f100811f 	cmp	x8, #0x20
  202910:	54ffff41 	b.ne	2028f8 <_ftoa+0x188>  // b.any
    }
    else if (flags & FLAGS_PLUS) {
      buf[len++] = '+';  // ignore the space if the '+' exists
    }
    else if (flags & FLAGS_SPACE) {
      buf[len++] = ' ';
  202914:	d2800408 	mov	x8, #0x20                  	// #32
    }
  }

  return _out_rev(out, buffer, idx, maxlen, buf, len, width, flags);
  202918:	2a0503e6 	mov	w6, w5
  20291c:	aa0c03e4 	mov	x4, x12
  202920:	aa0803e5 	mov	x5, x8
  202924:	aa1203e3 	mov	x3, x18
  202928:	aa1103e2 	mov	x2, x17
  20292c:	aa1003e1 	mov	x1, x16
  202930:	aa0f03e0 	mov	x0, x15
  202934:	97fffe6f 	bl	2022f0 <_out_rev>
}
  202938:	a8c37bfd 	ldp	x29, x30, [sp], #48
  20293c:	d65f03c0 	ret
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  202940:	37100207 	tbnz	w7, #2, 202980 <_ftoa+0x210>
  202944:	d2800060 	mov	x0, #0x3                   	// #3
  202948:	2a0503e6 	mov	w6, w5
  20294c:	d0000004 	adrp	x4, 204000 <__FUNCTION__.1+0x10>
  202950:	910a4084 	add	x4, x4, #0x290
  202954:	aa0003e5 	mov	x5, x0
  202958:	aa1203e3 	mov	x3, x18
  20295c:	aa1103e2 	mov	x2, x17
  202960:	aa1003e1 	mov	x1, x16
  202964:	aa0f03e0 	mov	x0, x15
  202968:	17fffe62 	b	2022f0 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, "nan", 3, width, flags);
  20296c:	2a0503e6 	mov	w6, w5
  202970:	d0000004 	adrp	x4, 204000 <__FUNCTION__.1+0x10>
  202974:	d2800065 	mov	x5, #0x3                   	// #3
  202978:	910a6084 	add	x4, x4, #0x298
  20297c:	17fffe5d 	b	2022f0 <_out_rev>
    return _out_rev(out, buffer, idx, maxlen, (flags & FLAGS_PLUS) ? "fni+" : "fni", (flags & FLAGS_PLUS) ? 4U : 3U, width, flags);
  202980:	d2800080 	mov	x0, #0x4                   	// #4
  202984:	2a0503e6 	mov	w6, w5
  202988:	d0000004 	adrp	x4, 204000 <__FUNCTION__.1+0x10>
  20298c:	910a2084 	add	x4, x4, #0x288
  202990:	aa0003e5 	mov	x5, x0
  202994:	aa1203e3 	mov	x3, x18
  202998:	aa1103e2 	mov	x2, x17
  20299c:	aa1003e1 	mov	x1, x16
  2029a0:	aa0f03e0 	mov	x0, x15
  2029a4:	17fffe53 	b	2022f0 <_out_rev>
    value = 0 - value;
  2029a8:	2f00e401 	movi	d1, #0x0
    negative = true;
  2029ac:	52800023 	mov	w3, #0x1                   	// #1
    value = 0 - value;
  2029b0:	1e603820 	fsub	d0, d1, d0
  if (!(flags & FLAGS_PRECISION)) {
  2029b4:	3757f1c7 	tbnz	w7, #10, 2027ec <_ftoa+0x7c>
  2029b8:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  2029bc:	910043ec 	add	x12, sp, #0x10
  2029c0:	f2e825c0 	movk	x0, #0x412e, lsl #48
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  2029c4:	528000c4 	mov	w4, #0x6                   	// #6
  2029c8:	9e670002 	fmov	d2, x0
  2029cc:	d2800008 	mov	x8, #0x0                   	// #0
  2029d0:	17ffff96 	b	202828 <_ftoa+0xb8>
    return _etoa(out, buffer, idx, maxlen, value, prec, width, flags);
  2029d4:	2a0703e6 	mov	w6, w7
  2029d8:	aa1203e3 	mov	x3, x18
  2029dc:	aa1103e2 	mov	x2, x17
  2029e0:	aa1003e1 	mov	x1, x16
  2029e4:	aa0f03e0 	mov	x0, x15
  2029e8:	14000066 	b	202b80 <_etoa>
    return _out_rev(out, buffer, idx, maxlen, "fni-", 4, width, flags);
  2029ec:	2a0503e6 	mov	w6, w5
  2029f0:	d0000004 	adrp	x4, 204000 <__FUNCTION__.1+0x10>
  2029f4:	d2800085 	mov	x5, #0x4                   	// #4
  2029f8:	910a8084 	add	x4, x4, #0x2a0
  2029fc:	17fffe3d 	b	2022f0 <_out_rev>
  202a00:	51008081 	sub	w1, w4, #0x20
      buf[len++] = (char)(48U + (frac % 10U));
  202a04:	b202e7e2 	mov	x2, #0xcccccccccccccccc    	// #-3689348814741910324
  202a08:	0b080021 	add	w1, w1, w8
  202a0c:	f29999a2 	movk	x2, #0xcccd
  202a10:	1400000d 	b	202a44 <_ftoa+0x2d4>
  202a14:	d343fd6b 	lsr	x11, x11, #3
      if (!(frac /= 10U)) {
  202a18:	f10025df 	cmp	x14, #0x9
      --count;
  202a1c:	51000480 	sub	w0, w4, #0x1
      buf[len++] = (char)(48U + (frac % 10U));
  202a20:	91000509 	add	x9, x8, #0x1
  202a24:	8b0b096d 	add	x13, x11, x11, lsl #2
  202a28:	cb0d05cd 	sub	x13, x14, x13, lsl #1
      if (!(frac /= 10U)) {
  202a2c:	aa0b03ee 	mov	x14, x11
      buf[len++] = (char)(48U + (frac % 10U));
  202a30:	1100c1ab 	add	w11, w13, #0x30
  202a34:	3828698b 	strb	w11, [x12, x8]
      if (!(frac /= 10U)) {
  202a38:	54000349 	b.ls	202aa0 <_ftoa+0x330>  // b.plast
      --count;
  202a3c:	2a0003e4 	mov	w4, w0
      buf[len++] = (char)(48U + (frac % 10U));
  202a40:	aa0903e8 	mov	x8, x9
  202a44:	9bc27dcb 	umulh	x11, x14, x2
    while (len < PRINTF_FTOA_BUFFER_SIZE) {
  202a48:	6b01009f 	cmp	w4, w1
  202a4c:	54fffe41 	b.ne	202a14 <_ftoa+0x2a4>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  202a50:	d2800408 	mov	x8, #0x20                  	// #32
  202a54:	17ffff8b 	b	202880 <_ftoa+0x110>
    ++frac;
  202a58:	910005ce 	add	x14, x14, #0x1
    if (frac >= pow10[prec]) {
  202a5c:	9e6301c1 	ucvtf	d1, x14
  202a60:	1e622030 	fcmpe	d1, d2
  202a64:	5400004a 	b.ge	202a6c <_ftoa+0x2fc>  // b.tcont
  202a68:	17ffff7e 	b	202860 <_ftoa+0xf0>
      ++whole;
  202a6c:	1100054a 	add	w10, w10, #0x1
      frac = 0;
  202a70:	d280000e 	mov	x14, #0x0                   	// #0
  202a74:	17ffff7b 	b	202860 <_ftoa+0xf0>
  if (!(flags & FLAGS_LEFT) && (flags & FLAGS_ZEROPAD)) {
  202a78:	120004e0 	and	w0, w7, #0x3
  202a7c:	7100041f 	cmp	w0, #0x1
  202a80:	54000780 	b.eq	202b70 <_ftoa+0x400>  // b.none
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  202a84:	f100811f 	cmp	x8, #0x20
  202a88:	54fff480 	b.eq	202918 <_ftoa+0x1a8>  // b.none
    if (negative) {
  202a8c:	34000323 	cbz	w3, 202af0 <_ftoa+0x380>
      buf[len++] = '-';
  202a90:	528005a0 	mov	w0, #0x2d                  	// #45
  202a94:	38286980 	strb	w0, [x12, x8]
  202a98:	91000508 	add	x8, x8, #0x1
  202a9c:	17ffff9f 	b	202918 <_ftoa+0x1a8>
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  202aa0:	f100813f 	cmp	x9, #0x20
  202aa4:	54fffd60 	b.eq	202a50 <_ftoa+0x2e0>  // b.none
  202aa8:	91000901 	add	x1, x8, #0x2
  202aac:	51000884 	sub	w4, w4, #0x2
  202ab0:	8b040021 	add	x1, x1, x4
      buf[len++] = '0';
  202ab4:	52800602 	mov	w2, #0x30                  	// #48
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  202ab8:	35000080 	cbnz	w0, 202ac8 <_ftoa+0x358>
  202abc:	14000013 	b	202b08 <_ftoa+0x398>
  202ac0:	eb01013f 	cmp	x9, x1
  202ac4:	54000260 	b.eq	202b10 <_ftoa+0x3a0>  // b.none
      buf[len++] = '0';
  202ac8:	91000529 	add	x9, x9, #0x1
  202acc:	8b090180 	add	x0, x12, x9
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  202ad0:	f100813f 	cmp	x9, #0x20
      buf[len++] = '0';
  202ad4:	381ff002 	sturb	w2, [x0, #-1]
    while ((len < PRINTF_FTOA_BUFFER_SIZE) && (count-- > 0U)) {
  202ad8:	54ffff41 	b.ne	202ac0 <_ftoa+0x350>  // b.any
      buf[len++] = (char)(48U + (frac % 10U));
  202adc:	d2800408 	mov	x8, #0x20                  	// #32
  202ae0:	17ffff68 	b	202880 <_ftoa+0x110>
  if (len < PRINTF_FTOA_BUFFER_SIZE) {
  202ae4:	f100811f 	cmp	x8, #0x20
  202ae8:	54fff180 	b.eq	202918 <_ftoa+0x1a8>  // b.none
  202aec:	d503201f 	nop
    else if (flags & FLAGS_PLUS) {
  202af0:	371001c7 	tbnz	w7, #2, 202b28 <_ftoa+0x3b8>
    else if (flags & FLAGS_SPACE) {
  202af4:	361ff127 	tbz	w7, #3, 202918 <_ftoa+0x1a8>
      buf[len++] = ' ';
  202af8:	52800400 	mov	w0, #0x20                  	// #32
  202afc:	38286980 	strb	w0, [x12, x8]
  202b00:	91000508 	add	x8, x8, #0x1
  202b04:	17ffff85 	b	202918 <_ftoa+0x1a8>
      buf[len++] = (char)(48U + (frac % 10U));
  202b08:	aa0903e1 	mov	x1, x9
  202b0c:	d503201f 	nop
      buf[len++] = '.';
  202b10:	528005c0 	mov	w0, #0x2e                  	// #46
  202b14:	91000428 	add	x8, x1, #0x1
  202b18:	38216980 	strb	w0, [x12, x1]
  202b1c:	17ffff59 	b	202880 <_ftoa+0x110>
    if ((!(diff < 0.5) || (diff > 0.5)) && (whole & 1)) {
  202b20:	54ffeacc 	b.gt	202878 <_ftoa+0x108>
  202b24:	17ffff57 	b	202880 <_ftoa+0x110>
      buf[len++] = '+';  // ignore the space if the '+' exists
  202b28:	52800560 	mov	w0, #0x2b                  	// #43
  202b2c:	38286980 	strb	w0, [x12, x8]
  202b30:	91000508 	add	x8, x8, #0x1
  202b34:	17ffff79 	b	202918 <_ftoa+0x1a8>
  else if ((frac == 0U) || (frac & 1U)) {
  202b38:	3607e94e 	tbz	w14, #0, 202860 <_ftoa+0xf0>
    ++frac;
  202b3c:	910005ce 	add	x14, x14, #0x1
  202b40:	17ffff48 	b	202860 <_ftoa+0xf0>
      width--;
  202b44:	510004a2 	sub	w2, w5, #0x1
  202b48:	aa0203e5 	mov	x5, x2
    while ((len < width) && (len < PRINTF_FTOA_BUFFER_SIZE)) {
  202b4c:	eb08005f 	cmp	x2, x8
  202b50:	54ffecc8 	b.hi	2028e8 <_ftoa+0x178>  // b.pmore
  202b54:	17ffffcc 	b	202a84 <_ftoa+0x314>
  double tmp = (value - whole) * pow10[prec];
  202b58:	d0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  202b5c:	91028000 	add	x0, x0, #0xa0
  202b60:	910043ec 	add	x12, sp, #0x10
  202b64:	d2800008 	mov	x8, #0x0                   	// #0
  202b68:	fc645802 	ldr	d2, [x0, w4, uxtw #3]
  202b6c:	17ffff2f 	b	202828 <_ftoa+0xb8>
    if (width && (negative || (flags & (FLAGS_PLUS | FLAGS_SPACE)))) {
  202b70:	34fff8a5 	cbz	w5, 202a84 <_ftoa+0x314>
  202b74:	17ffff57 	b	2028d0 <_ftoa+0x160>
  202b78:	d503201f 	nop
  202b7c:	d503201f 	nop

0000000000202b80 <_etoa>:


#if defined(PRINTF_SUPPORT_EXPONENTIAL)
// internal ftoa variant for exponential floating-point type, contributed by Martijn Jasperse <m.jasperse@gmail.com>
static size_t _etoa(out_fct_type out, char* buffer, size_t idx, size_t maxlen, double value, unsigned int prec, unsigned int width, unsigned int flags)
{
  202b80:	d10203ff 	sub	sp, sp, #0x80
  // check for NaN and special values
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  202b84:	1e602000 	fcmp	d0, d0
{
  202b88:	a9017bfd 	stp	x29, x30, [sp, #16]
  202b8c:	910043fd 	add	x29, sp, #0x10
  202b90:	a90253f3 	stp	x19, x20, [sp, #32]
  202b94:	aa0203f3 	mov	x19, x2
  202b98:	2a0603f4 	mov	w20, w6
  202b9c:	a9035bf5 	stp	x21, x22, [sp, #48]
  202ba0:	aa0003f5 	mov	x21, x0
  202ba4:	aa0103f6 	mov	x22, x1
  202ba8:	a90463f7 	stp	x23, x24, [sp, #64]
  202bac:	aa0303f7 	mov	x23, x3
  202bb0:	a90673fb 	stp	x27, x28, [sp, #96]
  202bb4:	2a0503fb 	mov	w27, w5
  if ((value != value) || (value > DBL_MAX) || (value < -DBL_MAX)) {
  202bb8:	540012c1 	b.ne	202e10 <_etoa+0x290>  // b.any
  202bbc:	92f00200 	mov	x0, #0x7fefffffffffffff    	// #9218868437227405311
  202bc0:	9e670001 	fmov	d1, x0
  202bc4:	1e612010 	fcmpe	d0, d1
  202bc8:	5400124c 	b.gt	202e10 <_etoa+0x290>
  202bcc:	92e00200 	mov	x0, #0xffefffffffffffff    	// #-4503599627370497
  202bd0:	9e670001 	fmov	d1, x0
  202bd4:	1e612010 	fcmpe	d0, d1
  202bd8:	540011c4 	b.mi	202e10 <_etoa+0x290>  // b.first
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  }

  // determine the sign
  const bool negative = value < 0;
  if (negative) {
  202bdc:	1e602018 	fcmpe	d0, #0.0
  202be0:	1e614002 	fneg	d2, d0

  conv.F = value;
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  // now approximate log10 from the log2 integer part and an expansion of ln around 1.5
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202be4:	d0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  202be8:	fd417016 	ldr	d22, [x0, #736]
  202bec:	d0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  202bf0:	fd417401 	ldr	d1, [x0, #744]
  202bf4:	d0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  202bf8:	fd417815 	ldr	d21, [x0, #752]
  202bfc:	1e604c42 	fcsel	d2, d2, d0, mi	// mi = first
  // now we want to compute 10^expval but we want to be sure it won't overflow
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202c00:	d0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  202c04:	fd417c14 	ldr	d20, [x0, #760]
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  202c08:	d0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  202c0c:	fd418013 	ldr	d19, [x0, #768]
  202c10:	d0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  202c14:	fd418412 	ldr	d18, [x0, #776]
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202c18:	1e6f1018 	fmov	d24, #1.500000000000000000e+00
  conv.F = value;
  202c1c:	9e660040 	fmov	x0, d2
  202c20:	a9056bf9 	stp	x25, x26, [sp, #80]
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202c24:	1e6c1005 	fmov	d5, #5.000000000000000000e-01
  const double z2 = z * z;
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  // compute exp(z) using continued fractions, see https://en.wikipedia.org/wiki/Exponential_function#Continued_fractions_for_ex
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202c28:	1e659003 	fmov	d3, #1.400000000000000000e+01
  202c2c:	1e649007 	fmov	d7, #1.000000000000000000e+01
  202c30:	1e631011 	fmov	d17, #6.000000000000000000e+00
  202c34:	1e601006 	fmov	d6, #2.000000000000000000e+00
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  202c38:	9240cc01 	and	x1, x0, #0xfffffffffffff
  int exp2 = (int)((conv.U >> 52U) & 0x07FFU) - 1023;           // effectively log2
  202c3c:	d374f800 	ubfx	x0, x0, #52, #11
  202c40:	510ffc00 	sub	w0, w0, #0x3ff
  conv.U = (conv.U & ((1ULL << 52U) - 1U)) | (1023ULL << 52U);  // drop the exponent so conv.F is now in [1,2)
  202c44:	b24c2421 	orr	x1, x1, #0x3ff0000000000000
  202c48:	9e670024 	fmov	d4, x1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202c4c:	1e6e1010 	fmov	d16, #1.000000000000000000e+00
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202c50:	1e620017 	scvtf	d23, w0
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  202c54:	721600c3 	ands	w3, w6, #0x400
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202c58:	1e783884 	fsub	d4, d4, d24
    prec = PRINTF_DEFAULT_FLOAT_PRECISION;
  202c5c:	528000c2 	mov	w2, #0x6                   	// #6
  202c60:	1a821084 	csel	w4, w4, w2, ne	// ne = any
  int expval = (int)(0.1760912590558 + exp2 * 0.301029995663981 + (conv.F - 1.5) * 0.289529654602168);
  202c64:	1f5606e1 	fmadd	d1, d23, d22, d1
  202c68:	1f550481 	fmadd	d1, d4, d21, d1
  202c6c:	1e780039 	fcvtzs	w25, d1
  exp2 = (int)(expval * 3.321928094887362 + 0.5);
  202c70:	1e620324 	scvtf	d4, w25
  202c74:	1f541481 	fmadd	d1, d4, d20, d5
  202c78:	1e780020 	fcvtzs	w0, d1
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  202c7c:	1e620001 	scvtf	d1, w0
  conv.U = (uint64_t)(exp2 + 1023) << 52U;
  202c80:	110ffc00 	add	w0, w0, #0x3ff
  202c84:	9e670005 	fmov	d5, x0
  202c88:	5f7454a5 	shl	d5, d5, #52
  const double z  = expval * 2.302585092994046 - exp2 * 0.6931471805599453;
  202c8c:	1e730821 	fmul	d1, d1, d19
  202c90:	1f728481 	fnmsub	d1, d4, d18, d1
  const double z2 = z * z;
  202c94:	1e610824 	fmul	d4, d1, d1
  conv.F *= 1 + 2 * z / (2 - z + (z2 / (6 + (z2 / (10 + z2 / 14)))));
  202c98:	1e6138c6 	fsub	d6, d6, d1
  202c9c:	1e612821 	fadd	d1, d1, d1
  202ca0:	1e631883 	fdiv	d3, d4, d3
  202ca4:	1e672863 	fadd	d3, d3, d7
  202ca8:	1e631883 	fdiv	d3, d4, d3
  202cac:	1e712863 	fadd	d3, d3, d17
  202cb0:	1e631884 	fdiv	d4, d4, d3
  202cb4:	1e662884 	fadd	d4, d4, d6
  202cb8:	1e641821 	fdiv	d1, d1, d4
  202cbc:	1e702821 	fadd	d1, d1, d16
  202cc0:	1e650821 	fmul	d1, d1, d5
  // correct for rounding errors
  if (value < conv.F) {
  202cc4:	1e612050 	fcmpe	d2, d1
  202cc8:	54000be4 	b.mi	202e44 <_etoa+0x2c4>  // b.first
    expval--;
    conv.F /= 10;
  }

  // the exponent format is "%+03d" and largest value is "307", so set aside 4-5 characters
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  202ccc:	11018f20 	add	w0, w25, #0x63
  202cd0:	7103181f 	cmp	w0, #0xc6
  202cd4:	1a9f97fc 	cset	w28, hi	// hi = pmore
  202cd8:	1100139c 	add	w28, w28, #0x4

  // in "%g" mode, "prec" is the number of *significant figures* not decimals
  if (flags & FLAGS_ADAPT_EXP) {
  202cdc:	36580134 	tbz	w20, #11, 202d00 <_etoa+0x180>
    // do we want to fall-back to "%f" mode?
    if ((value >= 1e-4) && (value < 1e6)) {
  202ce0:	d0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  202ce4:	fd418803 	ldr	d3, [x0, #784]
  202ce8:	1e632050 	fcmpe	d2, d3
  202cec:	54000cea 	b.ge	202e88 <_etoa+0x308>  // b.tcont
      minwidth = 0U;
      expval   = 0;
    }
    else {
      // we use one sigfig for the whole part
      if ((prec > 0) && (flags & FLAGS_PRECISION)) {
  202cf0:	34000084 	cbz	w4, 202d00 <_etoa+0x180>
        --prec;
  202cf4:	7100007f 	cmp	w3, #0x0
  202cf8:	1a9f07e0 	cset	w0, ne	// ne = any
  202cfc:	4b000084 	sub	w4, w4, w0

  // will everything fit?
  unsigned int fwidth = width;
  if (width > minwidth) {
    // we didn't fall-back so subtract the characters required for the exponent
    fwidth -= minwidth;
  202d00:	6b1c0365 	subs	w5, w27, w28
  } else {
    // not enough characters, so go back to default sizing
    fwidth = 0U;
  }
  if ((flags & FLAGS_LEFT) && minwidth) {
  202d04:	121f0280 	and	w0, w20, #0x2
    fwidth -= minwidth;
  202d08:	1a9f80a5 	csel	w5, w5, wzr, hi	// hi = pmore
  if ((flags & FLAGS_LEFT) && minwidth) {
  202d0c:	7100001f 	cmp	w0, #0x0
  202d10:	1a9f07e0 	cset	w0, ne	// ne = any
  202d14:	b9007fe0 	str	w0, [sp, #124]
  202d18:	1a9f00a5 	csel	w5, w5, wzr, eq	// eq = none
    // if we're padding on the right, DON'T pad the floating part
    fwidth = 0U;
  }

  // rescale the float value
  if (expval) {
  202d1c:	5280003a 	mov	w26, #0x1                   	// #1
  202d20:	34000059 	cbz	w25, 202d28 <_etoa+0x1a8>
    value /= conv.F;
  202d24:	1e611842 	fdiv	d2, d2, d1
  }

  // output the floating part
  const size_t start_idx = idx;
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202d28:	1e602018 	fcmpe	d0, #0.0
  202d2c:	54000aa4 	b.mi	202e80 <_etoa+0x300>  // b.first
  202d30:	1e604040 	fmov	d0, d2
  202d34:	12147a86 	and	w6, w20, #0xfffff7ff
  202d38:	aa1703e3 	mov	x3, x23
  202d3c:	aa1303e2 	mov	x2, x19
  202d40:	aa1603e1 	mov	x1, x22
  202d44:	aa1503e0 	mov	x0, x21
  202d48:	97fffe8a 	bl	202770 <_ftoa>
  202d4c:	aa0003f8 	mov	x24, x0

  // output the exponent part
  if (minwidth) {
  202d50:	340004fa 	cbz	w26, 202dec <_etoa+0x26c>
    // output the exponential symbol
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  202d54:	f27b029f 	tst	x20, #0x20
  202d58:	52800ca1 	mov	w1, #0x65                  	// #101
  202d5c:	aa1803e2 	mov	x2, x24
  202d60:	aa1703e3 	mov	x3, x23
  202d64:	528008a0 	mov	w0, #0x45                  	// #69
  202d68:	1a800020 	csel	w0, w1, w0, eq	// eq = none
  202d6c:	aa1603e1 	mov	x1, x22
  202d70:	d63f02a0 	blr	x21
    // output the exponent value
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  202d74:	7100033f 	cmp	w25, #0x0
  202d78:	528000a0 	mov	w0, #0x5                   	// #5
  202d7c:	5a99a724 	cneg	w4, w25, lt	// lt = tstop
  202d80:	5100079c 	sub	w28, w28, #0x1
  202d84:	b90003fc 	str	w28, [sp]
    out((flags & FLAGS_UPPERCASE) ? 'E' : 'e', buffer, idx++, maxlen);
  202d88:	91000702 	add	x2, x24, #0x1
    idx = _ntoa_long(out, buffer, idx, maxlen, (expval < 0) ? -expval : expval, expval < 0, 10, 0, minwidth-1, FLAGS_ZEROPAD | FLAGS_PLUS);
  202d8c:	b9000be0 	str	w0, [sp, #8]
  202d90:	93407c84 	sxtw	x4, w4
  202d94:	531f7f25 	lsr	w5, w25, #31
  202d98:	aa1703e3 	mov	x3, x23
  202d9c:	aa1603e1 	mov	x1, x22
  202da0:	aa1503e0 	mov	x0, x21
  202da4:	52800007 	mov	w7, #0x0                   	// #0
  202da8:	d2800146 	mov	x6, #0xa                   	// #10
  202dac:	97fffd95 	bl	202400 <_ntoa_long>
  202db0:	aa0003f8 	mov	x24, x0
    // might need to right-pad spaces
    if (flags & FLAGS_LEFT) {
  202db4:	b9407fe0 	ldr	w0, [sp, #124]
  202db8:	340001a0 	cbz	w0, 202dec <_etoa+0x26c>
      while (idx - start_idx < width) out(' ', buffer, idx++, maxlen);
  202dbc:	cb130313 	sub	x19, x24, x19
  202dc0:	eb13037f 	cmp	x27, x19
  202dc4:	54000149 	b.ls	202dec <_etoa+0x26c>  // b.plast
  202dc8:	aa1803e2 	mov	x2, x24
  202dcc:	91000673 	add	x19, x19, #0x1
  202dd0:	aa1703e3 	mov	x3, x23
  202dd4:	aa1603e1 	mov	x1, x22
  202dd8:	52800400 	mov	w0, #0x20                  	// #32
  202ddc:	d63f02a0 	blr	x21
  202de0:	91000718 	add	x24, x24, #0x1
  202de4:	eb1b027f 	cmp	x19, x27
  202de8:	54ffff03 	b.cc	202dc8 <_etoa+0x248>  // b.lo, b.ul, b.last
    }
  }
  return idx;
}
  202dec:	a9417bfd 	ldp	x29, x30, [sp, #16]
  202df0:	aa1803e0 	mov	x0, x24
  202df4:	a94253f3 	ldp	x19, x20, [sp, #32]
  202df8:	a9435bf5 	ldp	x21, x22, [sp, #48]
  202dfc:	a94463f7 	ldp	x23, x24, [sp, #64]
  202e00:	a9456bf9 	ldp	x25, x26, [sp, #80]
  202e04:	a94673fb 	ldp	x27, x28, [sp, #96]
  202e08:	910203ff 	add	sp, sp, #0x80
  202e0c:	d65f03c0 	ret
    return _ftoa(out, buffer, idx, maxlen, value, prec, width, flags);
  202e10:	2a1403e6 	mov	w6, w20
  202e14:	2a1b03e5 	mov	w5, w27
  202e18:	aa1703e3 	mov	x3, x23
  202e1c:	aa1303e2 	mov	x2, x19
  202e20:	aa1603e1 	mov	x1, x22
  202e24:	aa1503e0 	mov	x0, x21
}
  202e28:	a9417bfd 	ldp	x29, x30, [sp, #16]
  202e2c:	a94253f3 	ldp	x19, x20, [sp, #32]
  202e30:	a9435bf5 	ldp	x21, x22, [sp, #48]
  202e34:	a94463f7 	ldp	x23, x24, [sp, #64]
  202e38:	a94673fb 	ldp	x27, x28, [sp, #96]
  202e3c:	910203ff 	add	sp, sp, #0x80
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202e40:	17fffe4c 	b	202770 <_ftoa>
    conv.F /= 10;
  202e44:	1e671821 	fdiv	d1, d1, d7
    expval--;
  202e48:	51000739 	sub	w25, w25, #0x1
  unsigned int minwidth = ((expval < 100) && (expval > -100)) ? 4U : 5U;
  202e4c:	11018f20 	add	w0, w25, #0x63
  202e50:	7103181f 	cmp	w0, #0xc6
  202e54:	1a9f97fc 	cset	w28, hi	// hi = pmore
  202e58:	1100139c 	add	w28, w28, #0x4
  if (flags & FLAGS_ADAPT_EXP) {
  202e5c:	365ff534 	tbz	w20, #11, 202d00 <_etoa+0x180>
  202e60:	17ffffa0 	b	202ce0 <_etoa+0x160>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  202e64:	2a0103f4 	mov	w20, w1
    fwidth = 0U;
  202e68:	52800005 	mov	w5, #0x0                   	// #0
      minwidth = 0U;
  202e6c:	5280001c 	mov	w28, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  202e70:	5280001a 	mov	w26, #0x0                   	// #0
      expval   = 0;
  202e74:	52800019 	mov	w25, #0x0                   	// #0
  if ((flags & FLAGS_LEFT) && minwidth) {
  202e78:	b9007fff 	str	wzr, [sp, #124]
  202e7c:	d503201f 	nop
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202e80:	1e614042 	fneg	d2, d2
  202e84:	17ffffab 	b	202d30 <_etoa+0x1b0>
    if ((value >= 1e-4) && (value < 1e6)) {
  202e88:	d2d09000 	mov	x0, #0x848000000000        	// #145685290680320
  202e8c:	f2e825c0 	movk	x0, #0x412e, lsl #48
  202e90:	9e670003 	fmov	d3, x0
  202e94:	1e632050 	fcmpe	d2, d3
  202e98:	54000044 	b.mi	202ea0 <_etoa+0x320>  // b.first
  202e9c:	17ffff95 	b	202cf0 <_etoa+0x170>
        prec = (unsigned)((int)prec - expval - 1);
  202ea0:	4b190080 	sub	w0, w4, w25
  202ea4:	6b04033f 	cmp	w25, w4
  202ea8:	51000400 	sub	w0, w0, #0x1
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  202eac:	32160281 	orr	w1, w20, #0x400
        prec = (unsigned)((int)prec - expval - 1);
  202eb0:	1a9fb004 	csel	w4, w0, wzr, lt	// lt = tstop
  if (width > minwidth) {
  202eb4:	350001bb 	cbnz	w27, 202ee8 <_etoa+0x368>
  idx = _ftoa(out, buffer, idx, maxlen, negative ? -value : value, prec, fwidth, flags & ~FLAGS_ADAPT_EXP);
  202eb8:	1e602018 	fcmpe	d0, #0.0
  202ebc:	54fffd44 	b.mi	202e64 <_etoa+0x2e4>  // b.first
  202ec0:	12147a86 	and	w6, w20, #0xfffff7ff
  202ec4:	1e604040 	fmov	d0, d2
  202ec8:	a9456bf9 	ldp	x25, x26, [sp, #80]
  202ecc:	321600c6 	orr	w6, w6, #0x400
  202ed0:	aa1703e3 	mov	x3, x23
  202ed4:	aa1303e2 	mov	x2, x19
  202ed8:	aa1603e1 	mov	x1, x22
  202edc:	aa1503e0 	mov	x0, x21
  202ee0:	52800005 	mov	w5, #0x0                   	// #0
  202ee4:	17ffffd1 	b	202e28 <_etoa+0x2a8>
      flags |= FLAGS_PRECISION;   // make sure _ftoa respects precision
  202ee8:	2a0103f4 	mov	w20, w1
  if (width > minwidth) {
  202eec:	2a1b03e5 	mov	w5, w27
      minwidth = 0U;
  202ef0:	5280001c 	mov	w28, #0x0                   	// #0
  if (width > minwidth) {
  202ef4:	52800019 	mov	w25, #0x0                   	// #0
  202ef8:	5280001a 	mov	w26, #0x0                   	// #0
  202efc:	b9007fff 	str	wzr, [sp, #124]
  202f00:	17ffff8a 	b	202d28 <_etoa+0x1a8>
  202f04:	d503201f 	nop
  202f08:	d503201f 	nop
  202f0c:	d503201f 	nop

0000000000202f10 <_vsnprintf>:
#endif  // PRINTF_SUPPORT_FLOAT


// internal vsnprintf
static int _vsnprintf(out_fct_type out, char* buffer, const size_t maxlen, const char* format, va_list va)
{
  202f10:	d102c3ff 	sub	sp, sp, #0xb0
  unsigned int flags, width, precision, n;
  size_t idx = 0U;

  if (!buffer) {
    // use null output function
    out = _out_null;
  202f14:	f100003f 	cmp	x1, #0x0
{
  202f18:	a9017bfd 	stp	x29, x30, [sp, #16]
  202f1c:	910043fd 	add	x29, sp, #0x10
  202f20:	a90253f3 	stp	x19, x20, [sp, #32]
    out = _out_null;
  202f24:	90000013 	adrp	x19, 202000 <main+0x60>
  202f28:	910b8273 	add	x19, x19, #0x2e0
{
  202f2c:	a9035bf5 	stp	x21, x22, [sp, #48]
    out = _out_null;
  202f30:	9a800273 	csel	x19, x19, x0, eq	// eq = none
{
  202f34:	aa0103f5 	mov	x21, x1
  202f38:	a90463f7 	stp	x23, x24, [sp, #64]
  202f3c:	aa0203f4 	mov	x20, x2
  202f40:	b9401898 	ldr	w24, [x4, #24]
  202f44:	a90673fb 	stp	x27, x28, [sp, #96]
  }

  while (*format)
  202f48:	d280001c 	mov	x28, #0x0                   	// #0
  202f4c:	f9400880 	ldr	x0, [x4, #16]
  202f50:	f9004fe0 	str	x0, [sp, #152]
  202f54:	39400061 	ldrb	w1, [x3]
  202f58:	a9400896 	ldp	x22, x2, [x4]
  202f5c:	f90047e2 	str	x2, [sp, #136]
  202f60:	b9401c80 	ldr	w0, [x4, #28]
  202f64:	b90077e0 	str	w0, [sp, #116]
  202f68:	34004141 	cbz	w1, 203790 <_vsnprintf+0x880>
      default :
        break;
    }

    // evaluate specifier
    switch (*format) {
  202f6c:	d280003b 	mov	x27, #0x1                   	// #1
  202f70:	a9056bf9 	stp	x25, x26, [sp, #80]
  202f74:	d0000019 	adrp	x25, 204000 <__FUNCTION__.1+0x10>
  202f78:	91004320 	add	x0, x25, #0x10
  202f7c:	aa0303fa 	mov	x26, x3
  202f80:	f9003fe0 	str	x0, [sp, #120]
  202f84:	1400000a 	b	202fac <_vsnprintf+0x9c>
      out(*format, buffer, idx++, maxlen);
  202f88:	91000784 	add	x4, x28, #0x1
  202f8c:	2a0103e0 	mov	w0, w1
        out('%', buffer, idx++, maxlen);
        format++;
        break;

      default :
        out(*format, buffer, idx++, maxlen);
  202f90:	aa1c03e2 	mov	x2, x28
  202f94:	aa1403e3 	mov	x3, x20
  202f98:	aa1503e1 	mov	x1, x21
  202f9c:	aa0403fc 	mov	x28, x4
  202fa0:	d63f0260 	blr	x19
  while (*format)
  202fa4:	39400341 	ldrb	w1, [x26]
  202fa8:	34000cc1 	cbz	w1, 203140 <_vsnprintf+0x230>
      format++;
  202fac:	9100075a 	add	x26, x26, #0x1
    if (*format != '%') {
  202fb0:	7100943f 	cmp	w1, #0x25
  202fb4:	54fffea1 	b.ne	202f88 <_vsnprintf+0x78>  // b.any
      switch (*format) {
  202fb8:	aa1a03e1 	mov	x1, x26
    flags = 0U;
  202fbc:	52800006 	mov	w6, #0x0                   	// #0
      switch (*format) {
  202fc0:	38401420 	ldrb	w0, [x1], #1
  202fc4:	7100ac1f 	cmp	w0, #0x2b
  202fc8:	540001a0 	b.eq	202ffc <_vsnprintf+0xec>  // b.none
  202fcc:	d503201f 	nop
  202fd0:	540001c8 	b.hi	203008 <_vsnprintf+0xf8>  // b.pmore
  202fd4:	7100801f 	cmp	w0, #0x20
  202fd8:	54000260 	b.eq	203024 <_vsnprintf+0x114>  // b.none
  202fdc:	71008c1f 	cmp	w0, #0x23
  202fe0:	540002e1 	b.ne	20303c <_vsnprintf+0x12c>  // b.any
        case '#': flags |= FLAGS_HASH;    format++; n = 1U; break;
  202fe4:	321c00c6 	orr	w6, w6, #0x10
      format++;
  202fe8:	aa0103fa 	mov	x26, x1
      switch (*format) {
  202fec:	aa1a03e1 	mov	x1, x26
  202ff0:	38401420 	ldrb	w0, [x1], #1
  202ff4:	7100ac1f 	cmp	w0, #0x2b
  202ff8:	54fffec1 	b.ne	202fd0 <_vsnprintf+0xc0>  // b.any
        case '+': flags |= FLAGS_PLUS;    format++; n = 1U; break;
  202ffc:	321e00c6 	orr	w6, w6, #0x4
      format++;
  203000:	aa0103fa 	mov	x26, x1
  203004:	17fffffa 	b	202fec <_vsnprintf+0xdc>
      switch (*format) {
  203008:	7100b41f 	cmp	w0, #0x2d
  20300c:	54000120 	b.eq	203030 <_vsnprintf+0x120>  // b.none
  203010:	7100c01f 	cmp	w0, #0x30
  203014:	54005fe1 	b.ne	203c10 <_vsnprintf+0xd00>  // b.any
        case '0': flags |= FLAGS_ZEROPAD; format++; n = 1U; break;
  203018:	320000c6 	orr	w6, w6, #0x1
      format++;
  20301c:	aa0103fa 	mov	x26, x1
  203020:	17fffff3 	b	202fec <_vsnprintf+0xdc>
        case ' ': flags |= FLAGS_SPACE;   format++; n = 1U; break;
  203024:	321d00c6 	orr	w6, w6, #0x8
      format++;
  203028:	aa0103fa 	mov	x26, x1
  20302c:	17fffff0 	b	202fec <_vsnprintf+0xdc>
        case '-': flags |= FLAGS_LEFT;    format++; n = 1U; break;
  203030:	321f00c6 	orr	w6, w6, #0x2
      format++;
  203034:	aa0103fa 	mov	x26, x1
  203038:	17ffffed 	b	202fec <_vsnprintf+0xdc>
    else if (*format == '*') {
  20303c:	7100a81f 	cmp	w0, #0x2a
  203040:	54000ae0 	b.eq	20319c <_vsnprintf+0x28c>  // b.none
    width = 0U;
  203044:	52800019 	mov	w25, #0x0                   	// #0
    precision = 0U;
  203048:	52800017 	mov	w23, #0x0                   	// #0
    switch (*format) {
  20304c:	7101b01f 	cmp	w0, #0x6c
        format++;
  203050:	aa0103e2 	mov	x2, x1
    switch (*format) {
  203054:	54000de0 	b.eq	203210 <_vsnprintf+0x300>  // b.none
  203058:	54000969 	b.ls	203184 <_vsnprintf+0x274>  // b.plast
  20305c:	7101d01f 	cmp	w0, #0x74
  203060:	54000060 	b.eq	20306c <_vsnprintf+0x15c>  // b.none
  203064:	7101e81f 	cmp	w0, #0x7a
  203068:	54000241 	b.ne	2030b0 <_vsnprintf+0x1a0>  // b.any
        if (*format == 'l') {
  20306c:	39400740 	ldrb	w0, [x26, #1]
        flags |= (sizeof(size_t) == sizeof(long) ? FLAGS_LONG : FLAGS_LONG_LONG);
  203070:	321800c6 	orr	w6, w6, #0x100
        format++;
  203074:	9100045a 	add	x26, x2, #0x1
    switch (*format) {
  203078:	71019c1f 	cmp	w0, #0x67
  20307c:	540001e8 	b.hi	2030b8 <_vsnprintf+0x1a8>  // b.pmore
  203080:	7100901f 	cmp	w0, #0x24
  203084:	54000089 	b.ls	203094 <_vsnprintf+0x184>  // b.plast
  203088:	51009401 	sub	w1, w0, #0x25
  20308c:	7101083f 	cmp	w1, #0x42
  203090:	54000069 	b.ls	20309c <_vsnprintf+0x18c>  // b.plast
        out(*format, buffer, idx++, maxlen);
  203094:	91000784 	add	x4, x28, #0x1
  203098:	17ffffbe 	b	202f90 <_vsnprintf+0x80>
    switch (*format) {
  20309c:	f9403fe2 	ldr	x2, [sp, #120]
  2030a0:	78615841 	ldrh	w1, [x2, w1, uxtw #1]
  2030a4:	10000062 	adr	x2, 2030b0 <_vsnprintf+0x1a0>
  2030a8:	8b21a841 	add	x1, x2, w1, sxth #2
  2030ac:	d61f0020 	br	x1
        format++;
  2030b0:	aa0103fa 	mov	x26, x1
  2030b4:	d503201f 	nop
    switch (*format) {
  2030b8:	5101a401 	sub	w1, w0, #0x69
  2030bc:	12001c21 	and	w1, w1, #0xff
  2030c0:	71003c3f 	cmp	w1, #0xf
  2030c4:	54fffe88 	b.hi	203094 <_vsnprintf+0x184>  // b.pmore
  2030c8:	9ac12362 	lsl	x2, x27, x1
  2030cc:	d2920823 	mov	x3, #0x9041                	// #36929
  2030d0:	ea03005f 	tst	x2, x3
  2030d4:	54003021 	b.ne	2036d8 <_vsnprintf+0x7c8>  // b.any
  2030d8:	7100283f 	cmp	w1, #0xa
  2030dc:	540014a0 	b.eq	203370 <_vsnprintf+0x460>  // b.none
  2030e0:	71001c3f 	cmp	w1, #0x7
  2030e4:	54fffd81 	b.ne	203094 <_vsnprintf+0x184>  // b.any
        flags |= FLAGS_ZEROPAD | FLAGS_UPPERCASE;
  2030e8:	52800420 	mov	w0, #0x21                  	// #33
  2030ec:	2a0000c0 	orr	w0, w6, w0
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  2030f0:	37f820f8 	tbnz	w24, #31, 20350c <_vsnprintf+0x5fc>
  2030f4:	91003ec2 	add	x2, x22, #0xf
  2030f8:	aa1603e1 	mov	x1, x22
  2030fc:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203100:	2a1703e7 	mov	w7, w23
  203104:	aa1c03e2 	mov	x2, x28
  203108:	f9400024 	ldr	x4, [x1]
  20310c:	d2800206 	mov	x6, #0x10                  	// #16
  203110:	52800201 	mov	w1, #0x10                  	// #16
  203114:	b90003e1 	str	w1, [sp]
  203118:	b9000be0 	str	w0, [sp, #8]
  20311c:	52800005 	mov	w5, #0x0                   	// #0
  203120:	aa1503e1 	mov	x1, x21
  203124:	aa1403e3 	mov	x3, x20
  203128:	aa1303e0 	mov	x0, x19
  20312c:	97fffcb5 	bl	202400 <_ntoa_long>
  while (*format)
  203130:	39400341 	ldrb	w1, [x26]
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  203134:	aa0003fc 	mov	x28, x0
  while (*format)
  203138:	35fff3a1 	cbnz	w1, 202fac <_vsnprintf+0x9c>
  20313c:	d503201f 	nop
  203140:	a9456bf9 	ldp	x25, x26, [sp, #80]

  // termination
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);

  // return written chars without terminating \0
  return (int)idx;
  203144:	2a1c03f6 	mov	w22, w28
  out((char)0, buffer, idx < maxlen ? idx : maxlen - 1U, maxlen);
  203148:	eb1c029f 	cmp	x20, x28
  20314c:	d1000682 	sub	x2, x20, #0x1
  203150:	aa1503e1 	mov	x1, x21
  203154:	9a9c9042 	csel	x2, x2, x28, ls	// ls = plast
  203158:	aa1403e3 	mov	x3, x20
  20315c:	52800000 	mov	w0, #0x0                   	// #0
  203160:	d63f0260 	blr	x19
}
  203164:	a9417bfd 	ldp	x29, x30, [sp, #16]
  203168:	2a1603e0 	mov	w0, w22
  20316c:	a94253f3 	ldp	x19, x20, [sp, #32]
  203170:	a9435bf5 	ldp	x21, x22, [sp, #48]
  203174:	a94463f7 	ldp	x23, x24, [sp, #64]
  203178:	a94673fb 	ldp	x27, x28, [sp, #96]
  20317c:	9102c3ff 	add	sp, sp, #0xb0
  203180:	d65f03c0 	ret
    switch (*format) {
  203184:	7101a01f 	cmp	w0, #0x68
  203188:	54000ea0 	b.eq	20335c <_vsnprintf+0x44c>  // b.none
  20318c:	7101a81f 	cmp	w0, #0x6a
  203190:	54fff6e0 	b.eq	20306c <_vsnprintf+0x15c>  // b.none
  203194:	aa1a03e2 	mov	x2, x26
  203198:	17ffffb7 	b	203074 <_vsnprintf+0x164>
      const int w = va_arg(va, int);
  20319c:	37f80498 	tbnz	w24, #31, 20322c <_vsnprintf+0x31c>
  2031a0:	91002ec2 	add	x2, x22, #0xb
  2031a4:	aa1603e0 	mov	x0, x22
  2031a8:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2031ac:	b9400019 	ldr	w25, [x0]
      if (w < 0) {
  2031b0:	36f80079 	tbz	w25, #31, 2031bc <_vsnprintf+0x2ac>
        flags |= FLAGS_LEFT;    // reverse padding
  2031b4:	321f00c6 	orr	w6, w6, #0x2
        width = (unsigned int)-w;
  2031b8:	4b1903f9 	neg	w25, w25
    if (*format == '.') {
  2031bc:	39400740 	ldrb	w0, [x26, #1]
      format++;
  2031c0:	aa0103fa 	mov	x26, x1
  2031c4:	91000421 	add	x1, x1, #0x1
    if (*format == '.') {
  2031c8:	7100b81f 	cmp	w0, #0x2e
    precision = 0U;
  2031cc:	52800017 	mov	w23, #0x0                   	// #0
    if (*format == '.') {
  2031d0:	54fff3e1 	b.ne	20304c <_vsnprintf+0x13c>  // b.any
      if (_is_digit(*format)) {
  2031d4:	39400740 	ldrb	w0, [x26, #1]
      flags |= FLAGS_PRECISION;
  2031d8:	321600c6 	orr	w6, w6, #0x400
      format++;
  2031dc:	aa0103e2 	mov	x2, x1
  return (ch >= '0') && (ch <= '9');
  2031e0:	5100c003 	sub	w3, w0, #0x30
      if (_is_digit(*format)) {
  2031e4:	12001c63 	and	w3, w3, #0xff
  2031e8:	7100247f 	cmp	w3, #0x9
  2031ec:	54001489 	b.ls	20347c <_vsnprintf+0x56c>  // b.plast
      else if (*format == '*') {
  2031f0:	7100a81f 	cmp	w0, #0x2a
  2031f4:	540025c0 	b.eq	2036ac <_vsnprintf+0x79c>  // b.none
      format++;
  2031f8:	aa0103fa 	mov	x26, x1
  2031fc:	91000421 	add	x1, x1, #0x1
    switch (*format) {
  203200:	7101b01f 	cmp	w0, #0x6c
        format++;
  203204:	aa0103e2 	mov	x2, x1
    switch (*format) {
  203208:	54fff281 	b.ne	203058 <_vsnprintf+0x148>  // b.any
  20320c:	d503201f 	nop
        if (*format == 'l') {
  203210:	39400740 	ldrb	w0, [x26, #1]
  203214:	7101b01f 	cmp	w0, #0x6c
  203218:	54fff2c1 	b.ne	203070 <_vsnprintf+0x160>  // b.any
    switch (*format) {
  20321c:	39400b40 	ldrb	w0, [x26, #2]
          flags |= FLAGS_LONG_LONG;
  203220:	321804c6 	orr	w6, w6, #0x300
          format++;
  203224:	91000b42 	add	x2, x26, #0x2
  203228:	17ffff93 	b	203074 <_vsnprintf+0x164>
      const int w = va_arg(va, int);
  20322c:	11002302 	add	w2, w24, #0x8
  203230:	7100005f 	cmp	w2, #0x0
  203234:	540018ed 	b.le	203550 <_vsnprintf+0x640>
  203238:	91002ec3 	add	x3, x22, #0xb
  20323c:	aa1603e0 	mov	x0, x22
  203240:	2a0203f8 	mov	w24, w2
  203244:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203248:	17ffffd9 	b	2031ac <_vsnprintf+0x29c>
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  20324c:	121a7801 	and	w1, w0, #0xffffffdf
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  203250:	121e7800 	and	w0, w0, #0xfffffffd
        if ((*format == 'g')||(*format == 'G')) flags |= FLAGS_ADAPT_EXP;
  203254:	71011c3f 	cmp	w1, #0x47
  203258:	321500c1 	orr	w1, w6, #0x800
  20325c:	1a860026 	csel	w6, w1, w6, eq	// eq = none
        if ((*format == 'E')||(*format == 'G')) flags |= FLAGS_UPPERCASE;
  203260:	7101141f 	cmp	w0, #0x45
  203264:	321b00c0 	orr	w0, w6, #0x20
  203268:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  20326c:	b94077e0 	ldr	w0, [sp, #116]
  203270:	37f815e0 	tbnz	w0, #31, 20352c <_vsnprintf+0x61c>
  203274:	91003ec1 	add	x1, x22, #0xf
  203278:	aa1603e0 	mov	x0, x22
  20327c:	927df036 	and	x22, x1, #0xfffffffffffffff8
  203280:	fd400000 	ldr	d0, [x0]
  203284:	aa1c03e2 	mov	x2, x28
  203288:	2a1903e5 	mov	w5, w25
  20328c:	2a1703e4 	mov	w4, w23
  203290:	aa1403e3 	mov	x3, x20
  203294:	aa1503e1 	mov	x1, x21
  203298:	aa1303e0 	mov	x0, x19
  20329c:	97fffe39 	bl	202b80 <_etoa>
  2032a0:	aa0003fc 	mov	x28, x0
        break;
  2032a4:	17ffff40 	b	202fa4 <_vsnprintf+0x94>
        if (*format == 'F') flags |= FLAGS_UPPERCASE;
  2032a8:	7101181f 	cmp	w0, #0x46
  2032ac:	321b00c0 	orr	w0, w6, #0x20
  2032b0:	1a860006 	csel	w6, w0, w6, eq	// eq = none
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  2032b4:	b94077e0 	ldr	w0, [sp, #116]
  2032b8:	37f81180 	tbnz	w0, #31, 2034e8 <_vsnprintf+0x5d8>
  2032bc:	91003ec1 	add	x1, x22, #0xf
  2032c0:	aa1603e0 	mov	x0, x22
  2032c4:	927df036 	and	x22, x1, #0xfffffffffffffff8
  2032c8:	fd400000 	ldr	d0, [x0]
  2032cc:	aa1c03e2 	mov	x2, x28
  2032d0:	2a1903e5 	mov	w5, w25
  2032d4:	2a1703e4 	mov	w4, w23
  2032d8:	aa1403e3 	mov	x3, x20
  2032dc:	aa1503e1 	mov	x1, x21
  2032e0:	aa1303e0 	mov	x0, x19
  2032e4:	97fffd23 	bl	202770 <_ftoa>
  2032e8:	aa0003fc 	mov	x28, x0
        break;
  2032ec:	17ffff2e 	b	202fa4 <_vsnprintf+0x94>
        unsigned int l = 1U;
  2032f0:	52800020 	mov	w0, #0x1                   	// #1
  2032f4:	b90083e0 	str	w0, [sp, #128]
        if (!(flags & FLAGS_LEFT)) {
  2032f8:	121f00c0 	and	w0, w6, #0x2
  2032fc:	b90093e0 	str	w0, [sp, #144]
  203300:	36081ac6 	tbz	w6, #1, 203658 <_vsnprintf+0x748>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  203304:	37f80d38 	tbnz	w24, #31, 2034a8 <_vsnprintf+0x598>
  203308:	91002ec1 	add	x1, x22, #0xb
  20330c:	aa1603e0 	mov	x0, x22
  203310:	927df036 	and	x22, x1, #0xfffffffffffffff8
  203314:	39400000 	ldrb	w0, [x0]
  203318:	aa1403e3 	mov	x3, x20
  20331c:	aa1c03e2 	mov	x2, x28
  203320:	aa1503e1 	mov	x1, x21
  203324:	91000797 	add	x23, x28, #0x1
  203328:	d63f0260 	blr	x19
        if (flags & FLAGS_LEFT) {
  20332c:	b94093e0 	ldr	w0, [sp, #144]
  203330:	35001700 	cbnz	w0, 203610 <_vsnprintf+0x700>
        break;
  203334:	aa1703fc 	mov	x28, x23
  203338:	17ffff1b 	b	202fa4 <_vsnprintf+0x94>
        out('%', buffer, idx++, maxlen);
  20333c:	91000780 	add	x0, x28, #0x1
  203340:	aa1c03e2 	mov	x2, x28
  203344:	aa1403e3 	mov	x3, x20
  203348:	aa0003fc 	mov	x28, x0
  20334c:	aa1503e1 	mov	x1, x21
  203350:	528004a0 	mov	w0, #0x25                  	// #37
  203354:	d63f0260 	blr	x19
        break;
  203358:	17ffff13 	b	202fa4 <_vsnprintf+0x94>
        if (*format == 'h') {
  20335c:	39400740 	ldrb	w0, [x26, #1]
  203360:	7101a01f 	cmp	w0, #0x68
  203364:	54002020 	b.eq	203768 <_vsnprintf+0x858>  // b.none
        flags |= FLAGS_SHORT;
  203368:	321900c6 	orr	w6, w6, #0x80
  20336c:	17ffff42 	b	203074 <_vsnprintf+0x164>
        const char* p = va_arg(va, char*);
  203370:	37f80ad8 	tbnz	w24, #31, 2034c8 <_vsnprintf+0x5b8>
  203374:	91003ec1 	add	x1, x22, #0xf
  203378:	aa1603e0 	mov	x0, x22
  20337c:	927df036 	and	x22, x1, #0xfffffffffffffff8
  203380:	f940000a 	ldr	x10, [x0]
        unsigned int l = _strnlen_s(p, precision ? precision : (size_t)-1);
  203384:	710002ff 	cmp	w23, #0x0
  203388:	2a1703e3 	mov	w3, w23
  20338c:	da9f1063 	csinv	x3, x3, xzr, ne	// ne = any
  for (s = str; *s && maxsize--; ++s);
  203390:	39400140 	ldrb	w0, [x10]
  203394:	34003500 	cbz	w0, 203a34 <_vsnprintf+0xb24>
  203398:	8b030143 	add	x3, x10, x3
  20339c:	aa0a03e1 	mov	x1, x10
  2033a0:	14000003 	b	2033ac <_vsnprintf+0x49c>
  2033a4:	eb03003f 	cmp	x1, x3
  2033a8:	54000060 	b.eq	2033b4 <_vsnprintf+0x4a4>  // b.none
  2033ac:	38401c22 	ldrb	w2, [x1, #1]!
  2033b0:	35ffffa2 	cbnz	w2, 2033a4 <_vsnprintf+0x494>
  return (unsigned int)(s - str);
  2033b4:	4b0a0021 	sub	w1, w1, w10
  2033b8:	b90093e1 	str	w1, [sp, #144]
        if (flags & FLAGS_PRECISION) {
  2033bc:	121600c1 	and	w1, w6, #0x400
  2033c0:	b900abe1 	str	w1, [sp, #168]
  2033c4:	365000a6 	tbz	w6, #10, 2033d8 <_vsnprintf+0x4c8>
          l = (l < precision ? l : precision);
  2033c8:	b94093e1 	ldr	w1, [sp, #144]
  2033cc:	6b17003f 	cmp	w1, w23
  2033d0:	1a979021 	csel	w1, w1, w23, ls	// ls = plast
  2033d4:	b90093e1 	str	w1, [sp, #144]
        if (!(flags & FLAGS_LEFT)) {
  2033d8:	121f00c1 	and	w1, w6, #0x2
  2033dc:	b900afe1 	str	w1, [sp, #172]
  2033e0:	36081f26 	tbz	w6, #1, 2037c4 <_vsnprintf+0x8b4>
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2033e4:	340002a0 	cbz	w0, 203438 <_vsnprintf+0x528>
  2033e8:	b940abe1 	ldr	w1, [sp, #168]
  2033ec:	34001aa1 	cbz	w1, 203740 <_vsnprintf+0x830>
  2033f0:	8b374381 	add	x1, x28, w23, uxtw
            out(' ', buffer, idx++, maxlen);
  2033f4:	aa1c03e2 	mov	x2, x28
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  2033f8:	cb1c0157 	sub	x23, x10, x28
  2033fc:	f90043e1 	str	x1, [sp, #128]
  203400:	14000008 	b	203420 <_vsnprintf+0x510>
          out(*(p++), buffer, idx++, maxlen);
  203404:	9100045c 	add	x28, x2, #0x1
  203408:	aa1403e3 	mov	x3, x20
  20340c:	aa1503e1 	mov	x1, x21
  203410:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  203414:	387c6ae0 	ldrb	w0, [x23, x28]
  203418:	340000c0 	cbz	w0, 203430 <_vsnprintf+0x520>
          out(*(p++), buffer, idx++, maxlen);
  20341c:	aa1c03e2 	mov	x2, x28
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  203420:	f94043e1 	ldr	x1, [sp, #128]
  203424:	eb02003f 	cmp	x1, x2
  203428:	54fffee1 	b.ne	203404 <_vsnprintf+0x4f4>  // b.any
  20342c:	aa0103fc 	mov	x28, x1
        if (flags & FLAGS_LEFT) {
  203430:	b940afe0 	ldr	w0, [sp, #172]
  203434:	34ffdb80 	cbz	w0, 202fa4 <_vsnprintf+0x94>
          while (l++ < width) {
  203438:	b94093e1 	ldr	w1, [sp, #144]
  20343c:	aa1c03f7 	mov	x23, x28
  203440:	6b19003f 	cmp	w1, w25
  203444:	54ffdb02 	b.cs	202fa4 <_vsnprintf+0x94>  // b.hs, b.nlast
  203448:	51000720 	sub	w0, w25, #0x1
  20344c:	91000789 	add	x9, x28, #0x1
  203450:	4b010000 	sub	w0, w0, w1
  203454:	8b09001c 	add	x28, x0, x9
            out(' ', buffer, idx++, maxlen);
  203458:	aa1703e2 	mov	x2, x23
  20345c:	aa1403e3 	mov	x3, x20
  203460:	910006f7 	add	x23, x23, #0x1
  203464:	aa1503e1 	mov	x1, x21
  203468:	52800400 	mov	w0, #0x20                  	// #32
  20346c:	d63f0260 	blr	x19
          while (l++ < width) {
  203470:	eb1c02ff 	cmp	x23, x28
  203474:	54ffff21 	b.ne	203458 <_vsnprintf+0x548>  // b.any
  203478:	17fffecb 	b	202fa4 <_vsnprintf+0x94>
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20347c:	52800143 	mov	w3, #0xa                   	// #10
  203480:	1b0302e7 	madd	w7, w23, w3, w0
  while (_is_digit(**str)) {
  203484:	38401c40 	ldrb	w0, [x2, #1]!
  return (ch >= '0') && (ch <= '9');
  203488:	5100c001 	sub	w1, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20348c:	5100c0f7 	sub	w23, w7, #0x30
  while (_is_digit(**str)) {
  203490:	12001c21 	and	w1, w1, #0xff
  203494:	7100243f 	cmp	w1, #0x9
  203498:	54ffff49 	b.ls	203480 <_vsnprintf+0x570>  // b.plast
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  20349c:	aa0203fa 	mov	x26, x2
  2034a0:	91000441 	add	x1, x2, #0x1
  2034a4:	17fffeea 	b	20304c <_vsnprintf+0x13c>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  2034a8:	11002301 	add	w1, w24, #0x8
  2034ac:	7100003f 	cmp	w1, #0x0
  2034b0:	540024ed 	b.le	20394c <_vsnprintf+0xa3c>
  2034b4:	91002ec2 	add	x2, x22, #0xb
  2034b8:	aa1603e0 	mov	x0, x22
  2034bc:	2a0103f8 	mov	w24, w1
  2034c0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2034c4:	17ffff94 	b	203314 <_vsnprintf+0x404>
        const char* p = va_arg(va, char*);
  2034c8:	11002301 	add	w1, w24, #0x8
  2034cc:	7100003f 	cmp	w1, #0x0
  2034d0:	540021ad 	b.le	203904 <_vsnprintf+0x9f4>
  2034d4:	91003ec2 	add	x2, x22, #0xf
  2034d8:	aa1603e0 	mov	x0, x22
  2034dc:	2a0103f8 	mov	w24, w1
  2034e0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2034e4:	17ffffa7 	b	203380 <_vsnprintf+0x470>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  2034e8:	b94077e0 	ldr	w0, [sp, #116]
  2034ec:	11004001 	add	w1, w0, #0x10
  2034f0:	7100003f 	cmp	w1, #0x0
  2034f4:	5400218d 	b.le	203924 <_vsnprintf+0xa14>
  2034f8:	91003ec2 	add	x2, x22, #0xf
  2034fc:	aa1603e0 	mov	x0, x22
  203500:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203504:	b90077e1 	str	w1, [sp, #116]
  203508:	17ffff70 	b	2032c8 <_vsnprintf+0x3b8>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  20350c:	11002302 	add	w2, w24, #0x8
  203510:	7100005f 	cmp	w2, #0x0
  203514:	5400200d 	b.le	203914 <_vsnprintf+0xa04>
  203518:	91003ec3 	add	x3, x22, #0xf
  20351c:	aa1603e1 	mov	x1, x22
  203520:	2a0203f8 	mov	w24, w2
  203524:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203528:	17fffef6 	b	203100 <_vsnprintf+0x1f0>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  20352c:	b94077e0 	ldr	w0, [sp, #116]
  203530:	11004001 	add	w1, w0, #0x10
  203534:	7100003f 	cmp	w1, #0x0
  203538:	5400200d 	b.le	203938 <_vsnprintf+0xa28>
  20353c:	91003ec2 	add	x2, x22, #0xf
  203540:	aa1603e0 	mov	x0, x22
  203544:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203548:	b90077e1 	str	w1, [sp, #116]
  20354c:	17ffff4d 	b	203280 <_vsnprintf+0x370>
      const int w = va_arg(va, int);
  203550:	f94047e0 	ldr	x0, [sp, #136]
  203554:	8b38c000 	add	x0, x0, w24, sxtw
  203558:	2a0203f8 	mov	w24, w2
  20355c:	17ffff14 	b	2031ac <_vsnprintf+0x29c>
        if (*format == 'x' || *format == 'X') {
  203560:	121a7801 	and	w1, w0, #0xffffffdf
  203564:	7101603f 	cmp	w1, #0x58
  203568:	54001080 	b.eq	203778 <_vsnprintf+0x868>  // b.none
        else if (*format == 'b') {
  20356c:	7101881f 	cmp	w0, #0x62
  203570:	54001920 	b.eq	203894 <_vsnprintf+0x984>  // b.none
        if ((*format != 'i') && (*format != 'd')) {
  203574:	52800c81 	mov	w1, #0x64                  	// #100
  203578:	7101a41f 	cmp	w0, #0x69
  20357c:	7a411004 	ccmp	w0, w1, #0x4, ne	// ne = any
          flags &= ~FLAGS_HASH;   // no hash for dec format
  203580:	121b78c6 	and	w6, w6, #0xffffffef
        if ((*format != 'i') && (*format != 'd')) {
  203584:	d2800141 	mov	x1, #0xa                   	// #10
  203588:	54000b41 	b.ne	2036f0 <_vsnprintf+0x7e0>  // b.any
          flags &= ~FLAGS_ZEROPAD;
  20358c:	f27600df 	tst	x6, #0x400
  203590:	121f78c2 	and	w2, w6, #0xfffffffe
  203594:	1a861046 	csel	w6, w2, w6, ne	// ne = any
        if ((*format == 'i') || (*format == 'd')) {
  203598:	7101a41f 	cmp	w0, #0x69
  20359c:	52800c82 	mov	w2, #0x64                  	// #100
          if (flags & FLAGS_LONG_LONG) {
  2035a0:	121700c3 	and	w3, w6, #0x200
        if ((*format == 'i') || (*format == 'd')) {
  2035a4:	7a421004 	ccmp	w0, w2, #0x4, ne	// ne = any
  2035a8:	54000b81 	b.ne	203718 <_vsnprintf+0x808>  // b.any
          if (flags & FLAGS_LONG_LONG) {
  2035ac:	35001903 	cbnz	w3, 2038cc <_vsnprintf+0x9bc>
          else if (flags & FLAGS_LONG) {
  2035b0:	37401d66 	tbnz	w6, #8, 20395c <_vsnprintf+0xa4c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  2035b4:	37301626 	tbnz	w6, #6, 203878 <_vsnprintf+0x968>
  2035b8:	363822e6 	tbz	w6, #7, 203a14 <_vsnprintf+0xb04>
  2035bc:	37f82d58 	tbnz	w24, #31, 203b64 <_vsnprintf+0xc54>
  2035c0:	91002ec2 	add	x2, x22, #0xb
  2035c4:	aa1603e0 	mov	x0, x22
  2035c8:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2035cc:	79c00005 	ldrsh	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  2035d0:	710000bf 	cmp	w5, #0x0
  2035d4:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  2035d8:	12003c84 	and	w4, w4, #0xffff
  2035dc:	2a1703e7 	mov	w7, w23
  2035e0:	531f7ca5 	lsr	w5, w5, #31
  2035e4:	93407c84 	sxtw	x4, w4
  2035e8:	aa1c03e2 	mov	x2, x28
  2035ec:	b9000be6 	str	w6, [sp, #8]
  2035f0:	aa0103e6 	mov	x6, x1
  2035f4:	b90003f9 	str	w25, [sp]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  2035f8:	aa1403e3 	mov	x3, x20
  2035fc:	aa1503e1 	mov	x1, x21
  203600:	aa1303e0 	mov	x0, x19
  203604:	97fffb7f 	bl	202400 <_ntoa_long>
  203608:	aa0003fc 	mov	x28, x0
        break;
  20360c:	17fffe66 	b	202fa4 <_vsnprintf+0x94>
          while (l++ < width) {
  203610:	b94083e0 	ldr	w0, [sp, #128]
  203614:	6b19001f 	cmp	w0, w25
  203618:	54ffe8e2 	b.cs	203334 <_vsnprintf+0x424>  // b.hs, b.nlast
  20361c:	51000725 	sub	w5, w25, #0x1
  203620:	91000b89 	add	x9, x28, #0x2
  203624:	4b0000a0 	sub	w0, w5, w0
  203628:	8b090019 	add	x25, x0, x9
  20362c:	d503201f 	nop
            out(' ', buffer, idx++, maxlen);
  203630:	aa1703e2 	mov	x2, x23
  203634:	aa1403e3 	mov	x3, x20
  203638:	910006f7 	add	x23, x23, #0x1
  20363c:	aa1503e1 	mov	x1, x21
  203640:	52800400 	mov	w0, #0x20                  	// #32
  203644:	d63f0260 	blr	x19
          while (l++ < width) {
  203648:	eb1902ff 	cmp	x23, x25
  20364c:	54ffff21 	b.ne	203630 <_vsnprintf+0x720>  // b.any
        break;
  203650:	aa1703fc 	mov	x28, x23
  203654:	17fffe54 	b	202fa4 <_vsnprintf+0x94>
          while (l++ < width) {
  203658:	7100073f 	cmp	w25, #0x1
  20365c:	54002409 	b.ls	203adc <_vsnprintf+0xbcc>  // b.plast
  203660:	91000784 	add	x4, x28, #0x1
  203664:	51000b20 	sub	w0, w25, #0x2
  203668:	8b000097 	add	x23, x4, x0
  20366c:	14000002 	b	203674 <_vsnprintf+0x764>
  203670:	91000484 	add	x4, x4, #0x1
  203674:	f90043e4 	str	x4, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  203678:	aa1c03e2 	mov	x2, x28
  20367c:	aa1403e3 	mov	x3, x20
  203680:	aa1503e1 	mov	x1, x21
  203684:	52800400 	mov	w0, #0x20                  	// #32
  203688:	d63f0260 	blr	x19
  20368c:	f94043e4 	ldr	x4, [sp, #128]
  203690:	aa0403fc 	mov	x28, x4
          while (l++ < width) {
  203694:	eb17009f 	cmp	x4, x23
  203698:	54fffec1 	b.ne	203670 <_vsnprintf+0x760>  // b.any
  20369c:	11000720 	add	w0, w25, #0x1
  2036a0:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  2036a4:	36ffe338 	tbz	w24, #31, 203308 <_vsnprintf+0x3f8>
  2036a8:	17ffff80 	b	2034a8 <_vsnprintf+0x598>
        const int prec = (int)va_arg(va, int);
  2036ac:	37f807d8 	tbnz	w24, #31, 2037a4 <_vsnprintf+0x894>
  2036b0:	91002ec1 	add	x1, x22, #0xb
  2036b4:	aa1603e0 	mov	x0, x22
  2036b8:	927df036 	and	x22, x1, #0xfffffffffffffff8
        precision = prec > 0 ? (unsigned int)prec : 0U;
  2036bc:	b9400007 	ldr	w7, [x0]
        format++;
  2036c0:	91000b5a 	add	x26, x26, #0x2
    switch (*format) {
  2036c4:	39400340 	ldrb	w0, [x26]
  2036c8:	91000741 	add	x1, x26, #0x1
        precision = prec > 0 ? (unsigned int)prec : 0U;
  2036cc:	710000ff 	cmp	w7, #0x0
  2036d0:	1a9fa0f7 	csel	w23, w7, wzr, ge	// ge = tcont
        format++;
  2036d4:	17fffe5e 	b	20304c <_vsnprintf+0x13c>
        if (*format == 'x' || *format == 'X') {
  2036d8:	121a7801 	and	w1, w0, #0xffffffdf
  2036dc:	7101603f 	cmp	w1, #0x58
  2036e0:	540005c0 	b.eq	203798 <_vsnprintf+0x888>  // b.none
        else if (*format == 'o') {
  2036e4:	7101bc1f 	cmp	w0, #0x6f
  2036e8:	d2800101 	mov	x1, #0x8                   	// #8
  2036ec:	54fff441 	b.ne	203574 <_vsnprintf+0x664>  // b.any
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  2036f0:	121c74c6 	and	w6, w6, #0xfffffff3
  2036f4:	d503201f 	nop
          flags &= ~FLAGS_ZEROPAD;
  2036f8:	f27600df 	tst	x6, #0x400
  2036fc:	121f78c2 	and	w2, w6, #0xfffffffe
  203700:	1a861046 	csel	w6, w2, w6, ne	// ne = any
        if ((*format == 'i') || (*format == 'd')) {
  203704:	7101a41f 	cmp	w0, #0x69
  203708:	52800c82 	mov	w2, #0x64                  	// #100
          if (flags & FLAGS_LONG_LONG) {
  20370c:	121700c3 	and	w3, w6, #0x200
        if ((*format == 'i') || (*format == 'd')) {
  203710:	7a421004 	ccmp	w0, w2, #0x4, ne	// ne = any
  203714:	54fff4c0 	b.eq	2035ac <_vsnprintf+0x69c>  // b.none
          if (flags & FLAGS_LONG_LONG) {
  203718:	35000c43 	cbnz	w3, 2038a0 <_vsnprintf+0x990>
          else if (flags & FLAGS_LONG) {
  20371c:	374013c6 	tbnz	w6, #8, 203994 <_vsnprintf+0xa84>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203720:	37300926 	tbnz	w6, #6, 203844 <_vsnprintf+0x934>
  203724:	363816c6 	tbz	w6, #7, 2039fc <_vsnprintf+0xaec>
  203728:	37f822f8 	tbnz	w24, #31, 203b84 <_vsnprintf+0xc74>
  20372c:	aa1603e0 	mov	x0, x22
  203730:	91002ec2 	add	x2, x22, #0xb
  203734:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203738:	79400004 	ldrh	w4, [x0]
  20373c:	14000047 	b	203858 <_vsnprintf+0x948>
  203740:	cb1c0157 	sub	x23, x10, x28
  203744:	d503201f 	nop
          out(*(p++), buffer, idx++, maxlen);
  203748:	aa1c03e2 	mov	x2, x28
  20374c:	9100079c 	add	x28, x28, #0x1
  203750:	aa1403e3 	mov	x3, x20
  203754:	aa1503e1 	mov	x1, x21
  203758:	d63f0260 	blr	x19
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  20375c:	387c6ae0 	ldrb	w0, [x23, x28]
  203760:	35ffff40 	cbnz	w0, 203748 <_vsnprintf+0x838>
  203764:	17ffff33 	b	203430 <_vsnprintf+0x520>
    switch (*format) {
  203768:	39400b40 	ldrb	w0, [x26, #2]
          flags |= FLAGS_CHAR;
  20376c:	321a04c6 	orr	w6, w6, #0xc0
          format++;
  203770:	91000b42 	add	x2, x26, #0x2
  203774:	17fffe40 	b	203074 <_vsnprintf+0x164>
        if (*format == 'X') {
  203778:	7101601f 	cmp	w0, #0x58
  20377c:	540000e1 	b.ne	203798 <_vsnprintf+0x888>  // b.any
          flags |= FLAGS_UPPERCASE;
  203780:	321b00c6 	orr	w6, w6, #0x20
  203784:	d2800201 	mov	x1, #0x10                  	// #16
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  203788:	121c74c6 	and	w6, w6, #0xfffffff3
  20378c:	17ffffdb 	b	2036f8 <_vsnprintf+0x7e8>
  while (*format)
  203790:	52800016 	mov	w22, #0x0                   	// #0
  203794:	17fffe6d 	b	203148 <_vsnprintf+0x238>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  203798:	121c74c6 	and	w6, w6, #0xfffffff3
        if (*format == 'X') {
  20379c:	d2800201 	mov	x1, #0x10                  	// #16
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  2037a0:	17ffffd6 	b	2036f8 <_vsnprintf+0x7e8>
        const int prec = (int)va_arg(va, int);
  2037a4:	11002301 	add	w1, w24, #0x8
  2037a8:	7100003f 	cmp	w1, #0x0
  2037ac:	5400044d 	b.le	203834 <_vsnprintf+0x924>
  2037b0:	91002ec2 	add	x2, x22, #0xb
  2037b4:	aa1603e0 	mov	x0, x22
  2037b8:	2a0103f8 	mov	w24, w1
  2037bc:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2037c0:	17ffffbf 	b	2036bc <_vsnprintf+0x7ac>
          while (l++ < width) {
  2037c4:	b94093e1 	ldr	w1, [sp, #144]
  2037c8:	6b19003f 	cmp	w1, w25
  2037cc:	54001902 	b.cs	203aec <_vsnprintf+0xbdc>  // b.hs, b.nlast
  2037d0:	51000720 	sub	w0, w25, #0x1
  2037d4:	91000784 	add	x4, x28, #0x1
  2037d8:	4b010000 	sub	w0, w0, w1
  2037dc:	8b040000 	add	x0, x0, x4
  2037e0:	f90053e0 	str	x0, [sp, #160]
  2037e4:	14000002 	b	2037ec <_vsnprintf+0x8dc>
  2037e8:	91000484 	add	x4, x4, #0x1
  2037ec:	f90043ea 	str	x10, [sp, #128]
            out(' ', buffer, idx++, maxlen);
  2037f0:	aa1c03e2 	mov	x2, x28
  2037f4:	f9004be4 	str	x4, [sp, #144]
  2037f8:	52800400 	mov	w0, #0x20                  	// #32
  2037fc:	aa1403e3 	mov	x3, x20
  203800:	aa1503e1 	mov	x1, x21
  203804:	d63f0260 	blr	x19
  203808:	f9404be4 	ldr	x4, [sp, #144]
          while (l++ < width) {
  20380c:	f94053e0 	ldr	x0, [sp, #160]
            out(' ', buffer, idx++, maxlen);
  203810:	aa0403fc 	mov	x28, x4
          while (l++ < width) {
  203814:	f94043ea 	ldr	x10, [sp, #128]
  203818:	eb00009f 	cmp	x4, x0
  20381c:	54fffe61 	b.ne	2037e8 <_vsnprintf+0x8d8>  // b.any
  203820:	11000720 	add	w0, w25, #0x1
  203824:	b90093e0 	str	w0, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  203828:	39400140 	ldrb	w0, [x10]
  20382c:	35ffdde0 	cbnz	w0, 2033e8 <_vsnprintf+0x4d8>
  203830:	17fffddd 	b	202fa4 <_vsnprintf+0x94>
        const int prec = (int)va_arg(va, int);
  203834:	f94047e0 	ldr	x0, [sp, #136]
  203838:	8b38c000 	add	x0, x0, w24, sxtw
  20383c:	2a0103f8 	mov	w24, w1
  203840:	17ffff9f 	b	2036bc <_vsnprintf+0x7ac>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203844:	37f812d8 	tbnz	w24, #31, 203a9c <_vsnprintf+0xb8c>
  203848:	91002ec2 	add	x2, x22, #0xb
  20384c:	aa1603e0 	mov	x0, x22
  203850:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203854:	39400004 	ldrb	w4, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, value, false, base, precision, width, flags);
  203858:	2a1703e7 	mov	w7, w23
  20385c:	2a0403e4 	mov	w4, w4
  203860:	b9000be6 	str	w6, [sp, #8]
  203864:	aa0103e6 	mov	x6, x1
  203868:	b90003f9 	str	w25, [sp]
  20386c:	aa1c03e2 	mov	x2, x28
  203870:	52800005 	mov	w5, #0x0                   	// #0
  203874:	17ffff61 	b	2035f8 <_vsnprintf+0x6e8>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203878:	37f80e38 	tbnz	w24, #31, 203a3c <_vsnprintf+0xb2c>
  20387c:	91002ec2 	add	x2, x22, #0xb
  203880:	aa1603e0 	mov	x0, x22
  203884:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203888:	39400005 	ldrb	w5, [x0]
  20388c:	2a0503e4 	mov	w4, w5
  203890:	17ffff53 	b	2035dc <_vsnprintf+0x6cc>
          flags &= ~(FLAGS_PLUS | FLAGS_SPACE);
  203894:	121c74c6 	and	w6, w6, #0xfffffff3
  203898:	d2800041 	mov	x1, #0x2                   	// #2
  20389c:	17ffff97 	b	2036f8 <_vsnprintf+0x7e8>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  2038a0:	37f808f8 	tbnz	w24, #31, 2039bc <_vsnprintf+0xaac>
  2038a4:	91003ec2 	add	x2, x22, #0xf
  2038a8:	aa1603e0 	mov	x0, x22
  2038ac:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2038b0:	f9400004 	ldr	x4, [x0]
  2038b4:	2a1703e7 	mov	w7, w23
  2038b8:	aa1c03e2 	mov	x2, x28
  2038bc:	b90003f9 	str	w25, [sp]
  2038c0:	b9000be6 	str	w6, [sp, #8]
  2038c4:	aa0103e6 	mov	x6, x1
  2038c8:	17fffe15 	b	20311c <_vsnprintf+0x20c>
            const long long value = va_arg(va, long long);
  2038cc:	37f80898 	tbnz	w24, #31, 2039dc <_vsnprintf+0xacc>
  2038d0:	91003ec2 	add	x2, x22, #0xf
  2038d4:	aa1603e0 	mov	x0, x22
  2038d8:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2038dc:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long_long(out, buffer, idx, maxlen, (unsigned long long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  2038e0:	2a1703e7 	mov	w7, w23
  2038e4:	aa1c03e2 	mov	x2, x28
  2038e8:	b90003f9 	str	w25, [sp]
  2038ec:	f10000bf 	cmp	x5, #0x0
  2038f0:	b9000be6 	str	w6, [sp, #8]
  2038f4:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  2038f8:	aa0103e6 	mov	x6, x1
  2038fc:	d37ffca5 	lsr	x5, x5, #63
  203900:	17fffe08 	b	203120 <_vsnprintf+0x210>
        const char* p = va_arg(va, char*);
  203904:	f94047e0 	ldr	x0, [sp, #136]
  203908:	8b38c000 	add	x0, x0, w24, sxtw
  20390c:	2a0103f8 	mov	w24, w1
  203910:	17fffe9c 	b	203380 <_vsnprintf+0x470>
          idx = _ntoa_long_long(out, buffer, idx, maxlen, (uintptr_t)va_arg(va, void*), false, 16U, precision, width, flags);
  203914:	f94047e1 	ldr	x1, [sp, #136]
  203918:	8b38c021 	add	x1, x1, w24, sxtw
  20391c:	2a0203f8 	mov	w24, w2
  203920:	17fffdf8 	b	203100 <_vsnprintf+0x1f0>
        idx = _ftoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  203924:	f9404fe2 	ldr	x2, [sp, #152]
  203928:	b94077e0 	ldr	w0, [sp, #116]
  20392c:	b90077e1 	str	w1, [sp, #116]
  203930:	8b20c040 	add	x0, x2, w0, sxtw
  203934:	17fffe65 	b	2032c8 <_vsnprintf+0x3b8>
        idx = _etoa(out, buffer, idx, maxlen, va_arg(va, double), precision, width, flags);
  203938:	f9404fe2 	ldr	x2, [sp, #152]
  20393c:	b94077e0 	ldr	w0, [sp, #116]
  203940:	b90077e1 	str	w1, [sp, #116]
  203944:	8b20c040 	add	x0, x2, w0, sxtw
  203948:	17fffe4e 	b	203280 <_vsnprintf+0x370>
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  20394c:	f94047e0 	ldr	x0, [sp, #136]
  203950:	8b38c000 	add	x0, x0, w24, sxtw
  203954:	2a0103f8 	mov	w24, w1
  203958:	17fffe6f 	b	203314 <_vsnprintf+0x404>
            const long value = va_arg(va, long);
  20395c:	37f80818 	tbnz	w24, #31, 203a5c <_vsnprintf+0xb4c>
  203960:	91003ec2 	add	x2, x22, #0xf
  203964:	aa1603e0 	mov	x0, x22
  203968:	927df056 	and	x22, x2, #0xfffffffffffffff8
  20396c:	f9400005 	ldr	x5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned long)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  203970:	2a1703e7 	mov	w7, w23
  203974:	aa1c03e2 	mov	x2, x28
  203978:	b90003f9 	str	w25, [sp]
  20397c:	f10000bf 	cmp	x5, #0x0
  203980:	b9000be6 	str	w6, [sp, #8]
  203984:	da85a4a4 	cneg	x4, x5, lt	// lt = tstop
  203988:	aa0103e6 	mov	x6, x1
  20398c:	d37ffca5 	lsr	x5, x5, #63
  203990:	17ffff1a 	b	2035f8 <_vsnprintf+0x6e8>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  203994:	37f80758 	tbnz	w24, #31, 203a7c <_vsnprintf+0xb6c>
  203998:	91003ec2 	add	x2, x22, #0xf
  20399c:	aa1603e0 	mov	x0, x22
  2039a0:	927df056 	and	x22, x2, #0xfffffffffffffff8
  2039a4:	f9400004 	ldr	x4, [x0]
  2039a8:	2a1703e7 	mov	w7, w23
  2039ac:	b90003f9 	str	w25, [sp]
  2039b0:	b9000be6 	str	w6, [sp, #8]
  2039b4:	aa0103e6 	mov	x6, x1
  2039b8:	17ffffad 	b	20386c <_vsnprintf+0x95c>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  2039bc:	11002302 	add	w2, w24, #0x8
  2039c0:	7100005f 	cmp	w2, #0x0
  2039c4:	540007cd 	b.le	203abc <_vsnprintf+0xbac>
  2039c8:	91003ec3 	add	x3, x22, #0xf
  2039cc:	aa1603e0 	mov	x0, x22
  2039d0:	2a0203f8 	mov	w24, w2
  2039d4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  2039d8:	17ffffb6 	b	2038b0 <_vsnprintf+0x9a0>
            const long long value = va_arg(va, long long);
  2039dc:	11002302 	add	w2, w24, #0x8
  2039e0:	7100005f 	cmp	w2, #0x0
  2039e4:	5400074d 	b.le	203acc <_vsnprintf+0xbbc>
  2039e8:	91003ec3 	add	x3, x22, #0xf
  2039ec:	aa1603e0 	mov	x0, x22
  2039f0:	2a0203f8 	mov	w24, w2
  2039f4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  2039f8:	17ffffb9 	b	2038dc <_vsnprintf+0x9cc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  2039fc:	37f808b8 	tbnz	w24, #31, 203b10 <_vsnprintf+0xc00>
  203a00:	aa1603e0 	mov	x0, x22
  203a04:	91002ec2 	add	x2, x22, #0xb
  203a08:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203a0c:	b9400004 	ldr	w4, [x0]
  203a10:	17ffff92 	b	203858 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203a14:	37f80998 	tbnz	w24, #31, 203b44 <_vsnprintf+0xc34>
  203a18:	91002ec2 	add	x2, x22, #0xb
  203a1c:	aa1603e0 	mov	x0, x22
  203a20:	927df056 	and	x22, x2, #0xfffffffffffffff8
  203a24:	b9400005 	ldr	w5, [x0]
            idx = _ntoa_long(out, buffer, idx, maxlen, (unsigned int)(value > 0 ? value : 0 - value), value < 0, base, precision, width, flags);
  203a28:	710000bf 	cmp	w5, #0x0
  203a2c:	5a85a4a4 	cneg	w4, w5, lt	// lt = tstop
  203a30:	17fffeeb 	b	2035dc <_vsnprintf+0x6cc>
  for (s = str; *s && maxsize--; ++s);
  203a34:	b90093ff 	str	wzr, [sp, #144]
  203a38:	17fffe61 	b	2033bc <_vsnprintf+0x4ac>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203a3c:	11002302 	add	w2, w24, #0x8
  203a40:	7100005f 	cmp	w2, #0x0
  203a44:	5400078d 	b.le	203b34 <_vsnprintf+0xc24>
  203a48:	91002ec3 	add	x3, x22, #0xb
  203a4c:	aa1603e0 	mov	x0, x22
  203a50:	2a0203f8 	mov	w24, w2
  203a54:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203a58:	17ffff8c 	b	203888 <_vsnprintf+0x978>
            const long value = va_arg(va, long);
  203a5c:	11002302 	add	w2, w24, #0x8
  203a60:	7100005f 	cmp	w2, #0x0
  203a64:	54000aad 	b.le	203bb8 <_vsnprintf+0xca8>
  203a68:	91003ec3 	add	x3, x22, #0xf
  203a6c:	aa1603e0 	mov	x0, x22
  203a70:	2a0203f8 	mov	w24, w2
  203a74:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203a78:	17ffffbd 	b	20396c <_vsnprintf+0xa5c>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  203a7c:	11002302 	add	w2, w24, #0x8
  203a80:	7100005f 	cmp	w2, #0x0
  203a84:	540003ed 	b.le	203b00 <_vsnprintf+0xbf0>
  203a88:	91003ec3 	add	x3, x22, #0xf
  203a8c:	aa1603e0 	mov	x0, x22
  203a90:	2a0203f8 	mov	w24, w2
  203a94:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203a98:	17ffffc3 	b	2039a4 <_vsnprintf+0xa94>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203a9c:	11002302 	add	w2, w24, #0x8
  203aa0:	7100005f 	cmp	w2, #0x0
  203aa4:	5400082d 	b.le	203ba8 <_vsnprintf+0xc98>
  203aa8:	91002ec3 	add	x3, x22, #0xb
  203aac:	aa1603e0 	mov	x0, x22
  203ab0:	2a0203f8 	mov	w24, w2
  203ab4:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203ab8:	17ffff67 	b	203854 <_vsnprintf+0x944>
            idx = _ntoa_long_long(out, buffer, idx, maxlen, va_arg(va, unsigned long long), false, base, precision, width, flags);
  203abc:	f94047e0 	ldr	x0, [sp, #136]
  203ac0:	8b38c000 	add	x0, x0, w24, sxtw
  203ac4:	2a0203f8 	mov	w24, w2
  203ac8:	17ffff7a 	b	2038b0 <_vsnprintf+0x9a0>
            const long long value = va_arg(va, long long);
  203acc:	f94047e0 	ldr	x0, [sp, #136]
  203ad0:	8b38c000 	add	x0, x0, w24, sxtw
  203ad4:	2a0203f8 	mov	w24, w2
  203ad8:	17ffff81 	b	2038dc <_vsnprintf+0x9cc>
          while (l++ < width) {
  203adc:	52800040 	mov	w0, #0x2                   	// #2
  203ae0:	b90083e0 	str	w0, [sp, #128]
        out((char)va_arg(va, int), buffer, idx++, maxlen);
  203ae4:	36ffc138 	tbz	w24, #31, 203308 <_vsnprintf+0x3f8>
  203ae8:	17fffe70 	b	2034a8 <_vsnprintf+0x598>
          while (l++ < width) {
  203aec:	b94093e1 	ldr	w1, [sp, #144]
  203af0:	11000421 	add	w1, w1, #0x1
  203af4:	b90093e1 	str	w1, [sp, #144]
        while ((*p != 0) && (!(flags & FLAGS_PRECISION) || precision--)) {
  203af8:	35ffc780 	cbnz	w0, 2033e8 <_vsnprintf+0x4d8>
  203afc:	17fffd2a 	b	202fa4 <_vsnprintf+0x94>
            idx = _ntoa_long(out, buffer, idx, maxlen, va_arg(va, unsigned long), false, base, precision, width, flags);
  203b00:	f94047e0 	ldr	x0, [sp, #136]
  203b04:	8b38c000 	add	x0, x0, w24, sxtw
  203b08:	2a0203f8 	mov	w24, w2
  203b0c:	17ffffa6 	b	2039a4 <_vsnprintf+0xa94>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203b10:	11002302 	add	w2, w24, #0x8
  203b14:	7100005f 	cmp	w2, #0x0
  203b18:	5400060d 	b.le	203bd8 <_vsnprintf+0xcc8>
  203b1c:	aa1603e0 	mov	x0, x22
  203b20:	91002ec3 	add	x3, x22, #0xb
  203b24:	2a0203f8 	mov	w24, w2
  203b28:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203b2c:	b9400004 	ldr	w4, [x0]
  203b30:	17ffff4a 	b	203858 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203b34:	f94047e0 	ldr	x0, [sp, #136]
  203b38:	8b38c000 	add	x0, x0, w24, sxtw
  203b3c:	2a0203f8 	mov	w24, w2
  203b40:	17ffff52 	b	203888 <_vsnprintf+0x978>
  203b44:	11002302 	add	w2, w24, #0x8
  203b48:	7100005f 	cmp	w2, #0x0
  203b4c:	5400050d 	b.le	203bec <_vsnprintf+0xcdc>
  203b50:	91002ec3 	add	x3, x22, #0xb
  203b54:	aa1603e0 	mov	x0, x22
  203b58:	2a0203f8 	mov	w24, w2
  203b5c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203b60:	17ffffb1 	b	203a24 <_vsnprintf+0xb14>
  203b64:	11002302 	add	w2, w24, #0x8
  203b68:	7100005f 	cmp	w2, #0x0
  203b6c:	540002ed 	b.le	203bc8 <_vsnprintf+0xcb8>
  203b70:	91002ec3 	add	x3, x22, #0xb
  203b74:	aa1603e0 	mov	x0, x22
  203b78:	2a0203f8 	mov	w24, w2
  203b7c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203b80:	17fffe93 	b	2035cc <_vsnprintf+0x6bc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203b84:	11002302 	add	w2, w24, #0x8
  203b88:	7100005f 	cmp	w2, #0x0
  203b8c:	5400038d 	b.le	203bfc <_vsnprintf+0xcec>
  203b90:	aa1603e0 	mov	x0, x22
  203b94:	91002ec3 	add	x3, x22, #0xb
  203b98:	2a0203f8 	mov	w24, w2
  203b9c:	927df076 	and	x22, x3, #0xfffffffffffffff8
  203ba0:	79400004 	ldrh	w4, [x0]
  203ba4:	17ffff2d 	b	203858 <_vsnprintf+0x948>
  203ba8:	f94047e0 	ldr	x0, [sp, #136]
  203bac:	8b38c000 	add	x0, x0, w24, sxtw
  203bb0:	2a0203f8 	mov	w24, w2
  203bb4:	17ffff28 	b	203854 <_vsnprintf+0x944>
            const long value = va_arg(va, long);
  203bb8:	f94047e0 	ldr	x0, [sp, #136]
  203bbc:	8b38c000 	add	x0, x0, w24, sxtw
  203bc0:	2a0203f8 	mov	w24, w2
  203bc4:	17ffff6a 	b	20396c <_vsnprintf+0xa5c>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203bc8:	f94047e0 	ldr	x0, [sp, #136]
  203bcc:	8b38c000 	add	x0, x0, w24, sxtw
  203bd0:	2a0203f8 	mov	w24, w2
  203bd4:	17fffe7e 	b	2035cc <_vsnprintf+0x6bc>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203bd8:	f94047e0 	ldr	x0, [sp, #136]
  203bdc:	8b38c000 	add	x0, x0, w24, sxtw
  203be0:	2a0203f8 	mov	w24, w2
  203be4:	b9400004 	ldr	w4, [x0]
  203be8:	17ffff1c 	b	203858 <_vsnprintf+0x948>
            const int value = (flags & FLAGS_CHAR) ? (char)va_arg(va, int) : (flags & FLAGS_SHORT) ? (short int)va_arg(va, int) : va_arg(va, int);
  203bec:	f94047e0 	ldr	x0, [sp, #136]
  203bf0:	8b38c000 	add	x0, x0, w24, sxtw
  203bf4:	2a0203f8 	mov	w24, w2
  203bf8:	17ffff8b 	b	203a24 <_vsnprintf+0xb14>
            const unsigned int value = (flags & FLAGS_CHAR) ? (unsigned char)va_arg(va, unsigned int) : (flags & FLAGS_SHORT) ? (unsigned short int)va_arg(va, unsigned int) : va_arg(va, unsigned int);
  203bfc:	f94047e0 	ldr	x0, [sp, #136]
  203c00:	8b38c000 	add	x0, x0, w24, sxtw
  203c04:	2a0203f8 	mov	w24, w2
  203c08:	79400004 	ldrh	w4, [x0]
  203c0c:	17ffff13 	b	203858 <_vsnprintf+0x948>
  return (ch >= '0') && (ch <= '9');
  203c10:	5100c002 	sub	w2, w0, #0x30
  unsigned int i = 0U;
  203c14:	52800019 	mov	w25, #0x0                   	// #0
    if (_is_digit(*format)) {
  203c18:	12001c42 	and	w2, w2, #0xff
  203c1c:	7100245f 	cmp	w2, #0x9
  203c20:	54ffad48 	b.hi	2031c8 <_vsnprintf+0x2b8>  // b.pmore
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  203c24:	52800143 	mov	w3, #0xa                   	// #10
  203c28:	1b030325 	madd	w5, w25, w3, w0
  while (_is_digit(**str)) {
  203c2c:	39400020 	ldrb	w0, [x1]
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  203c30:	aa0103fa 	mov	x26, x1
  203c34:	91000421 	add	x1, x1, #0x1
  return (ch >= '0') && (ch <= '9');
  203c38:	5100c002 	sub	w2, w0, #0x30
    i = i * 10U + (unsigned int)(*((*str)++) - '0');
  203c3c:	5100c0b9 	sub	w25, w5, #0x30
  while (_is_digit(**str)) {
  203c40:	12001c42 	and	w2, w2, #0xff
  203c44:	7100245f 	cmp	w2, #0x9
  203c48:	54ffff09 	b.ls	203c28 <_vsnprintf+0xd18>  // b.plast
  203c4c:	17fffd5f 	b	2031c8 <_vsnprintf+0x2b8>

0000000000203c50 <sddf_printf_>:


///////////////////////////////////////////////////////////////////////////////

int sddf_printf_(const char* format, ...)
{
  203c50:	a9ae7bfd 	stp	x29, x30, [sp, #-288]!
  va_list va;
  va_start(va, format);
  203c54:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  203c58:	128006ea 	mov	w10, #0xffffffc8            	// #-56
{
  203c5c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203c60:	910383eb 	add	x11, sp, #0xe0
  203c64:	910483e8 	add	x8, sp, #0x120
  203c68:	a90423e8 	stp	x8, x8, [sp, #64]
{
  203c6c:	aa0003e8 	mov	x8, x0
  char buffer[1];
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203c70:	f0ffffe0 	adrp	x0, 202000 <main+0x60>
  203c74:	911d0000 	add	x0, x0, #0x740
  va_start(va, format);
  203c78:	f9002beb 	str	x11, [sp, #80]
  203c7c:	290b27ea 	stp	w10, w9, [sp, #88]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203c80:	a94437ec 	ldp	x12, x13, [sp, #64]
  203c84:	a90137ec 	stp	x12, x13, [sp, #16]
  203c88:	a9452fea 	ldp	x10, x11, [sp, #80]
  203c8c:	a9022fea 	stp	x10, x11, [sp, #32]
{
  203c90:	3d801be0 	str	q0, [sp, #96]
  203c94:	3d801fe1 	str	q1, [sp, #112]
  203c98:	3d8023e2 	str	q2, [sp, #128]
  203c9c:	3d8027e3 	str	q3, [sp, #144]
  203ca0:	3d802be4 	str	q4, [sp, #160]
  203ca4:	3d802fe5 	str	q5, [sp, #176]
  203ca8:	3d8033e6 	str	q6, [sp, #192]
  203cac:	3d8037e7 	str	q7, [sp, #208]
  203cb0:	a90e8be1 	stp	x1, x2, [sp, #232]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203cb4:	9100e3e1 	add	x1, sp, #0x38
  203cb8:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  203cbc:	a90f93e3 	stp	x3, x4, [sp, #248]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203cc0:	910043e4 	add	x4, sp, #0x10
  203cc4:	aa0803e3 	mov	x3, x8
{
  203cc8:	a9109be5 	stp	x5, x6, [sp, #264]
  203ccc:	f9008fe7 	str	x7, [sp, #280]
  const int ret = _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203cd0:	97fffc90 	bl	202f10 <_vsnprintf>
  va_end(va);
  return ret;
}
  203cd4:	a8d27bfd 	ldp	x29, x30, [sp], #288
  203cd8:	d65f03c0 	ret
  203cdc:	d503201f 	nop

0000000000203ce0 <sddf_sprintf_>:


int sddf_sprintf_(char* buffer, const char* format, ...)
{
  203ce0:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  203ce4:	12800fe9 	mov	w9, #0xffffff80            	// #-128
  203ce8:	128005ea 	mov	w10, #0xffffffd0            	// #-48
{
  203cec:	910003fd 	mov	x29, sp
  va_start(va, format);
  203cf0:	910343e8 	add	x8, sp, #0xd0
  203cf4:	910403eb 	add	x11, sp, #0x100
  203cf8:	a9032feb 	stp	x11, x11, [sp, #48]
  203cfc:	f90023e8 	str	x8, [sp, #64]
{
  203d00:	aa0103e8 	mov	x8, x1
  va_start(va, format);
  203d04:	290927ea 	stp	w10, w9, [sp, #72]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203d08:	aa0003e1 	mov	x1, x0
  203d0c:	a94337ec 	ldp	x12, x13, [sp, #48]
  203d10:	f0ffffe0 	adrp	x0, 202000 <main+0x60>
  203d14:	a9442fea 	ldp	x10, x11, [sp, #64]
  203d18:	910b0000 	add	x0, x0, #0x2c0
  203d1c:	a90137ec 	stp	x12, x13, [sp, #16]
  203d20:	a9022fea 	stp	x10, x11, [sp, #32]
{
  203d24:	3d8017e0 	str	q0, [sp, #80]
  203d28:	3d801be1 	str	q1, [sp, #96]
  203d2c:	3d801fe2 	str	q2, [sp, #112]
  203d30:	3d8023e3 	str	q3, [sp, #128]
  203d34:	3d8027e4 	str	q4, [sp, #144]
  203d38:	3d802be5 	str	q5, [sp, #160]
  203d3c:	3d802fe6 	str	q6, [sp, #176]
  203d40:	3d8033e7 	str	q7, [sp, #192]
  203d44:	a90d0fe2 	stp	x2, x3, [sp, #208]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203d48:	aa0803e3 	mov	x3, x8
  203d4c:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
{
  203d50:	a90e17e4 	stp	x4, x5, [sp, #224]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203d54:	910043e4 	add	x4, sp, #0x10
{
  203d58:	a90f1fe6 	stp	x6, x7, [sp, #240]
  const int ret = _vsnprintf(_out_buffer, buffer, (size_t)-1, format, va);
  203d5c:	97fffc6d 	bl	202f10 <_vsnprintf>
  va_end(va);
  return ret;
}
  203d60:	a8d07bfd 	ldp	x29, x30, [sp], #256
  203d64:	d65f03c0 	ret
  203d68:	d503201f 	nop
  203d6c:	d503201f 	nop

0000000000203d70 <sddf_snprintf_>:


int sddf_snprintf_(char* buffer, size_t count, const char* format, ...)
{
  203d70:	a9b07bfd 	stp	x29, x30, [sp, #-256]!
  va_list va;
  va_start(va, format);
  203d74:	128004e8 	mov	w8, #0xffffffd8            	// #-40
  203d78:	12800fea 	mov	w10, #0xffffff80            	// #-128
{
  203d7c:	910003fd 	mov	x29, sp
  va_start(va, format);
  203d80:	910343e9 	add	x9, sp, #0xd0
  203d84:	910403eb 	add	x11, sp, #0x100
  203d88:	a9032feb 	stp	x11, x11, [sp, #48]
  203d8c:	f90023e9 	str	x9, [sp, #64]
{
  203d90:	aa0103e9 	mov	x9, x1
  va_start(va, format);
  203d94:	29092be8 	stp	w8, w10, [sp, #72]
{
  203d98:	aa0203e8 	mov	x8, x2
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  203d9c:	a94337ec 	ldp	x12, x13, [sp, #48]
  203da0:	aa0003e1 	mov	x1, x0
  203da4:	a9442fea 	ldp	x10, x11, [sp, #64]
  203da8:	aa0903e2 	mov	x2, x9
  203dac:	f0ffffe0 	adrp	x0, 202000 <main+0x60>
  203db0:	910b0000 	add	x0, x0, #0x2c0
  203db4:	a90137ec 	stp	x12, x13, [sp, #16]
  203db8:	a9022fea 	stp	x10, x11, [sp, #32]
{
  203dbc:	3d8017e0 	str	q0, [sp, #80]
  203dc0:	3d801be1 	str	q1, [sp, #96]
  203dc4:	3d801fe2 	str	q2, [sp, #112]
  203dc8:	3d8023e3 	str	q3, [sp, #128]
  203dcc:	3d8027e4 	str	q4, [sp, #144]
  203dd0:	3d802be5 	str	q5, [sp, #160]
  203dd4:	3d802fe6 	str	q6, [sp, #176]
  203dd8:	3d8033e7 	str	q7, [sp, #192]
  203ddc:	a90d93e3 	stp	x3, x4, [sp, #216]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  203de0:	910043e4 	add	x4, sp, #0x10
  203de4:	aa0803e3 	mov	x3, x8
{
  203de8:	a90e9be5 	stp	x5, x6, [sp, #232]
  203dec:	f9007fe7 	str	x7, [sp, #248]
  const int ret = _vsnprintf(_out_buffer, buffer, count, format, va);
  203df0:	97fffc48 	bl	202f10 <_vsnprintf>
  va_end(va);
  return ret;
}
  203df4:	a8d07bfd 	ldp	x29, x30, [sp], #256
  203df8:	d65f03c0 	ret
  203dfc:	d503201f 	nop

0000000000203e00 <sddf_vprintf_>:


int sddf_vprintf_(const char* format, va_list va)
{
  203e00:	aa0103e5 	mov	x5, x1
  203e04:	a9bc7bfd 	stp	x29, x30, [sp, #-64]!
  char buffer[1];
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203e08:	aa0003e3 	mov	x3, x0
{
  203e0c:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_char, buffer, (size_t)-1, format, va);
  203e10:	a9401ca6 	ldp	x6, x7, [x5]
  203e14:	f9000be6 	str	x6, [sp, #16]
  203e18:	910043e4 	add	x4, sp, #0x10
  203e1c:	9100e3e1 	add	x1, sp, #0x38
  203e20:	f94008a6 	ldr	x6, [x5, #16]
  203e24:	f9000fe7 	str	x7, [sp, #24]
  203e28:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  203e2c:	f0ffffe0 	adrp	x0, 202000 <main+0x60>
  203e30:	f9400ca5 	ldr	x5, [x5, #24]
  203e34:	911d0000 	add	x0, x0, #0x740
  203e38:	a90217e6 	stp	x6, x5, [sp, #32]
  203e3c:	97fffc35 	bl	202f10 <_vsnprintf>
}
  203e40:	a8c47bfd 	ldp	x29, x30, [sp], #64
  203e44:	d65f03c0 	ret
  203e48:	d503201f 	nop
  203e4c:	d503201f 	nop

0000000000203e50 <sddf_vsnprintf_>:


int sddf_vsnprintf_(char* buffer, size_t count, const char* format, va_list va)
{
  203e50:	aa0303e5 	mov	x5, x3
  203e54:	a9bd7bfd 	stp	x29, x30, [sp, #-48]!
  203e58:	aa0103e4 	mov	x4, x1
  203e5c:	910003fd 	mov	x29, sp
  return _vsnprintf(_out_buffer, buffer, count, format, va);
  203e60:	a9401ca8 	ldp	x8, x7, [x5]
  203e64:	aa0003e1 	mov	x1, x0
  203e68:	a94114a6 	ldp	x6, x5, [x5, #16]
  203e6c:	aa0203e3 	mov	x3, x2
  203e70:	f0ffffe0 	adrp	x0, 202000 <main+0x60>
  203e74:	910b0000 	add	x0, x0, #0x2c0
  203e78:	aa0403e2 	mov	x2, x4
  203e7c:	910043e4 	add	x4, sp, #0x10
  203e80:	a9011fe8 	stp	x8, x7, [sp, #16]
  203e84:	a90217e6 	stp	x6, x5, [sp, #32]
  203e88:	97fffc22 	bl	202f10 <_vsnprintf>
}
  203e8c:	a8c37bfd 	ldp	x29, x30, [sp], #48
  203e90:	d65f03c0 	ret
  203e94:	d503201f 	nop
  203e98:	d503201f 	nop
  203e9c:	d503201f 	nop

0000000000203ea0 <sddf_fctprintf>:


int sddf_fctprintf(void (*out)(char character, void* arg), void* arg, const char* format, ...)
{
  203ea0:	a9af7bfd 	stp	x29, x30, [sp, #-272]!
  va_list va;
  va_start(va, format);
  203ea4:	12800feb 	mov	w11, #0xffffff80            	// #-128
  203ea8:	128004e9 	mov	w9, #0xffffffd8            	// #-40
{
  203eac:	910003fd 	mov	x29, sp
  va_start(va, format);
  203eb0:	910383ea 	add	x10, sp, #0xe0
  203eb4:	910443e8 	add	x8, sp, #0x110
  203eb8:	a90423e8 	stp	x8, x8, [sp, #64]
{
  203ebc:	aa0203e8 	mov	x8, x2
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  203ec0:	92800002 	mov	x2, #0xffffffffffffffff    	// #-1
  va_start(va, format);
  203ec4:	f9002bea 	str	x10, [sp, #80]
{
  203ec8:	aa0003ea 	mov	x10, x0
  va_start(va, format);
  203ecc:	290b2fe9 	stp	w9, w11, [sp, #88]
{
  203ed0:	aa0103e9 	mov	x9, x1
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  203ed4:	a9443fee 	ldp	x14, x15, [sp, #64]
  203ed8:	9100c3e1 	add	x1, sp, #0x30
  203edc:	a94537ec 	ldp	x12, x13, [sp, #80]
  203ee0:	f0ffffe0 	adrp	x0, 202000 <main+0x60>
  203ee4:	911d4000 	add	x0, x0, #0x750
  203ee8:	a9013fee 	stp	x14, x15, [sp, #16]
  203eec:	a90237ec 	stp	x12, x13, [sp, #32]
  const out_fct_wrap_type out_fct_wrap = { out, arg };
  203ef0:	a90327ea 	stp	x10, x9, [sp, #48]
{
  203ef4:	3d801be0 	str	q0, [sp, #96]
  203ef8:	3d801fe1 	str	q1, [sp, #112]
  203efc:	3d8023e2 	str	q2, [sp, #128]
  203f00:	3d8027e3 	str	q3, [sp, #144]
  203f04:	3d802be4 	str	q4, [sp, #160]
  203f08:	3d802fe5 	str	q5, [sp, #176]
  203f0c:	3d8033e6 	str	q6, [sp, #192]
  203f10:	3d8037e7 	str	q7, [sp, #208]
  203f14:	a90e93e3 	stp	x3, x4, [sp, #232]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  203f18:	910043e4 	add	x4, sp, #0x10
  203f1c:	aa0803e3 	mov	x3, x8
{
  203f20:	a90f9be5 	stp	x5, x6, [sp, #248]
  203f24:	f90087e7 	str	x7, [sp, #264]
  const int ret = _vsnprintf(_out_fct, (char*)(uintptr_t)&out_fct_wrap, (size_t)-1, format, va);
  203f28:	97fffbfa 	bl	202f10 <_vsnprintf>
  va_end(va);
  return ret;
}
  203f2c:	a8d17bfd 	ldp	x29, x30, [sp], #272
  203f30:	d65f03c0 	ret
	...

0000000000203f40 <_assert_fail>:
 */

#include <sddf/util/printf.h>

void _assert_fail(const char  *assertion, const char  *file, unsigned int line, const char  *function)
{
  203f40:	2a0203e5 	mov	w5, w2
  203f44:	a9bf7bfd 	stp	x29, x30, [sp, #-16]!
  203f48:	aa0103e4 	mov	x4, x1
  203f4c:	910003fd 	mov	x29, sp
    sddf_dprintf("Failed assertion '%s' at %s:%u in function %s\n", assertion, file, line, function);
  203f50:	aa0003e1 	mov	x1, x0
  203f54:	aa0403e2 	mov	x2, x4
  203f58:	aa0303e4 	mov	x4, x3
  203f5c:	b0000000 	adrp	x0, 204000 <__FUNCTION__.1+0x10>
  203f60:	910aa000 	add	x0, x0, #0x2a8
  203f64:	2a0503e3 	mov	w3, w5
  203f68:	97ffff3a 	bl	203c50 <sddf_printf_>
    __builtin_trap();
  203f6c:	d4207d00 	brk	#0x3e8

0000000000203f70 <_sddf_putchar>:

static char string_buffer[MAX_STRING_LENGTH + 1];
static uint32_t local_tail;

void _sddf_putchar(char character)
{
  203f70:	a9be7bfd 	stp	x29, x30, [sp, #-32]!
    string_buffer[local_tail] = character;
  203f74:	f0000001 	adrp	x1, 206000 <state+0x188>
  203f78:	91158021 	add	x1, x1, #0x560
{
  203f7c:	910003fd 	mov	x29, sp
  203f80:	f9000bf3 	str	x19, [sp, #16]
    string_buffer[local_tail] = character;
  203f84:	f0000013 	adrp	x19, 206000 <state+0x188>
  203f88:	b9455263 	ldr	w3, [x19, #1360]
{
  203f8c:	12001c00 	and	w0, w0, #0xff
    local_tail++;
  203f90:	11000462 	add	w2, w3, #0x1
  203f94:	b9055262 	str	w2, [x19, #1360]

    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  203f98:	7140045f 	cmp	w2, #0x1, lsl #12
    string_buffer[local_tail] = character;
  203f9c:	38234820 	strb	w0, [x1, w3, uxtw]
    if (character == FLUSH_CHAR || local_tail == MAX_STRING_LENGTH) {
  203fa0:	7a4a1804 	ccmp	w0, #0xa, #0x4, ne	// ne = any
  203fa4:	540000a1 	b.ne	203fb8 <_sddf_putchar+0x48>  // b.any
        string_buffer[local_tail] = '\0';
        microkit_dbg_puts(string_buffer);
  203fa8:	aa0103e0 	mov	x0, x1
        string_buffer[local_tail] = '\0';
  203fac:	3822483f 	strb	wzr, [x1, w2, uxtw]
        microkit_dbg_puts(string_buffer);
  203fb0:	97fff860 	bl	202130 <microkit_dbg_puts>
        local_tail = 0;
  203fb4:	b905527f 	str	wzr, [x19, #1360]
    }
  203fb8:	f9400bf3 	ldr	x19, [sp, #16]
  203fbc:	a8c27bfd 	ldp	x29, x30, [sp], #32
  203fc0:	d65f03c0 	ret
  203fc4:	00000000 	udf	#0

0000000000203fc8 <__FUNCTION__.8>:
  203fc8:	636f7270 5f737365 5f707261 74696177     process_arp_wait
  203fd8:	00676e69 00000000                       ing.....

0000000000203fe0 <__FUNCTION__.5>:
  203fe0:	74756f72 00000065                       route...

0000000000203fe8 <__FUNCTION__.2>:
  203fe8:	74696e69 00000000                       init....

0000000000203ff0 <__FUNCTION__.1>:
  203ff0:	5f74656e 66667562 5f737265 74696e69     net_buffers_init
	...
  204010:	fff900a3 fff9fff9 fff9fff9 fff9fff9     ................
  204020:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  204030:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  204040:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  204050:	007e0067 fff90067 fff9fff9 fff9fff9     g.~.g...........
  204060:	fff9fff9 fff9fff9 fff9fff9 fff9fff9     ................
  204070:	fff9fff9 012cfff9 fff9fff9 fff9fff9     ......,.........
  204080:	fff9fff9 fff9fff9 012cfff9 012c0090     ..........,...,.
  204090:	007e0067 00000067 00000000 00000000     g.~.g...........

00000000002040a0 <pow10.0>:
  2040a0:	00000000 3ff00000 00000000 40240000     .......?......$@
  2040b0:	00000000 40590000 00000000 408f4000     ......Y@.....@.@
  2040c0:	00000000 40c38800 00000000 40f86a00     .......@.....j.@
  2040d0:	00000000 412e8480 00000000 416312d0     .......A......cA
  2040e0:	00000000 4197d784 00000000 41cdcd65     .......A....e..A
